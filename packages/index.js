'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var require$$0 = _interopDefault(require('events'));
var path = _interopDefault(require('path'));
var util = _interopDefault(require('util'));
var tty = _interopDefault(require('tty'));
var fs = _interopDefault(require('fs'));
var require$$2 = _interopDefault(require('net'));
var _buffer = _interopDefault(require('buffer'));
var string_decoder = _interopDefault(require('string_decoder'));
var require$$1 = _interopDefault(require('stream'));
var zlib = _interopDefault(require('zlib'));
var querystring = _interopDefault(require('querystring'));
var crypto = _interopDefault(require('crypto'));
var assert = _interopDefault(require('assert'));
var url = _interopDefault(require('url'));
var http = _interopDefault(require('http'));
var module$1 = _interopDefault(require('module'));
var constants = _interopDefault(require('constants'));
var dns = _interopDefault(require('dns'));
var readline = _interopDefault(require('readline'));
var child_process = _interopDefault(require('child_process'));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

var callsiteTostring = callSiteToString;

/**
 * Format a CallSite file location to a string.
 */

function callSiteFileLocation(callSite) {
  var fileName;
  var fileLocation = '';

  if (callSite.isNative()) {
    fileLocation = 'native';
  } else if (callSite.isEval()) {
    fileName = callSite.getScriptNameOrSourceURL();
    if (!fileName) {
      fileLocation = callSite.getEvalOrigin();
    }
  } else {
    fileName = callSite.getFileName();
  }

  if (fileName) {
    fileLocation += fileName;

    var lineNumber = callSite.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ':' + lineNumber;

      var columnNumber = callSite.getColumnNumber();
      if (columnNumber) {
        fileLocation += ':' + columnNumber;
      }
    }
  }

  return fileLocation || 'unknown source';
}

/**
 * Format a CallSite to a string.
 */

function callSiteToString(callSite) {
  var addSuffix = true;
  var fileLocation = callSiteFileLocation(callSite);
  var functionName = callSite.getFunctionName();
  var isConstructor = callSite.isConstructor();
  var isMethodCall = !(callSite.isToplevel() || isConstructor);
  var line = '';

  if (isMethodCall) {
    var methodName = callSite.getMethodName();
    var typeName = getConstructorName(callSite);

    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0) {
        line += typeName + '.';
      }

      line += functionName;

      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
        line += ' [as ' + methodName + ']';
      }
    } else {
      line += typeName + '.' + (methodName || '<anonymous>');
    }
  } else if (isConstructor) {
    line += 'new ' + (functionName || '<anonymous>');
  } else if (functionName) {
    line += functionName;
  } else {
    addSuffix = false;
    line += fileLocation;
  }

  if (addSuffix) {
    line += ' (' + fileLocation + ')';
  }

  return line;
}

/**
 * Get constructor name of reviver.
 */

function getConstructorName(obj) {
  var receiver = obj.receiver;
  return receiver.constructor && receiver.constructor.name || null;
}

/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eventListenerCount_1 = eventListenerCount;

/**
 * Get the count of listeners on an event emitter of a specific type.
 */

function eventListenerCount(emitter, type) {
  return emitter.listeners(type).length;
}

var compat = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 * @private
 */

var EventEmitter = require$$0.EventEmitter;

/**
 * Module exports.
 * @public
 */

lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;

  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }

  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = 2;

  // capture the stack
  Error.captureStackTrace(obj);

  // slice the stack
  var stack = obj.stack.slice();

  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;

  return stack[0].toString ? toString : callsiteTostring;
});

lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount() {
  return EventEmitter.listenerCount || eventListenerCount_1;
});

/**
 * Define a lazy property.
 */

function lazyProperty(obj, prop, getter) {
  function get() {
    var val = getter();

    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      value: val
    });

    return val;
  }

  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: true,
    get: get
  });
}

/**
 * Call toString() on the obj
 */

function toString(obj) {
  return obj.toString();
}
});

/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString$1 = compat.callSiteToString;
var eventListenerCount$1 = compat.eventListenerCount;
var relative = path.relative;

/**
 * Module exports.
 */

var depd_1 = depd;

/**
 * Get the path to base files on.
 */

var basePath = process.cwd();

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace(str, namespace) {
  var vals = str.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();

  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];

    // namespace contained
    if (val && (val === '*' || val.toLowerCase() === ns)) {
      return true;
    }
  }

  return false;
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;

  descriptor.get = function getter() {
    return value;
  };

  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value = val;
    };
  }

  delete descriptor.value;
  delete descriptor.writable;

  Object.defineProperty(obj, prop, descriptor);

  return descriptor;
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString(arity) {
  var str = '';

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i;
  }

  return str.substr(2);
}

/**
 * Create stack string from stack.
 */

function createStackString(stack) {
  var str = this.name + ': ' + this.namespace;

  if (this.message) {
    str += ' deprecated ' + this.message;
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString$1(stack[i]);
  }

  return str;
}

/**
 * Create deprecate for namespace in caller.
 */

function depd(namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required');
  }

  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  var file = site[0];

  function deprecate(message) {
    // call to self as log
    log.call(deprecate, message);
  }

  deprecate._file = file;
  deprecate._ignored = isignored(namespace);
  deprecate._namespace = namespace;
  deprecate._traced = istraced(namespace);
  deprecate._warned = Object.create(null);

  deprecate.function = wrapfunction;
  deprecate.property = wrapproperty;

  return deprecate;
}

/**
 * Determine if namespace is ignored.
 */

function isignored(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true;
  }

  var str = process.env.NO_DEPRECATION || '';

  // namespace ignored
  return containsNamespace(str, namespace);
}

/**
 * Determine if namespace is traced.
 */

function istraced(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true;
  }

  var str = process.env.TRACE_DEPRECATION || '';

  // namespace traced
  return containsNamespace(str, namespace);
}

/**
 * Display deprecation message.
 */

function log(message, site) {
  var haslisteners = eventListenerCount$1(process, 'deprecation') !== 0;

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return;
  }

  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack = getStack();
  var file = this._file;

  if (site) {
    // provided site
    depSite = site;
    callSite = callSiteLocation(stack[1]);
    callSite.name = depSite.name;
    file = callSite[0];
  } else {
    // get call site
    i = 2;
    depSite = callSiteLocation(stack[i]);
    callSite = depSite;
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i]);
    callFile = caller[0];

    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break;
    }
  }

  var key = caller ? depSite.join(':') + '__' + caller.join(':') : undefined;

  if (key !== undefined && key in this._warned) {
    // already warned
    return;
  }

  this._warned[key] = true;

  // generate automatic message from call site
  var msg = message;
  if (!msg) {
    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i));
    process.emit('deprecation', err);
    return;
  }

  // format and write message
  var format = process.stderr.isTTY ? formatColor : formatPlain;
  var output = format.call(this, msg, caller, stack.slice(i));
  process.stderr.write(output + '\n', 'utf8');
}

/**
 * Get call site location as array.
 */

function callSiteLocation(callSite) {
  var file = callSite.getFileName() || '<anonymous>';
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file;
  }

  var site = [file, line, colm];

  site.callSite = callSite;
  site.name = callSite.getFunctionName();

  return site;
}

/**
 * Generate a default message from the site.
 */

function defaultMessage(site) {
  var callSite = site.callSite;
  var funcName = site.name;

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation(site) + '>';
  }

  var context = callSite.getThis();
  var typeName = context && callSite.getTypeName();

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined;
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName;
  }

  return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
}

/**
 * Format deprecation message without color.
 */

function formatPlain(msg, caller, stack) {
  var timestamp = new Date().toUTCString();

  var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + callSiteToString$1(stack[i]);
    }

    return formatted;
  }

  if (caller) {
    formatted += ' at ' + formatLocation(caller);
  }

  return formatted;
}

/**
 * Format deprecation message with color.
 */

function formatColor(msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
  ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
  ' \x1b[0m' + msg + '\x1b[39m'; // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + callSiteToString$1(stack[i]) + '\x1b[39m'; // cyan
    }

    return formatted;
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation(caller) + '\x1b[39m'; // cyan
  }

  return formatted;
}

/**
 * Format call site location.
 */

function formatLocation(callSite) {
  return relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
}

/**
 * Get the stack as array of call sites.
 */

function getStack() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;

  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit);

  // capture the stack
  Error.captureStackTrace(obj);

  // slice this function off the top
  var stack = obj.stack.slice(1);

  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;

  return stack;
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace(obj, stack) {
  return stack;
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction(fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function');
  }

  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);

  site.name = fn.name;

  // eslint-disable-next-line no-eval
  var deprecatedfn = eval('(function (' + args + ') {\n' + '"use strict"\n' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '})');

  return deprecatedfn;
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('argument obj must be object');
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

  if (!descriptor) {
    throw new TypeError('must call property on owner object');
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable');
  }

  var deprecate = this;
  var stack = getStack();
  var site = callSiteLocation(stack[1]);

  // set site name
  site.name = prop;

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop, message);
  }

  var get = descriptor.get;
  var set = descriptor.set;

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter() {
      log.call(deprecate, message, site);
      return get.apply(this, arguments);
    };
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter() {
      log.call(deprecate, message, site);
      return set.apply(this, arguments);
    };
  }

  Object.defineProperty(obj, prop, descriptor);
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError(namespace, message, stack) {
  var error = new Error();
  var stackString;

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError
  });

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  });

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString;
      }

      // prepare stack trace
      return stackString = createStackString.call(this, stack);
    },
    set: function setter(val) {
      stackString = val;
    }
  });

  return error;
}

/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var bytes_1 = bytes;
var format_1 = format;
var parse_1 = parse;

/**
 * Module variables.
 * @private
 */

var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;

var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;

var map = {
  b: 1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: (1 << 30) * 1024
};

var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb)$/i;

/**
 * Convert the given value in bytes into a string or parse to string to an integer in bytes.
 *
 * @param {string|number} value
 * @param {{
 *  case: [string],
 *  decimalPlaces: [number]
 *  fixedDecimals: [boolean]
 *  thousandsSeparator: [string]
 *  unitSeparator: [string]
 *  }} [options] bytes options.
 *
 * @returns {string|number|null}
 */

function bytes(value, options) {
  if (typeof value === 'string') {
    return parse(value);
  }

  if (typeof value === 'number') {
    return format(value, options);
  }

  return null;
}

/**
 * Format the given value in bytes into a string.
 *
 * If the value is negative, it is kept as such. If it is a float,
 * it is rounded.
 *
 * @param {number} value
 * @param {object} [options]
 * @param {number} [options.decimalPlaces=2]
 * @param {number} [options.fixedDecimals=false]
 * @param {string} [options.thousandsSeparator=]
 * @param {string} [options.unit=]
 * @param {string} [options.unitSeparator=]
 *
 * @returns {string|null}
 * @public
 */

function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }

  var mag = Math.abs(value);
  var thousandsSeparator = options && options.thousandsSeparator || '';
  var unitSeparator = options && options.unitSeparator || '';
  var decimalPlaces = options && options.decimalPlaces !== undefined ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = options && options.unit || '';

  if (!unit || !map[unit.toLowerCase()]) {
    if (mag >= map.tb) {
      unit = 'TB';
    } else if (mag >= map.gb) {
      unit = 'GB';
    } else if (mag >= map.mb) {
      unit = 'MB';
    } else if (mag >= map.kb) {
      unit = 'KB';
    } else {
      unit = 'B';
    }
  }

  var val = value / map[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);

  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, '$1');
  }

  if (thousandsSeparator) {
    str = str.replace(formatThousandsRegExp, thousandsSeparator);
  }

  return str + unitSeparator + unit;
}

/**
 * Parse the string value into an integer in bytes.
 *
 * If no unit is given, it is assumed the value is in bytes.
 *
 * @param {number|string} val
 *
 * @returns {number|null}
 * @public
 */

function parse(val) {
  if (typeof val === 'number' && !isNaN(val)) {
    return val;
  }

  if (typeof val !== 'string') {
    return null;
  }

  // Test if the string passed is valid
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = 'b';

  if (!results) {
    // Nothing could be extracted from the given string
    floatValue = parseInt(val, 10);
    unit = 'b';
  } else {
    // Retrieve the value and the unit
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }

  return Math.floor(map[unit] * floatValue);
}
bytes_1.format = format_1;
bytes_1.parse = parse_1;

/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */

var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */
var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6
 */
var QUOTE_REGEXP = /([\\"])/g;

/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;

/**
 * Module exports.
 * @public
 */

var format_1$1 = format$1;
var parse_1$1 = parse$1;

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @public
 */

function format$1(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }

  var parameters = obj.parameters;
  var type = obj.type;

  if (!type || !TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid type');
  }

  var string = type;

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param;
    var params = Object.keys(parameters).sort();

    for (var i = 0; i < params.length; i++) {
      param = params[i];

      if (!TOKEN_REGEXP.test(param)) {
        throw new TypeError('invalid parameter name');
      }

      string += '; ' + param + '=' + qstring(parameters[param]);
    }
  }

  return string;
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @public
 */

function parse$1(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  }

  // support req/res-like objects as argument
  var header = typeof string === 'object' ? getcontenttype(string) : string;

  if (typeof header !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }

  var index = header.indexOf(';');
  var type = index !== -1 ? header.substr(0, index).trim() : header.trim();

  if (!TYPE_REGEXP.test(type)) {
    throw new TypeError('invalid media type');
  }

  var obj = new ContentType(type.toLowerCase());

  // parse parameters
  if (index !== -1) {
    var key;
    var match;
    var value;

    PARAM_REGEXP.lastIndex = index;

    while (match = PARAM_REGEXP.exec(header)) {
      if (match.index !== index) {
        throw new TypeError('invalid parameter format');
      }

      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];

      if (value[0] === '"') {
        // remove quotes and escapes
        value = value.substr(1, value.length - 2).replace(QESC_REGEXP, '$1');
      }

      obj.parameters[key] = value;
    }

    if (index !== header.length) {
      throw new TypeError('invalid parameter format');
    }
  }

  return obj;
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @private
 */

function getcontenttype(obj) {
  var header;

  if (typeof obj.getHeader === 'function') {
    // res-like
    header = obj.getHeader('content-type');
  } else if (typeof obj.headers === 'object') {
    // req-like
    header = obj.headers && obj.headers['content-type'];
  }

  if (typeof header !== 'string') {
    throw new TypeError('content-type header is missing from object');
  }

  return header;
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function qstring(val) {
  var str = String(val);

  // no need to quote tokens
  if (TOKEN_REGEXP.test(str)) {
    return str;
  }

  if (str.length > 0 && !TEXT_REGEXP.test(str)) {
    throw new TypeError('invalid parameter value');
  }

  return '"' + str.replace(QUOTE_REGEXP, '\\$1') + '"';
}

/**
 * Class to represent a content type.
 * @private
 */
function ContentType(type) {
  this.parameters = Object.create(null);
  this.type = type;
}

var contentType = {
	format: format_1$1,
	parse: parse_1$1
};

/*!
 * depd
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

var callsiteTostring$1 = callSiteToString$2;

/**
 * Format a CallSite file location to a string.
 */

function callSiteFileLocation$1(callSite) {
  var fileName;
  var fileLocation = '';

  if (callSite.isNative()) {
    fileLocation = 'native';
  } else if (callSite.isEval()) {
    fileName = callSite.getScriptNameOrSourceURL();
    if (!fileName) {
      fileLocation = callSite.getEvalOrigin();
    }
  } else {
    fileName = callSite.getFileName();
  }

  if (fileName) {
    fileLocation += fileName;

    var lineNumber = callSite.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ':' + lineNumber;

      var columnNumber = callSite.getColumnNumber();
      if (columnNumber) {
        fileLocation += ':' + columnNumber;
      }
    }
  }

  return fileLocation || 'unknown source';
}

/**
 * Format a CallSite to a string.
 */

function callSiteToString$2(callSite) {
  var addSuffix = true;
  var fileLocation = callSiteFileLocation$1(callSite);
  var functionName = callSite.getFunctionName();
  var isConstructor = callSite.isConstructor();
  var isMethodCall = !(callSite.isToplevel() || isConstructor);
  var line = '';

  if (isMethodCall) {
    var methodName = callSite.getMethodName();
    var typeName = getConstructorName$1(callSite);

    if (functionName) {
      if (typeName && functionName.indexOf(typeName) !== 0) {
        line += typeName + '.';
      }

      line += functionName;

      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {
        line += ' [as ' + methodName + ']';
      }
    } else {
      line += typeName + '.' + (methodName || '<anonymous>');
    }
  } else if (isConstructor) {
    line += 'new ' + (functionName || '<anonymous>');
  } else if (functionName) {
    line += functionName;
  } else {
    addSuffix = false;
    line += fileLocation;
  }

  if (addSuffix) {
    line += ' (' + fileLocation + ')';
  }

  return line;
}

/**
 * Get constructor name of reviver.
 */

function getConstructorName$1(obj) {
  var receiver = obj.receiver;
  return receiver.constructor && receiver.constructor.name || null;
}

/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eventListenerCount_1$1 = eventListenerCount$2;

/**
 * Get the count of listeners on an event emitter of a specific type.
 */

function eventListenerCount$2(emitter, type) {
  return emitter.listeners(type).length;
}

var compat$1 = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 * @private
 */

var EventEmitter = require$$0.EventEmitter;

/**
 * Module exports.
 * @public
 */

lazyProperty(module.exports, 'callSiteToString', function callSiteToString() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;

  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }

  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = 2;

  // capture the stack
  Error.captureStackTrace(obj);

  // slice the stack
  var stack = obj.stack.slice();

  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;

  return stack[0].toString ? toString : callsiteTostring$1;
});

lazyProperty(module.exports, 'eventListenerCount', function eventListenerCount() {
  return EventEmitter.listenerCount || eventListenerCount_1$1;
});

/**
 * Define a lazy property.
 */

function lazyProperty(obj, prop, getter) {
  function get() {
    var val = getter();

    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      value: val
    });

    return val;
  }

  Object.defineProperty(obj, prop, {
    configurable: true,
    enumerable: true,
    get: get
  });
}

/**
 * Call toString() on the obj
 */

function toString(obj) {
  return obj.toString();
}
});

/*!
 * depd
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var callSiteToString$3 = compat$1.callSiteToString;
var eventListenerCount$3 = compat$1.eventListenerCount;
var relative$1 = path.relative;

/**
 * Module exports.
 */

var depd_1$1 = depd$1;

/**
 * Get the path to base files on.
 */

var basePath$1 = process.cwd();

/**
 * Determine if namespace is contained in the string.
 */

function containsNamespace$1(str, namespace) {
  var val = str.split(/[ ,]+/);

  namespace = String(namespace).toLowerCase();

  for (var i = 0; i < val.length; i++) {
    if (!(str = val[i])) continue;

    // namespace contained
    if (str === '*' || str.toLowerCase() === namespace) {
      return true;
    }
  }

  return false;
}

/**
 * Convert a data descriptor to accessor descriptor.
 */

function convertDataDescriptorToAccessor$1(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;

  descriptor.get = function getter() {
    return value;
  };

  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value = val;
    };
  }

  delete descriptor.value;
  delete descriptor.writable;

  Object.defineProperty(obj, prop, descriptor);

  return descriptor;
}

/**
 * Create arguments string to keep arity.
 */

function createArgumentsString$1(arity) {
  var str = '';

  for (var i = 0; i < arity; i++) {
    str += ', arg' + i;
  }

  return str.substr(2);
}

/**
 * Create stack string from stack.
 */

function createStackString$1(stack) {
  var str = this.name + ': ' + this.namespace;

  if (this.message) {
    str += ' deprecated ' + this.message;
  }

  for (var i = 0; i < stack.length; i++) {
    str += '\n    at ' + callSiteToString$3(stack[i]);
  }

  return str;
}

/**
 * Create deprecate for namespace in caller.
 */

function depd$1(namespace) {
  if (!namespace) {
    throw new TypeError('argument namespace is required');
  }

  var stack = getStack$1();
  var site = callSiteLocation$1(stack[1]);
  var file = site[0];

  function deprecate(message) {
    // call to self as log
    log$1.call(deprecate, message);
  }

  deprecate._file = file;
  deprecate._ignored = isignored$1(namespace);
  deprecate._namespace = namespace;
  deprecate._traced = istraced$1(namespace);
  deprecate._warned = Object.create(null);

  deprecate.function = wrapfunction$1;
  deprecate.property = wrapproperty$1;

  return deprecate;
}

/**
 * Determine if namespace is ignored.
 */

function isignored$1(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.noDeprecation) {
    // --no-deprecation support
    return true;
  }

  var str = process.env.NO_DEPRECATION || '';

  // namespace ignored
  return containsNamespace$1(str, namespace);
}

/**
 * Determine if namespace is traced.
 */

function istraced$1(namespace) {
  /* istanbul ignore next: tested in a child processs */
  if (process.traceDeprecation) {
    // --trace-deprecation support
    return true;
  }

  var str = process.env.TRACE_DEPRECATION || '';

  // namespace traced
  return containsNamespace$1(str, namespace);
}

/**
 * Display deprecation message.
 */

function log$1(message, site) {
  var haslisteners = eventListenerCount$3(process, 'deprecation') !== 0;

  // abort early if no destination
  if (!haslisteners && this._ignored) {
    return;
  }

  var caller;
  var callFile;
  var callSite;
  var i = 0;
  var seen = false;
  var stack = getStack$1();
  var file = this._file;

  if (site) {
    // provided site
    callSite = callSiteLocation$1(stack[1]);
    callSite.name = site.name;
    file = callSite[0];
  } else {
    // get call site
    i = 2;
    site = callSiteLocation$1(stack[i]);
    callSite = site;
  }

  // get caller of deprecated thing in relation to file
  for (; i < stack.length; i++) {
    caller = callSiteLocation$1(stack[i]);
    callFile = caller[0];

    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break;
    }
  }

  var key = caller ? site.join(':') + '__' + caller.join(':') : undefined;

  if (key !== undefined && key in this._warned) {
    // already warned
    return;
  }

  this._warned[key] = true;

  // generate automatic message from call site
  if (!message) {
    message = callSite === site || !callSite.name ? defaultMessage$1(site) : defaultMessage$1(callSite);
  }

  // emit deprecation if listeners exist
  if (haslisteners) {
    var err = DeprecationError$1(this._namespace, message, stack.slice(i));
    process.emit('deprecation', err);
    return;
  }

  // format and write message
  var format = process.stderr.isTTY ? formatColor$1 : formatPlain$1;
  var msg = format.call(this, message, caller, stack.slice(i));
  process.stderr.write(msg + '\n', 'utf8');
}

/**
 * Get call site location as array.
 */

function callSiteLocation$1(callSite) {
  var file = callSite.getFileName() || '<anonymous>';
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();

  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ', ' + file;
  }

  var site = [file, line, colm];

  site.callSite = callSite;
  site.name = callSite.getFunctionName();

  return site;
}

/**
 * Generate a default message from the site.
 */

function defaultMessage$1(site) {
  var callSite = site.callSite;
  var funcName = site.name;

  // make useful anonymous name
  if (!funcName) {
    funcName = '<anonymous@' + formatLocation$1(site) + '>';
  }

  var context = callSite.getThis();
  var typeName = context && callSite.getTypeName();

  // ignore useless type name
  if (typeName === 'Object') {
    typeName = undefined;
  }

  // make useful type name
  if (typeName === 'Function') {
    typeName = context.name || typeName;
  }

  return typeName && callSite.getMethodName() ? typeName + '.' + funcName : funcName;
}

/**
 * Format deprecation message without color.
 */

function formatPlain$1(msg, caller, stack) {
  var timestamp = new Date().toUTCString();

  var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    at ' + callSiteToString$3(stack[i]);
    }

    return formatted;
  }

  if (caller) {
    formatted += ' at ' + formatLocation$1(caller);
  }

  return formatted;
}

/**
 * Format deprecation message with color.
 */

function formatColor$1(msg, caller, stack) {
  var formatted = '\x1b[36;1m' + this._namespace + '\x1b[22;39m' + // bold cyan
  ' \x1b[33;1mdeprecated\x1b[22;39m' + // bold yellow
  ' \x1b[0m' + msg + '\x1b[39m'; // reset

  // add stack trace
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += '\n    \x1b[36mat ' + callSiteToString$3(stack[i]) + '\x1b[39m'; // cyan
    }

    return formatted;
  }

  if (caller) {
    formatted += ' \x1b[36m' + formatLocation$1(caller) + '\x1b[39m'; // cyan
  }

  return formatted;
}

/**
 * Format call site location.
 */

function formatLocation$1(callSite) {
  return relative$1(basePath$1, callSite[0]) + ':' + callSite[1] + ':' + callSite[2];
}

/**
 * Get the stack as array of call sites.
 */

function getStack$1() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;

  Error.prepareStackTrace = prepareObjectStackTrace$1;
  Error.stackTraceLimit = Math.max(10, limit);

  // capture the stack
  Error.captureStackTrace(obj);

  // slice this function off the top
  var stack = obj.stack.slice(1);

  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;

  return stack;
}

/**
 * Capture call site stack from v8.
 */

function prepareObjectStackTrace$1(obj, stack) {
  return stack;
}

/**
 * Return a wrapped function in a deprecation message.
 */

function wrapfunction$1(fn, message) {
  if (typeof fn !== 'function') {
    throw new TypeError('argument fn must be a function');
  }

  var args = createArgumentsString$1(fn.length);
  var stack = getStack$1();
  var site = callSiteLocation$1(stack[1]);

  site.name = fn.name;

  // eslint-disable-next-line no-eval
  var deprecatedfn = eval('(function (' + args + ') {\n' + '"use strict"\n' + 'log.call(deprecate, message, site)\n' + 'return fn.apply(this, arguments)\n' + '})');

  return deprecatedfn;
}

/**
 * Wrap property in a deprecation message.
 */

function wrapproperty$1(obj, prop, message) {
  if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
    throw new TypeError('argument obj must be object');
  }

  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);

  if (!descriptor) {
    throw new TypeError('must call property on owner object');
  }

  if (!descriptor.configurable) {
    throw new TypeError('property must be configurable');
  }

  var deprecate = this;
  var stack = getStack$1();
  var site = callSiteLocation$1(stack[1]);

  // set site name
  site.name = prop;

  // convert data descriptor
  if ('value' in descriptor) {
    descriptor = convertDataDescriptorToAccessor$1(obj, prop, message);
  }

  var get = descriptor.get;
  var set = descriptor.set;

  // wrap getter
  if (typeof get === 'function') {
    descriptor.get = function getter() {
      log$1.call(deprecate, message, site);
      return get.apply(this, arguments);
    };
  }

  // wrap setter
  if (typeof set === 'function') {
    descriptor.set = function setter() {
      log$1.call(deprecate, message, site);
      return set.apply(this, arguments);
    };
  }

  Object.defineProperty(obj, prop, descriptor);
}

/**
 * Create DeprecationError for deprecation
 */

function DeprecationError$1(namespace, message, stack) {
  var error = new Error();
  var stackString;

  Object.defineProperty(error, 'constructor', {
    value: DeprecationError$1
  });

  Object.defineProperty(error, 'message', {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });

  Object.defineProperty(error, 'name', {
    enumerable: false,
    configurable: true,
    value: 'DeprecationError',
    writable: true
  });

  Object.defineProperty(error, 'namespace', {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });

  Object.defineProperty(error, 'stack', {
    configurable: true,
    enumerable: false,
    get: function () {
      if (stackString !== undefined) {
        return stackString;
      }

      // prepare stack trace
      return stackString = createStackString$1.call(this, stack);
    },
    set: function setter(val) {
      stackString = val;
    }
  });

  return error;
}

var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);

function setProtoOf(obj, proto) {
	obj.__proto__ = proto;
	return obj;
}

function mixinProperties(obj, proto) {
	for (var prop in proto) {
		if (!obj.hasOwnProperty(prop)) {
			obj[prop] = proto[prop];
		}
	}
	return obj;
}

var codes = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

var codes$1 = /*#__PURE__*/Object.freeze({
	default: codes
});

var codes$2 = ( codes$1 && codes ) || codes$1;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module exports.
 * @public
 */

var statuses = status;

// status code to message map
status.STATUS_CODES = codes$2;

// array of status codes
status.codes = populateStatusesMap(status, codes$2);

// status codes for redirects
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true

  // status codes for empty bodies
};status.empty = {
  204: true,
  205: true,
  304: true

  // status codes for when you should retry the request
};status.retry = {
  502: true,
  503: true,
  504: true

  /**
   * Populate the statuses map for given codes.
   * @private
   */

};function populateStatusesMap(statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode(code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr;
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status(code) {
  if (typeof code === 'number') {
    if (!status[code]) throw new Error('invalid status code: ' + code);
    return code;
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string');
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status[n]) throw new Error('invalid status code: ' + n);
    return n;
  }

  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util$$1 = util;
  if (typeof util$$1.inherits !== 'function') throw '';
  module.exports = util$$1.inherits;
} catch (e) {
  module.exports = inherits_browser;
}
});

var httpErrors = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 * @private
 */

var deprecate = depd_1$1('http-errors');




/**
 * Module exports.
 * @public
 */

module.exports = createError;
module.exports.HttpError = createHttpErrorConstructor();

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

/**
 * Get the code class of a status code.
 * @private
 */

function codeClass(status) {
  return Number(String(status).charAt(0) + '00');
}

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError() {
  // so much arity going on ~_~
  var err;
  var msg;
  var status = 500;
  var props = {};
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (arg instanceof Error) {
      err = arg;
      status = err.status || err.statusCode || status;
      continue;
    }
    switch (typeof arg) {
      case 'string':
        msg = arg;
        break;
      case 'number':
        status = arg;
        if (i !== 0) {
          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)');
        }
        break;
      case 'object':
        props = arg;
        break;
    }
  }

  if (typeof status === 'number' && (status < 400 || status >= 600)) {
    deprecate('non-error status code; use only 4xx or 5xx status codes');
  }

  if (typeof status !== 'number' || !statuses[status] && (status < 400 || status >= 600)) {
    status = 500;
  }

  // constructor
  var HttpError = createError[status] || createError[codeClass(status)];

  if (!err) {
    // create error
    err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
    Error.captureStackTrace(err, createError);
  }

  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
    // add properties to generic error
    err.expose = status < 500;
    err.status = err.statusCode = status;
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key];
    }
  }

  return err;
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor() {
  function HttpError() {
    throw new TypeError('cannot construct abstract class');
  }

  inherits(HttpError, Error);

  return HttpError;
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ClientError(message) {
    // create the error object
    var msg = message != null ? message : statuses[code];
    var err = new Error(msg);

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError);

    // adjust the [[Prototype]]
    setprototypeof(err, ClientError.prototype);

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    });

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });

    return err;
  }

  inherits(ClientError, HttpError);

  ClientError.prototype.status = code;
  ClientError.prototype.statusCode = code;
  ClientError.prototype.expose = true;

  return ClientError;
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ServerError(message) {
    // create the error object
    var msg = message != null ? message : statuses[code];
    var err = new Error(msg);

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError);

    // adjust the [[Prototype]]
    setprototypeof(err, ServerError.prototype);

    // redefine the error message
    Object.defineProperty(err, 'message', {
      enumerable: true,
      configurable: true,
      value: msg,
      writable: true
    });

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });

    return err;
  }

  inherits(ServerError, HttpError);

  ServerError.prototype.status = code;
  ServerError.prototype.statusCode = code;
  ServerError.prototype.expose = false;

  return ServerError;
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports(exports, codes, HttpError) {
  codes.forEach(function forEachCode(code) {
    var CodeError;
    var name = toIdentifier(statuses[code]);

    switch (codeClass(code)) {
      case 400:
        CodeError = createClientErrorConstructor(HttpError, name, code);
        break;
      case 500:
        CodeError = createServerErrorConstructor(HttpError, name, code);
        break;
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError;
      exports[name] = CodeError;
    }
  });

  // backwards-compatibility
  exports["I'mateapot"] = deprecate.function(exports.ImATeapot, '"I\'mateapot"; use "ImATeapot" instead');
}

/**
 * Convert a string of words to a JavaScript identifier.
 * @private
 */

function toIdentifier(str) {
  return str.split(' ').map(function (token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join('').replace(/[^ _0-9a-z]/gi, '');
}
});
var httpErrors_1 = httpErrors.HttpError;

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse$2(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse$2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

var debug = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1 = debug.coerce;
var debug_2 = debug.disable;
var debug_3 = debug.enable;
var debug_4 = debug.enabled;
var debug_5 = debug.humanize;
var debug_6 = debug.names;
var debug_7 = debug.skips;
var debug_8 = debug.formatters;

var browser = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1 = browser.log;
var browser_2 = browser.formatArgs;
var browser_3 = browser.save;
var browser_4 = browser.load;
var browser_5 = browser.useColors;
var browser_6 = browser.storage;
var browser_7 = browser.colors;

var node = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug$$1) {
  debug$$1.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug$$1.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1 = node.init;
var node_2 = node.log;
var node_3 = node.formatArgs;
var node_4 = node.save;
var node_5 = node.load;
var node_6 = node.useColors;
var node_7 = node.colors;
var node_8 = node.inspectOpts;

var src = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser;
} else {
  module.exports = node;
}
});

var BOMChar = '\uFEFF';

var PrependBOM = PrependBOMWrapper;
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function (str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
};

PrependBOMWrapper.prototype.end = function () {
    return this.encoder.end();
};

//------------------------------------------------------------------------------

var StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function (buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res) return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function') this.options.stripBOM();
    }

    this.pass = true;
    return res;
};

StripBOMWrapper.prototype.end = function () {
    return this.decoder.end();
};

var bomHandling = {
	PrependBOM: PrependBOM,
	StripBOM: StripBOM
};

var Buffer$1 = _buffer.Buffer;

// Export Node.js internal encodings.

var internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",

    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },

    // Codec.
    _internal: InternalCodec
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64") this.encoder = InternalEncoderBase64;else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (new Buffer$1('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = string_decoder.StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function () {};

function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;

//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function (str) {
    return new Buffer$1(str, this.enc);
};

InternalEncoder.prototype.end = function () {};

//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function (str) {
    str = this.prevStr + str;
    var completeQuads = str.length - str.length % 4;
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return new Buffer$1(str, "base64");
};

InternalEncoderBase64.prototype.end = function () {
    return new Buffer$1(this.prevStr, "base64");
};

//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {}

InternalEncoderCesu8.prototype.write = function (str) {
    var buf = new Buffer$1(str.length * 3),
        bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80) buf[bufIdx++] = charCode;else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        } else {
            // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + (charCode >>> 6 & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
};

InternalEncoderCesu8.prototype.end = function () {};

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function (buf) {
    var acc = this.acc,
        contBytes = this.contBytes,
        accBytes = this.accBytes,
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) {
            // Leading byte
            if (contBytes > 0) {
                // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) {
                // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) {
                // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1;accBytes = 1;
            } else if (curByte < 0xF0) {
                // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2;accBytes = 1;
            } else {
                // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else {
            // Continuation byte
            if (contBytes > 0) {
                // We're waiting for it.
                acc = acc << 6 | curByte & 0x3f;
                contBytes--;accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0) res += this.defaultCharUnicode;else if (accBytes === 3 && acc < 0x800) res += this.defaultCharUnicode;else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else {
                // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc;this.contBytes = contBytes;this.accBytes = accBytes;
    return res;
};

InternalDecoderCesu8.prototype.end = function () {
    var res = 0;
    if (this.contBytes > 0) res += this.defaultCharUnicode;
    return res;
};

var Buffer$2 = _buffer.Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

var utf16be = Utf16BECodec;
function Utf16BECodec() {}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;

// -- Encoding

function Utf16BEEncoder() {}

Utf16BEEncoder.prototype.write = function (str) {
    var buf = new Buffer$2(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];buf[i] = buf[i + 1];buf[i + 1] = tmp;
    }
    return buf;
};

Utf16BEEncoder.prototype.end = function () {};

// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function (buf) {
    if (buf.length == 0) return '';

    var buf2 = new Buffer$2(buf.length + 1),
        i = 0,
        j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;j = 2;
    }

    for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
    }

    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;

    return buf2.slice(0, j).toString('ucs2');
};

Utf16BEDecoder.prototype.end = function () {};

// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

var utf16_1 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;

// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined) options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function (str) {
    return this.encoder.write(str);
};

Utf16Encoder.prototype.end = function () {
    return this.encoder.end();
};

// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function (buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;

        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer$2.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
};

Utf16Decoder.prototype.end = function () {
    if (!this.decoder) {
        var buf = Buffer$2.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? res + trail : res;
    }
    return this.decoder.end();
};

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0,
                asciiCharsBE = 0,
                // Counts of chars in both positions
            _len = Math.min(buf.length - buf.length % 2, 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE) enc = 'utf-16be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-16le';
        }
    }

    return enc;
}

var utf16 = {
	utf16be: utf16be,
	utf16: utf16_1
};

var Buffer$3 = _buffer.Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

var utf7_1 = Utf7Codec;
var unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
}
Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;

// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function (str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return new Buffer$3(str.replace(nonDirectChars, function (chunk) {
        return "+" + (chunk === '+' ? '' : this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) + "-";
    }.bind(this)));
};

Utf7Encoder.prototype.end = function () {};

// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++) base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0),
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function (buf) {
    var res = "",
        lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i + 1;
                inBase64 = true;
            }
        } else {
            // We decode base64.
            if (!base64Chars[buf[i]]) {
                // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {
                    // "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(new Buffer$3(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i + 1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer$3(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
};

Utf7Decoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer$3(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
};

// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


var utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
}
Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;

// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = new Buffer$3(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function (str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = new Buffer$3(str.length * 5 + 10),
        bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) {
            // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar) // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }
        } else {
            // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
};

Utf7IMAPEncoder.prototype.end = function () {
    var buf = new Buffer$3(10),
        bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
};

// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function (buf) {
    var res = "",
        lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) {
            // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i + 1;
                inBase64 = true;
            }
        } else {
            // We decode base64.
            if (!base64IMAPChars[buf[i]]) {
                // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {
                    // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(new Buffer$3(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i + 1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - b64str.length % 8; // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer$3(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
};

Utf7IMAPDecoder.prototype.end = function () {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0) res = this.iconv.decode(new Buffer$3(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
};

var utf7 = {
	utf7: utf7_1,
	unicode11utf7: unicode11utf7,
	utf7imap: utf7imap
};

var Buffer$4 = _buffer.Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

var _sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions) throw new Error("SBCS codec is called without the data.");

    // Prepare char buffer for decoding.
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256) throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");

    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = new Buffer$4(codecOptions.chars, 'ucs2');

    // Encoding buffer.
    var encodeBuf = new Buffer$4(65536);
    encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++) encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;

function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function (str) {
    var buf = new Buffer$4(str.length);
    for (var i = 0; i < str.length; i++) buf[i] = this.encodeBuf[str.charCodeAt(i)];

    return buf;
};

SBCSEncoder.prototype.end = function () {};

function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function (buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = new Buffer$4(buf.length * 2);
    var idx1 = 0,
        idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString('ucs2');
};

SBCSDecoder.prototype.end = function () {};

var sbcsCodec = {
	_sbcs: _sbcs
};

// Manually added data to be used by sbcs codec in addition to generated one.

var sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh"
};

// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.

var sbcsDataGenerated = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
};

var Buffer$5 = _buffer.Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

var _dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i$1 = 0; i$1 < 0x100; i$1++) UNASSIGNED_NODE[i$1] = UNASSIGNED;

// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions) throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table) throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();

    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++) this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];

    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals) for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
        var val = codecOptions.encodeSkipVals[i];
        if (typeof val === 'number') skipEncodeChars[val] = true;else for (var j = val.from; j <= val.to; j++) skipEncodeChars[j] = true;
    }

    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd) if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar)) this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++) secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++) thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++) fourthByteNode[i] = GB18030_CODE;
    }
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8) bytes.push(addr & 0xFF);
    if (bytes.length == 0) bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length - 1; i > 0; i--) {
        // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) {
            // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
            // Existing node.
            node = this.decodeTables[NODE_START - val];
        } else throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
};

DBCSCodec.prototype._addDecodeChunk = function (chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
            // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) {
                    // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000) writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);else throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
                } else if (0x0FF0 < code && code <= 0x0FFF) {
                    // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                } else writeTable[curAddr++] = code; // Basic char
            }
        } else if (typeof part === "number") {
            // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
        } else throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF) throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
};

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function (uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined) this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
};

DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START) this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
};

DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {

    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object') node = oldVal;else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length - 1];
    node[uCode] = dbcsCode;
};

DBCSCodec.prototype._fillEncodeTable = function (nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode]) continue;

        if (uCode >= 0) this._setEncodeChar(uCode, mbCode);else if (uCode <= NODE_START) this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);else if (uCode <= SEQ_START) this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
};

// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;

    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function (str) {
    var newBuf = new Buffer$5(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj,
        nextChar = -1,
        i = 0,
        j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        } else {
            var uCode = nextChar;
            nextChar = -1;
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) {
            // Char is one of surrogates.
            if (uCode < 0xDC00) {
                // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else {
                // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
            }
        } else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode;uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) {
            // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') {
                // Sequence continues.
                seqObj = resCode;
                continue;
            } else if (typeof resCode == 'number') {
                // Sequence finished. Write it.
                dbcsCode = resCode;
            } else if (resCode == undefined) {
                // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.
                }
            }
            seqObj = undefined;
        } else if (uCode >= 0) {
            // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 0xFF];

            if (dbcsCode <= SEQ_START) {
                // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600);dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260);dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10);dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;

        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8; // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        } else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = dbcsCode >> 8 & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
};

DBCSEncoder.prototype.end = function () {
    if (this.leadSurrogate === -1 && this.seqObj === undefined) return; // All clean. Most often case.

    var newBuf = new Buffer$5(10),
        j = 0;

    if (this.seqObj) {
        // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) {
            // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            } else {
                newBuf[j++] = dbcsCode >> 8; // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }

    return newBuf.slice(0, j);
};

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;

// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = new Buffer$5(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function (buf) {
    var newBuf = new Buffer$5(buf.length * 2),
        nodeIdx = this.nodeIdx,
        prevBuf = this.prevBuf,
        prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length,
        // idx of the start of current parsed sequence.
    uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer$5.concat([prevBuf, buf.slice(0, 10)]);

    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = i >= 0 ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) ; else if (uCode === UNASSIGNED) {
            // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        } else if (uCode === GB18030_CODE) {
            var curSeq = seqStart >= 0 ? buf.slice(seqStart, i + 1) : prevBuf.slice(seqStart + prevBufOffset, i + 1 + prevBufOffset);
            var ptr = (curSeq[0] - 0x81) * 12600 + (curSeq[1] - 0x30) * 1260 + (curSeq[2] - 0x81) * 10 + (curSeq[3] - 0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
            // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        } else if (uCode <= SEQ_START) {
            // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
        } else throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) {
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0;seqStart = i + 1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
};

DBCSDecoder.prototype.end = function () {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = new Buffer$5(0);
        this.nodeIdx = 0;
        if (buf.length > 0) ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
};

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val) return -1;

    var l = 0,
        r = table.length;
    while (l < r - 1) {
        // always table[l] <= val < table[r]
        var mid = l + Math.floor((r - l + 1) / 2);
        if (table[mid] <= val) l = mid;else r = mid;
    }
    return l;
}

var dbcsCodec = {
	_dbcs: _dbcs
};

var shiftjis = [["0", "\u0000", 128], ["a1", "", 62], ["8140", "", 9, ""], ["8180", ""], ["81b8", ""], ["81c8", ""], ["81da", ""], ["81f0", ""], ["81fc", ""], ["824f", "", 9], ["8260", "", 25], ["8281", "", 25], ["829f", "", 82], ["8340", "", 62], ["8380", "", 22], ["839f", "", 16, "", 6], ["83bf", "", 16, "", 6], ["8440", "", 5, "", 25], ["8470", "", 5, "", 7], ["8480", "", 17], ["849f", ""], ["8740", "", 19, "", 9], ["875f", ""], ["877e", ""], ["8780", "", 4, ""], ["889f", ""], ["8940", ""], ["8980", ""], ["8a40", ""], ["8a80", ""], ["8b40", ""], ["8b80", ""], ["8c40", ""], ["8c80", ""], ["8d40", ""], ["8d80", ""], ["8e40", ""], ["8e80", ""], ["8f40", ""], ["8f80", ""], ["9040", ""], ["9080", ""], ["9140", ""], ["9180", ""], ["9240", ""], ["9280", ""], ["9340", ""], ["9380", ""], ["9440", ""], ["9480", ""], ["9540", ""], ["9580", ""], ["9640", ""], ["9680", ""], ["9740", ""], ["9780", ""], ["9840", ""], ["989f", ""], ["9940", ""], ["9980", ""], ["9a40", ""], ["9a80", ""], ["9b40", ""], ["9b80", ""], ["9c40", ""], ["9c80", ""], ["9d40", ""], ["9d80", ""], ["9e40", ""], ["9e80", ""], ["9f40", ""], ["9f80", ""], ["e040", ""], ["e080", ""], ["e140", ""], ["e180", ""], ["e240", ""], ["e280", ""], ["e340", ""], ["e380", ""], ["e440", ""], ["e480", ""], ["e540", ""], ["e580", ""], ["e640", ""], ["e680", ""], ["e740", ""], ["e780", ""], ["e840", ""], ["e880", ""], ["e940", ""], ["e980", ""], ["ea40", ""], ["ea80", ""], ["ed40", ""], ["ed80", ""], ["ee40", ""], ["ee80", ""], ["eeef", "", 9, ""], ["f040", "", 62], ["f080", "", 124], ["f140", "", 62], ["f180", "", 124], ["f240", "", 62], ["f280", "", 124], ["f340", "", 62], ["f380", "", 124], ["f440", "", 62], ["f480", "", 124], ["f540", "", 62], ["f580", "", 124], ["f640", "", 62], ["f680", "", 124], ["f740", "", 62], ["f780", "", 124], ["f840", "", 62], ["f880", "", 124], ["f940", ""], ["fa40", "", 9, "", 9, ""], ["fa80", ""], ["fb40", ""], ["fb80", ""], ["fc40", ""]];

var shiftjis$1 = /*#__PURE__*/Object.freeze({
	default: shiftjis
});

var eucjp = [["0", "\u0000", 127], ["8ea1", "", 62], ["a1a1", "", 9, ""], ["a2a1", ""], ["a2ba", ""], ["a2ca", ""], ["a2dc", ""], ["a2f2", ""], ["a2fe", ""], ["a3b0", "", 9], ["a3c1", "", 25], ["a3e1", "", 25], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a8a1", ""], ["ada1", "", 19, "", 9], ["adc0", ""], ["addf", "", 4, ""], ["b0a1", ""], ["b1a1", ""], ["b2a1", ""], ["b3a1", ""], ["b4a1", ""], ["b5a1", ""], ["b6a1", ""], ["b7a1", ""], ["b8a1", ""], ["b9a1", ""], ["baa1", ""], ["bba1", ""], ["bca1", ""], ["bda1", ""], ["bea1", ""], ["bfa1", ""], ["c0a1", ""], ["c1a1", ""], ["c2a1", ""], ["c3a1", ""], ["c4a1", ""], ["c5a1", ""], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["c9a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", ""], ["d2a1", ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fcf1", "", 9, ""], ["8fa2af", ""], ["8fa2c2", ""], ["8fa2eb", ""], ["8fa6e1", ""], ["8fa6e7", ""], ["8fa6e9", ""], ["8fa6ec", ""], ["8fa6f1", ""], ["8fa7c2", "", 10, ""], ["8fa7f2", "", 10, ""], ["8fa9a1", ""], ["8fa9a4", ""], ["8fa9a6", ""], ["8fa9a8", ""], ["8fa9ab", ""], ["8fa9af", ""], ["8fa9c1", ""], ["8faaa1", ""], ["8faaba", ""], ["8faba1", ""], ["8fabbd", ""], ["8fabc5", ""], ["8fb0a1", ""], ["8fb1a1", ""], ["8fb2a1", "", 4, ""], ["8fb3a1", ""], ["8fb4a1", ""], ["8fb5a1", ""], ["8fb6a1", "", 5, "", 4, ""], ["8fb7a1", "", 4, ""], ["8fb8a1", ""], ["8fb9a1", ""], ["8fbaa1", "", 4, ""], ["8fbba1", ""], ["8fbca1", "", 4, ""], ["8fbda1", "", 4, ""], ["8fbea1", "", 4, ""], ["8fbfa1", ""], ["8fc0a1", ""], ["8fc1a1", ""], ["8fc2a1", ""], ["8fc3a1", "", 4, ""], ["8fc4a1", ""], ["8fc5a1", ""], ["8fc6a1", ""], ["8fc7a1", ""], ["8fc8a1", ""], ["8fc9a1", "", 4, "", 4, ""], ["8fcaa1", ""], ["8fcba1", ""], ["8fcca1", "", 9, ""], ["8fcda1", "", 5, ""], ["8fcea1", "", 6, ""], ["8fcfa1", ""], ["8fd0a1", ""], ["8fd1a1", ""], ["8fd2a1", "", 5], ["8fd3a1", ""], ["8fd4a1", "", 4, ""], ["8fd5a1", ""], ["8fd6a1", ""], ["8fd7a1", ""], ["8fd8a1", ""], ["8fd9a1", "", 4, "", 6, ""], ["8fdaa1", "", 4, ""], ["8fdba1", "", 6, ""], ["8fdca1", "", 4, ""], ["8fdda1", "", 4, ""], ["8fdea1", "", 4, ""], ["8fdfa1", ""], ["8fe0a1", ""], ["8fe1a1", "", 4, ""], ["8fe2a1", ""], ["8fe3a1", "", 5, "", 4, ""], ["8fe4a1", "", 4, ""], ["8fe5a1", "", 4, ""], ["8fe6a1", ""], ["8fe7a1", ""], ["8fe8a1", "", 4, ""], ["8fe9a1", "", 4], ["8feaa1", "", 4, ""], ["8feba1", "", 4, ""], ["8feca1", ""], ["8feda1", "", 4, "", 4, ""]];

var eucjp$1 = /*#__PURE__*/Object.freeze({
	default: eucjp
});

var cp936 = [["0", "\u0000", 127, ""], ["8140", "", 5, "", 9, "", 6, ""], ["8180", "", 6, "", 4, "", 4, "", 5, ""], ["8240", "", 4, "", 8, "", 4, "", 11], ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""], ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""], ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5], ["8440", "", 5, "", 5, ""], ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""], ["8540", "", 9, ""], ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""], ["8640", "", 4, "", 5, "", 4, "", 5, ""], ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""], ["8740", "", 7, "", 11, "", 4, "", 4], ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6], ["8840", "", 9, "", 4, "", 4, ""], ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7], ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""], ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""], ["8a40", "", 4, "", 12, ""], ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5], ["8b40", "", 8, "", 17, "", 6, "", 13, ""], ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6], ["8c40", "", 7, ""], ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4], ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4], ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""], ["8e40", "", 21, "", 12, "", 6, "", 12, ""], ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6], ["8f40", "", 5, "", 11, "", 8, ""], ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""], ["9040", "", 4, "", 4, "", 6, ""], ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6], ["9140", "", 6, "", 6, "", 18, "", 4, ""], ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""], ["9240", "", 6, "", 5, ""], ["9280", "", 5, "", 7, "", 6, ""], ["9340", "", 6, "", 4, "", 4, "", 5, ""], ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""], ["9440", "", 24, "", 7, "", 7, "", 4, "", 8], ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""], ["9540", "", 4, "", 4, "", 6, ""], ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""], ["9640", "", 5, "", 4, ""], ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5], ["9740", "", 7, "", 8, "", 7, "", 9, ""], ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""], ["9840", "", 4, "", 5, "", 9, ""], ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""], ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5], ["9980", "", 114, "", 6], ["9a40", "", 11, "", 7, "", 13, ""], ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""], ["9b40", "", 4, ""], ["9b80", "", 5, "", 4, "", 4, "", 5, ""], ["9c40", "", 7, ""], ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5], ["9d40", "", 7, "", 4, "", 9, "", 6, ""], ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""], ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6], ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""], ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""], ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4], ["a040", "", 9, "", 5, "", 9, "", 11, "", 19], ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""], ["a1a1", "", 7, ""], ["a2a1", "", 9], ["a2b1", "", 19, "", 19, "", 9], ["a2e5", "", 9], ["a2f1", "", 11], ["a3a1", "", 88, ""], ["a4a1", "", 82], ["a5a1", "", 85], ["a6a1", "", 16, "", 6], ["a6c1", "", 16, "", 6], ["a6e0", ""], ["a6ee", ""], ["a6f4", ""], ["a7a1", "", 5, "", 25], ["a7d1", "", 5, "", 25], ["a840", "", 35, "", 6], ["a880", "", 7, ""], ["a8a1", ""], ["a8bd", ""], ["a8c0", ""], ["a8c5", "", 36], ["a940", "", 8, ""], ["a959", ""], ["a95c", ""], ["a960", "", 9, "", 8], ["a980", "", 4, ""], ["a996", ""], ["a9a4", "", 75], ["aa40", "", 5, "", 5, "", 8], ["aa80", "", 7, "", 10, ""], ["ab40", "", 11, "", 4, "", 5, "", 4], ["ab80", "", 6, "", 4], ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11], ["ac80", "", 6, "", 12, "", 4, ""], ["ad40", "", 10, "", 7, "", 15, "", 12], ["ad80", "", 9, "", 8, "", 6, ""], ["ae40", "", 6, "", 7, "", 4, ""], ["ae80", "", 7, "", 6, "", 4, ""], ["af40", "", 4, ""], ["af80", ""], ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""], ["b080", "", 7, "", 8, "", 9, ""], ["b140", "", 4, "", 7, "", 10, ""], ["b180", "", 4, "", 7, "", 7, ""], ["b240", "", 11, "", 5, "", 11, "", 4], ["b280", "", 12, "", 8, "", 4, ""], ["b340", "", 5, ""], ["b380", "", 11, "", 7, "", 6, ""], ["b440", "", 7, "", 9], ["b480", "", 4, "", 5, "", 6, ""], ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""], ["b580", "", 6, "", 4, ""], ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""], ["b680", "", 6, "", 4, ""], ["b740", "", 14, "", 5, "", 9, "", 4, "", 16], ["b780", "", 6, ""], ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""], ["b880", "", 4, ""], ["b940", "", 5, "", 10, "", 6, ""], ["b980", "", 7, ""], ["ba40", "", 4, "", 4, "", 7, "", 5, ""], ["ba80", "", 4, "", 5, "", 12, "", 5, ""], ["bb40", "", 9, "", 36, "", 5, "", 9], ["bb80", "", 6, "", 4, ""], ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5], ["bc80", "", 14, "", 6, ""], ["bd40", "", 54, "", 7], ["bd80", "", 32, ""], ["be40", "", 12, "", 6, "", 42], ["be80", "", 32, ""], ["bf40", "", 62], ["bf80", "", 4, "", 4, "", 21, ""], ["c040", "", 35, "", 23, ""], ["c080", "", 6, "", 9, ""], ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""], ["c180", "", 4, "", 4, "", 5, ""], ["c240", "", 6, "", 5, ""], ["c280", "", 13, "", 5, "", 11, ""], ["c340", "", 5, "", 4, "", 6, ""], ["c380", "", 12, "", 4, ""], ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""], ["c480", "", 7, "", 5, "", 6, ""], ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""], ["c580", "", 7, "", 7, ""], ["c640", ""], ["c680", "", 4, "", 9, ""], ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""], ["c780", ""], ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""], ["c880", "", 6, "", 4, "", 4, ""], ["c940", "", 4, "", 7, "", 12, ""], ["c980", "", 4, "", 4, "", 10, ""], ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10], ["ca80", "", 4, "", 8, ""], ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""], ["cb80", "", 5, "", 6, "", 14, ""], ["cc40", "", 4, "", 10, "", 15, "", 13, ""], ["cc80", "", 11, "", 4, "", 7, ""], ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""], ["cd80", ""], ["ce40", "", 6, "", 5, "", 7, ""], ["ce80", "", 4, "", 6, "", 4, ""], ["cf40", "", 4, "", 4, "", 6, "", 9], ["cf80", "", 5, "", 7, "", 4, ""], ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""], ["d080", "", 4, "", 4, "", 5, ""], ["d140", "", 4, "", 4, "", 6, "", 5], ["d180", "", 4, "", 4, "", 4, ""], ["d240", "", 8, "", 24, "", 5, "", 19, ""], ["d280", "", 26, ""], ["d340", "", 30, "", 6], ["d380", "", 4, "", 5, "", 21, ""], ["d440", "", 31, "", 8, "", 21], ["d480", "", 25, "", 6, ""], ["d540", "", 7, "", 7, "", 46], ["d580", "", 32, ""], ["d640", "", 34, "", 27], ["d680", "", 30, ""], ["d740", "", 31, "", 4, "", 25], ["d780", "", 24, ""], ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""], ["d880", "", 6, "", 20, ""], ["d940", "", 62], ["d980", "", 32, ""], ["da40", "", 14, "", 8, "", 4, "", 9, ""], ["da80", "", 12, ""], ["db40", "", 6, "", 7, "", 4, ""], ["db80", "", 4, "", 5, "", 11, ""], ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7], ["dc80", "", 10, "", 21, ""], ["dd40", "", 62], ["dd80", "", 32, ""], ["de40", "", 32, ""], ["de80", "", 4, ""], ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""], ["df80", "", 4, ""], ["e040", "", 19, ""], ["e080", "", 10, "", 6, "", 8, ""], ["e140", "", 4, "", 6, "", 5, "", 5, ""], ["e180", "", 10, "", 9, "", 8, ""], ["e240", "", 62], ["e280", "", 32, "", 5, ""], ["e340", "", 45, "", 16], ["e380", "", 7, "", 24, ""], ["e440", "", 5, "", 24, "", 31], ["e480", "", 32, ""], ["e540", "", 51, "", 10], ["e580", "", 31, ""], ["e640", "", 34, "", 27], ["e680", "", 29, ""], ["e740", "", 7, "", 54], ["e780", "", 32, "", 6, "", 4, ""], ["e840", "", 14, "", 43, ""], ["e880", "", 20, ""], ["e940", "", 7, "", 42], ["e980", "", 32, ""], ["ea40", "", 27, "", 6, ""], ["ea80", "", 4, "", 12, ""], ["eb40", "", 9, "", 7, "", 9, "", 6, ""], ["eb80", "", 4, ""], ["ec40", "", 8, "", 4, "", 18, "", 7], ["ec80", "", 4, "", 7, "", 4, "", 4, ""], ["ed40", "", 6, "", 46], ["ed80", "", 4, "", 23, ""], ["ee40", "", 62], ["ee80", "", 32, "", 4, "", 6, ""], ["ef40", "", 5, "", 37, "", 4], ["ef80", "", 30, "", 4, "", 8, ""], ["f040", "", 4, "", 28, "", 26], ["f080", "", 9, "", 12, "", 4, "", 6, ""], ["f140", "", 10, "", 47], ["f180", "", 32, ""], ["f240", "", 62], ["f280", "", 32, ""], ["f340", "", 17, "", 6, "", 4, ""], ["f380", "", 8, "", 6, ""], ["f440", "", 5, "", 10, "", 10, "", 7, "", 5], ["f480", "", 32, ""], ["f540", "", 62], ["f580", "", 32, ""], ["f640", "", 62], ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""], ["f740", "", 62], ["f780", "", 4, "", 4, ""], ["f840", "", 62], ["f880", "", 32], ["f940", "", 62], ["f980", "", 32], ["fa40", "", 62], ["fa80", "", 32], ["fb40", "", 27, "", 9, ""], ["fb80", "", 5, "", 8, "", 5, ""], ["fc40", "", 8, "", 4, "", 8, "", 6], ["fc80", "", 4, "", 5, "", 8, ""], ["fd40", "", 4, "", 4, "", 10, "", 38], ["fd80", "", 5, "", 11, "", 4, ""], ["fe40", ""]];

var cp936$1 = /*#__PURE__*/Object.freeze({
	default: cp936
});

var gbkAdded = [["a140", "", 62], ["a180", "", 32], ["a240", "", 62], ["a280", "", 32], ["a2ab", "", 5], ["a2e3", ""], ["a2ef", ""], ["a2fd", ""], ["a340", "", 62], ["a380", "", 31, ""], ["a440", "", 62], ["a480", "", 32], ["a4f4", "", 10], ["a540", "", 62], ["a580", "", 32], ["a5f7", "", 7], ["a640", "", 62], ["a680", "", 32], ["a6b9", "", 7], ["a6d9", "", 6], ["a6ec", ""], ["a6f3", ""], ["a6f6", "", 8], ["a740", "", 62], ["a780", "", 32], ["a7c2", "", 14], ["a7f2", "", 12], ["a896", "", 10], ["a8bc", ""], ["a8bf", ""], ["a8c1", ""], ["a8ea", "", 20], ["a958", ""], ["a95b", ""], ["a95d", ""], ["a989", "", 11], ["a997", "", 12], ["a9f0", "", 14], ["aaa1", "", 93], ["aba1", "", 93], ["aca1", "", 93], ["ada1", "", 93], ["aea1", "", 93], ["afa1", "", 93], ["d7fa", "", 4], ["f8a1", "", 93], ["f9a1", "", 93], ["faa1", "", 93], ["fba1", "", 93], ["fca1", "", 93], ["fda1", "", 93], ["fe50", ""], ["fe80", "", 6, "", 93]];

var gbkAdded$1 = /*#__PURE__*/Object.freeze({
	default: gbkAdded
});

var uChars = [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536];
var gbChars = [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189000];
var gb18030Ranges = {
	uChars: uChars,
	gbChars: gbChars
};

var gb18030Ranges$1 = /*#__PURE__*/Object.freeze({
	uChars: uChars,
	gbChars: gbChars,
	default: gb18030Ranges
});

var cp949 = [["0", "\u0000", 127], ["8141", "", 4, "", 6, ""], ["8161", "", 9, "", 5, ""], ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""], ["8241", "", 7, "", 5], ["8261", "", 6, "", 5, ""], ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18], ["8341", "", 5, "", 5, "", 7], ["8361", "", 18, ""], ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8], ["8441", "", 5, "", 8], ["8461", "", 18], ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""], ["8541", "", 5, "", 4, "", 6, "", 4], ["8561", "", 5, "", 5, "", 6, ""], ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""], ["8641", "", 6, "", 5, ""], ["8661", "", 6, "", 10], ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""], ["8741", "", 9, "", 15], ["8761", "", 18, ""], ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4], ["8841", "", 4, "", 5, "", 6, "", 4], ["8861", "", 4, ""], ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""], ["8941", "", 6, "", 5, ""], ["8961", "", 10, "", 5, ""], ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15], ["8a41", "", 10, "", 6, ""], ["8a61", "", 4, "", 18, ""], ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""], ["8b41", "", 5, "", 4, "", 6, ""], ["8b61", "", 6, "", 8], ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18], ["8c41", "", 15, "", 4], ["8c61", "", 6, "", 5, "", 6, "", 5], ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16], ["8d41", "", 16, "", 8], ["8d61", "", 17, ""], ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""], ["8e41", "", 6, "", 5, "", 8], ["8e61", "", 4, "", 19], ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7], ["8f41", "", 7, "", 17], ["8f61", "", 7, "", 6, "", 4], ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5], ["9041", "", 6, "", 5, ""], ["9061", "", 5, "", 15], ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""], ["9141", "", 6, "", 5], ["9161", "", 9, "", 5], ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6], ["9241", "", 7, "", 4, ""], ["9261", "", 7, "", 7, "", 4], ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""], ["9341", "", 4, ""], ["9361", "", 6, "", 8], ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""], ["9441", "", 5, "", 5, "", 8], ["9461", "", 5, "", 6, "", 12], ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24], ["9541", "", 11, "", 5, ""], ["9561", "", 6, "", 5, ""], ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14], ["9641", "", 23, ""], ["9661", "", 6, "", 5, "", 8], ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44], ["9741", "", 16, "", 8], ["9761", "", 17, "", 7], ["9781", "", 11, "", 5, "", 6, "", 89, ""], ["9841", "", 16, "", 5, ""], ["9861", "", 6, "", 15], ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""], ["9941", "", 6, "", 5, ""], ["9961", "", 6, "", 5, ""], ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""], ["9a41", "", 16], ["9a61", "", 6, "", 6, ""], ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""], ["9b41", "", 6, "", 8], ["9b61", "", 17, "", 7], ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""], ["9c41", "", 4, "", 5, "", 5], ["9c61", "", 8, "", 6, "", 9], ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12], ["9d41", "", 13, "", 8], ["9d61", "", 25], ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""], ["9e41", "", 7, "", 9, ""], ["9e61", "", 4, "", 6, ""], ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""], ["9f41", "", 5, "", 4, "", 5, ""], ["9f61", "", 6, "", 5, ""], ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""], ["a041", "", 5, "", 6, ""], ["a061", "", 5, "", 13], ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""], ["a141", "", 18, ""], ["a161", "", 6, "", 5, ""], ["a181", "", 14, "", 5, "", 4, "", 9, ""], ["a241", "", 5, "", 18], ["a261", "", 6, "", 18], ["a281", "", 7, "", 6, "", 7, ""], ["a341", "", 6, "", 10, ""], ["a361", "", 6, "", 16], ["a381", "", 16, "", 4, "", 58, "", 32, ""], ["a441", "", 5, ""], ["a461", "", 5, "", 12], ["a481", "", 28, "", 93], ["a541", "", 4, "", 6, "", 5, ""], ["a561", "", 17, "", 5, ""], ["a581", "", 16, "", 14, "", 9], ["a5b0", "", 9], ["a5c1", "", 16, "", 6], ["a5e1", "", 16, "", 6], ["a641", "", 19, ""], ["a661", "", 5, "", 5, "", 6], ["a681", "", 6, "", 18, "", 7], ["a741", "", 4, "", 6, "", 7], ["a761", "", 22, ""], ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""], ["a841", "", 10, "", 14], ["a861", "", 18, "", 6], ["a881", "", 19, "", 11, ""], ["a8a6", ""], ["a8a8", ""], ["a8b1", "", 27, "", 25, "", 14, ""], ["a941", "", 14, "", 10], ["a961", "", 18], ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""], ["aa41", "", 6, "", 4, ""], ["aa61", "", 4, "", 5, "", 6, ""], ["aa81", "", 29, "", 82], ["ab41", "", 6, "", 5, ""], ["ab61", "", 6, "", 5, "", 5], ["ab81", "", 8, "", 6, "", 12, "", 85], ["ac41", "", 5, "", 6, ""], ["ac61", "", 11, "", 4], ["ac81", "", 28, "", 5, "", 25], ["acd1", "", 5, "", 25], ["ad41", "", 6, "", 5, "", 7], ["ad61", "", 6, "", 10, ""], ["ad81", "", 5, "", 18, ""], ["ae41", "", 5, "", 16], ["ae61", "", 5, "", 6, "", 4], ["ae81", "", 6, "", 5, ""], ["af41", "", 19], ["af61", "", 13, "", 5, ""], ["af81", "", 5, "", 6, "", 5, ""], ["b041", "", 5, "", 5, "", 12], ["b061", "", 5, "", 19], ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""], ["b141", "", 6, "", 5, ""], ["b161", "", 6, "", 5, "", 11], ["b181", "", 14, "", 6, ""], ["b241", "", 6, "", 5, ""], ["b261", "", 18, "", 5, ""], ["b281", "", 5, "", 18, "", 6, ""], ["b341", "", 19, ""], ["b361", "", 5, "", 5, "", 5], ["b381", "", 5, "", 5, "", 19, "", 4, ""], ["b441", "", 5, "", 6, "", 5], ["b461", "", 6, "", 10, ""], ["b481", "", 6, "", 18, "", 4, "", 4, ""], ["b541", "", 14, "", 5], ["b561", "", 5, "", 5, "", 4], ["b581", "", 6, "", 5, "", 11, ""], ["b641", "", 7, "", 17], ["b661", "", 15, ""], ["b681", "", 5, "", 6, "", 5, ""], ["b741", "", 13, "", 6, ""], ["b761", "", 20, ""], ["b781", "", 6, "", 14, ""], ["b841", "", 7, "", 17], ["b861", "", 8, "", 13], ["b881", "", 5, "", 24, "", 4, ""], ["b941", "", 6, "", 5, ""], ["b961", "", 14, "", 6, ""], ["b981", "", 22, "", 4, "", 4, ""], ["ba41", "", 5, "", 6, ""], ["ba61", "", 5, "", 4, "", 5], ["ba81", "", 6, "", 9, ""], ["bb41", "", 4, "", 5, "", 4, ""], ["bb61", "", 6, "", 5, ""], ["bb81", "", 31, ""], ["bc41", "", 17, ""], ["bc61", "", 5, "", 6, ""], ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""], ["bd41", "", 7, "", 7, ""], ["bd61", "", 5, "", 13], ["bd81", "", 5, "", 25, ""], ["be41", "", 7, "", 14], ["be61", "", 7, "", 7, ""], ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""], ["bf41", "", 10, "", 14], ["bf61", "", 18, ""], ["bf81", "", 5, "", 7, "", 6, "", 5, ""], ["c041", "", 5, "", 6, "", 5], ["c061", "", 25], ["c081", "", 6, "", 5, "", 7, ""], ["c141", "", 5, "", 6, ""], ["c161", "", 19, ""], ["c181", "", 31, ""], ["c241", "", 4, "", 5, ""], ["c261", "", 4, "", 5, "", 6, ""], ["c281", "", 5, "", 7, "", 9, ""], ["c341", "", 4], ["c361", "", 4, "", 5, "", 11], ["c381", "", 5, "", 7, "", 5, ""], ["c441", "", 7, "", 7, ""], ["c461", "", 5, "", 4], ["c481", "", 5, "", 11, ""], ["c541", "", 6, "", 5, ""], ["c561", "", 6, "", 5, "", 4], ["c581", "", 6, "", 5, ""], ["c641", "", 6, "", 5], ["c6a1", ""], ["c7a1", ""], ["c8a1", ""], ["caa1", ""], ["cba1", ""], ["cca1", ""], ["cda1", ""], ["cea1", ""], ["cfa1", ""], ["d0a1", ""], ["d1a1", "", 5, "", 4, ""], ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""], ["d3a1", ""], ["d4a1", ""], ["d5a1", ""], ["d6a1", ""], ["d7a1", ""], ["d8a1", ""], ["d9a1", ""], ["daa1", ""], ["dba1", ""], ["dca1", ""], ["dda1", ""], ["dea1", ""], ["dfa1", ""], ["e0a1", ""], ["e1a1", ""], ["e2a1", ""], ["e3a1", ""], ["e4a1", ""], ["e5a1", ""], ["e6a1", ""], ["e7a1", ""], ["e8a1", ""], ["e9a1", ""], ["eaa1", ""], ["eba1", ""], ["eca1", ""], ["eda1", ""], ["eea1", ""], ["efa1", ""], ["f0a1", ""], ["f1a1", ""], ["f2a1", ""], ["f3a1", ""], ["f4a1", ""], ["f5a1", ""], ["f6a1", ""], ["f7a1", ""], ["f8a1", ""], ["f9a1", ""], ["faa1", ""], ["fba1", ""], ["fca1", ""], ["fda1", ""]];

var cp949$1 = /*#__PURE__*/Object.freeze({
	default: cp949
});

var cp950 = [["0", "\u0000", 127], ["a140", ""], ["a1a1", "", 4, ""], ["a240", "", 7, ""], ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21], ["a340", "", 16, "", 6, "", 16, "", 6, "", 10], ["a3a1", "", 25, ""], ["a3e1", ""], ["a440", ""], ["a4a1", ""], ["a540", ""], ["a5a1", ""], ["a640", ""], ["a6a1", ""], ["a740", ""], ["a7a1", ""], ["a840", ""], ["a8a1", ""], ["a940", ""], ["a9a1", ""], ["aa40", ""], ["aaa1", ""], ["ab40", ""], ["aba1", ""], ["ac40", ""], ["aca1", ""], ["ad40", ""], ["ada1", ""], ["ae40", ""], ["aea1", ""], ["af40", ""], ["afa1", ""], ["b040", ""], ["b0a1", ""], ["b140", ""], ["b1a1", ""], ["b240", ""], ["b2a1", ""], ["b340", ""], ["b3a1", ""], ["b440", ""], ["b4a1", ""], ["b540", ""], ["b5a1", ""], ["b640", ""], ["b6a1", ""], ["b740", ""], ["b7a1", ""], ["b840", ""], ["b8a1", ""], ["b940", ""], ["b9a1", ""], ["ba40", ""], ["baa1", ""], ["bb40", ""], ["bba1", ""], ["bc40", ""], ["bca1", ""], ["bd40", ""], ["bda1", ""], ["be40", ""], ["bea1", ""], ["bf40", ""], ["bfa1", ""], ["c040", ""], ["c0a1", ""], ["c140", ""], ["c1a1", ""], ["c240", ""], ["c2a1", ""], ["c340", ""], ["c3a1", ""], ["c440", ""], ["c4a1", ""], ["c540", ""], ["c5a1", ""], ["c640", ""], ["c940", ""], ["c9a1", ""], ["ca40", ""], ["caa1", ""], ["cb40", ""], ["cba1", ""], ["cc40", ""], ["cca1", ""], ["cd40", ""], ["cda1", ""], ["ce40", ""], ["cea1", ""], ["cf40", ""], ["cfa1", ""], ["d040", ""], ["d0a1", ""], ["d140", ""], ["d1a1", ""], ["d240", ""], ["d2a1", ""], ["d340", ""], ["d3a1", ""], ["d440", ""], ["d4a1", ""], ["d540", ""], ["d5a1", ""], ["d640", ""], ["d6a1", ""], ["d740", ""], ["d7a1", ""], ["d840", ""], ["d8a1", ""], ["d940", ""], ["d9a1", ""], ["da40", ""], ["daa1", ""], ["db40", ""], ["dba1", ""], ["dc40", ""], ["dca1", ""], ["dd40", ""], ["dda1", ""], ["de40", ""], ["dea1", ""], ["df40", ""], ["dfa1", ""], ["e040", ""], ["e0a1", ""], ["e140", ""], ["e1a1", ""], ["e240", ""], ["e2a1", ""], ["e340", ""], ["e3a1", ""], ["e440", ""], ["e4a1", ""], ["e540", ""], ["e5a1", ""], ["e640", ""], ["e6a1", ""], ["e740", ""], ["e7a1", ""], ["e840", ""], ["e8a1", ""], ["e940", ""], ["e9a1", ""], ["ea40", ""], ["eaa1", ""], ["eb40", ""], ["eba1", ""], ["ec40", ""], ["eca1", ""], ["ed40", ""], ["eda1", ""], ["ee40", ""], ["eea1", ""], ["ef40", ""], ["efa1", ""], ["f040", ""], ["f0a1", ""], ["f140", ""], ["f1a1", ""], ["f240", ""], ["f2a1", ""], ["f340", ""], ["f3a1", ""], ["f440", ""], ["f4a1", ""], ["f540", ""], ["f5a1", ""], ["f640", ""], ["f6a1", ""], ["f740", ""], ["f7a1", ""], ["f840", ""], ["f8a1", ""], ["f940", ""], ["f9a1", ""]];

var cp950$1 = /*#__PURE__*/Object.freeze({
	default: cp950
});

var big5Added = [["8740", ""], ["8767", ""], ["87a1", ""], ["8840", "", 4, ""], ["88a1", ""], ["8940", ""], ["8943", ""], ["8946", ""], ["894c", ""], ["89a1", ""], ["89ab", ""], ["89b0", ""], ["89b5", ""], ["89c1", ""], ["89c5", ""], ["8a40", ""], ["8a43", ""], ["8a64", ""], ["8a76", ""], ["8aa1", ""], ["8aac", ""], ["8ab2", ""], ["8abb", ""], ["8ac9", ""], ["8ace", ""], ["8adf", ""], ["8af6", ""], ["8b40", ""], ["8b55", ""], ["8ba1", ""], ["8bde", ""], ["8c40", ""], ["8ca1", ""], ["8ca7", ""], ["8cc9", ""], ["8cce", ""], ["8ce6", ""], ["8d40", ""], ["8d42", ""], ["8da1", ""], ["8e40", ""], ["8ea1", ""], ["8f40", ""], ["8fa1", ""], ["9040", ""], ["90a1", ""], ["9140", ""], ["91a1", ""], ["9240", ""], ["92a1", ""], ["9340", ""], ["93a1", ""], ["9440", ""], ["94a1", ""], ["9540", ""], ["95a1", ""], ["9640", ""], ["96a1", ""], ["9740", ""], ["97a1", ""], ["9840", ""], ["98a1", ""], ["9940", ""], ["99a1", ""], ["9a40", ""], ["9aa1", ""], ["9b40", ""], ["9b62", ""], ["9ba1", ""], ["9c40", ""], ["9ca1", ""], ["9d40", ""], ["9da1", ""], ["9e40", ""], ["9ea1", ""], ["9ead", ""], ["9ec5", ""], ["9ef5", ""], ["9f40", ""], ["9f4f", ""], ["9fa1", ""], ["9fae", ""], ["9fb2", ""], ["9fc1", ""], ["9fc9", ""], ["9fdb", ""], ["9fe7", ""], ["9feb", ""], ["9ff0", ""], ["a040", ""], ["a055", ""], ["a058", ""], ["a05b", ""], ["a063", ""], ["a073", ""], ["a0a1", ""], ["a0a6", ""], ["a0ae", ""], ["a0b0", ""], ["a0d4", ""], ["a0e2", ""], ["a3c0", "", 31, ""], ["c6a1", "", 9, "", 9, "", 9, "", 23], ["c740", "", 58, ""], ["c7a1", "", 81, "", 5, "", 4], ["c840", "", 26, "", 25, ""], ["c8a1", ""], ["c8cd", ""], ["c8f5", ""], ["f9fe", ""], ["fa40", ""], ["faa1", ""], ["fb40", ""], ["fba1", ""], ["fc40", ""], ["fca1", ""], ["fd40", ""], ["fda1", ""], ["fe40", ""], ["fea1", ""]];

var big5Added$1 = /*#__PURE__*/Object.freeze({
	default: big5Added
});

var require$$0$1 = ( shiftjis$1 && shiftjis ) || shiftjis$1;

var require$$1$1 = ( eucjp$1 && eucjp ) || eucjp$1;

var require$$2$1 = ( cp936$1 && cp936 ) || cp936$1;

var require$$3 = ( gbkAdded$1 && gbkAdded ) || gbkAdded$1;

var require$$4 = ( gb18030Ranges$1 && gb18030Ranges ) || gb18030Ranges$1;

var require$$5 = ( cp949$1 && cp949 ) || cp949$1;

var require$$6 = ( cp950$1 && cp950 ) || cp950$1;

var require$$7 = ( big5Added$1 && big5Added ) || big5Added$1;

// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

var dbcsData = {

    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function () {
            return require$$0$1;
        },
        encodeAdd: { '\u00a5': 0x5C, '\u203E': 0x7E },
        encodeSkipVals: [{ from: 0xED40, to: 0xF940 }]
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function () {
            return require$$1$1;
        },
        encodeAdd: { '\u00a5': 0x5C, '\u203E': 0x7E }
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function () {
            return require$$2$1;
        }
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function () {
            return require$$2$1.concat(require$$3);
        }
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function () {
            return require$$2$1.concat(require$$3);
        },
        gb18030: function () {
            return require$$4;
        },
        encodeSkipVals: [0x80],
        encodeAdd: { '': 0xA2E3 }
    },

    'chinese': 'gb18030',

    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function () {
            return require$$5;
        }
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',

    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function () {
            return require$$6;
        }
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function () {
            return require$$6.concat(require$$7);
        },
        encodeSkipVals: [0xa2cc]
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs'
};

var encodings = createCommonjsModule(function (module, exports) {

// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.

var modules = [internal, utf16, utf7, sbcsCodec, sbcsData, sbcsDataGenerated, dbcsCodec, dbcsData];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module) if (Object.prototype.hasOwnProperty.call(module, enc)) exports[enc] = module[enc];
}
});

var Buffer$6 = _buffer.Buffer,
    Transform = require$$1.Transform;

// == Exports ==================================================================
var streams = function (iconv) {

    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) {
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
    };

    iconv.decodeStream = function decodeStream(encoding, options) {
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
    };

    iconv.supportsStreams = true;

    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};

// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function (chunk, encoding, done) {
    if (typeof chunk != 'string') return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
    } catch (e) {
        done(e);
    }
};

IconvLiteEncoderStream.prototype._flush = function (done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
    } catch (e) {
        done(e);
    }
};

IconvLiteEncoderStream.prototype.collect = function (cb) {
    var chunks = [];
    this.on('error', cb);
    this.on('data', function (chunk) {
        chunks.push(chunk);
    });
    this.on('end', function () {
        cb(null, Buffer$6.concat(chunks));
    });
    return this;
};

// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function (chunk, encoding, done) {
    if (!Buffer$6.isBuffer(chunk)) return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
    } catch (e) {
        done(e);
    }
};

IconvLiteDecoderStream.prototype._flush = function (done) {
    try {
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);
        done();
    } catch (e) {
        done(e);
    }
};

IconvLiteDecoderStream.prototype.collect = function (cb) {
    var res = '';
    this.on('error', cb);
    this.on('data', function (chunk) {
        res += chunk;
    });
    this.on('end', function () {
        cb(null, res);
    });
    return this;
};

var Buffer$7 = _buffer.Buffer;

// == Extend Node primitives to use iconv-lite =================================

var extendNode = function (iconv) {
    var original = undefined; // Place to keep original methods.

    // Node authors rewrote Buffer internals to make it compatible with
    // Uint8Array and we cannot patch key functions since then.
    iconv.supportsNodeEncodingsExtension = !(new Buffer$7(0) instanceof Uint8Array);

    iconv.extendNodeEncodings = function extendNodeEncodings() {
        if (original) return;
        original = {};

        if (!iconv.supportsNodeEncodingsExtension) {
            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
            return;
        }

        var nodeNativeEncodings = {
            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true,
            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true
        };

        Buffer$7.isNativeEncoding = function (enc) {
            return enc && nodeNativeEncodings[enc.toLowerCase()];
        };

        // -- SlowBuffer -----------------------------------------------------------
        var SlowBuffer = _buffer.SlowBuffer;

        original.SlowBufferToString = SlowBuffer.prototype.toString;
        SlowBuffer.prototype.toString = function (encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer$7.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        };

        original.SlowBufferWrite = SlowBuffer.prototype.write;
        SlowBuffer.prototype.write = function (string, offset, length, encoding) {
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {
                // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer$7.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);

            if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;
        };

        // -- Buffer ---------------------------------------------------------------

        original.BufferIsEncoding = Buffer$7.isEncoding;
        Buffer$7.isEncoding = function (encoding) {
            return Buffer$7.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
        };

        original.BufferByteLength = Buffer$7.byteLength;
        Buffer$7.byteLength = SlowBuffer.byteLength = function (str, encoding) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer$7.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding);

            // Slow, I know, but we don't have a better way yet.
            return iconv.encode(str, encoding).length;
        };

        original.BufferToString = Buffer$7.prototype.toString;
        Buffer$7.prototype.toString = function (encoding, start, end) {
            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer$7.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end);

            // Otherwise, use our decoding method.
            if (typeof start == 'undefined') start = 0;
            if (typeof end == 'undefined') end = this.length;
            return iconv.decode(this.slice(start, end), encoding);
        };

        original.BufferWrite = Buffer$7.prototype.write;
        Buffer$7.prototype.write = function (string, offset, length, encoding) {
            var _offset = offset,
                _length = length,
                _encoding = encoding;
            // Support both (string, offset, length, encoding)
            // and the legacy (string, encoding, offset, length)
            if (isFinite(offset)) {
                if (!isFinite(length)) {
                    encoding = length;
                    length = undefined;
                }
            } else {
                // legacy
                var swap = encoding;
                encoding = offset;
                offset = length;
                length = swap;
            }

            encoding = String(encoding || 'utf8').toLowerCase();

            // Use native conversion when possible
            if (Buffer$7.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);

            offset = +offset || 0;
            var remaining = this.length - offset;
            if (!length) {
                length = remaining;
            } else {
                length = +length;
                if (length > remaining) {
                    length = remaining;
                }
            }

            if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds');

            // Otherwise, use our encoding method.
            var buf = iconv.encode(string, encoding);
            if (buf.length < length) length = buf.length;
            buf.copy(this, offset, 0, length);
            return length;

            // TODO: Set _charsWritten.
        };

        // -- Readable -------------------------------------------------------------
        if (iconv.supportsStreams) {
            var Readable = require$$1.Readable;

            original.ReadableSetEncoding = Readable.prototype.setEncoding;
            Readable.prototype.setEncoding = function setEncoding(enc, options) {
                // Use our own decoder, it has the same interface.
                // We cannot use original function as it doesn't handle BOM-s.
                this._readableState.decoder = iconv.getDecoder(enc, options);
                this._readableState.encoding = enc;
            };

            Readable.prototype.collect = iconv._collect;
        }
    };

    // Remove iconv-lite Node primitive extensions.
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
        if (!iconv.supportsNodeEncodingsExtension) return;
        if (!original) throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");

        delete Buffer$7.isNativeEncoding;

        var SlowBuffer = _buffer.SlowBuffer;

        SlowBuffer.prototype.toString = original.SlowBufferToString;
        SlowBuffer.prototype.write = original.SlowBufferWrite;

        Buffer$7.isEncoding = original.BufferIsEncoding;
        Buffer$7.byteLength = original.BufferByteLength;
        Buffer$7.prototype.toString = original.BufferToString;
        Buffer$7.prototype.write = original.BufferWrite;

        if (iconv.supportsStreams) {
            var Readable = require$$1.Readable;

            Readable.prototype.setEncoding = original.ReadableSetEncoding;
            delete Readable.prototype.collect;
        }

        original = undefined;
    };
};

var lib = createCommonjsModule(function (module) {

// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.

var Buffer = _buffer.Buffer;

var iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();

    return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
};

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? res + trail : res;
};

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
};

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings) iconv.encodings = encodings; // Lazy load all encoding definitions.

    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = ('' + encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec) return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string":
                // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object":
                // Alias with options. Can be layered.
                for (var key in codecDef) codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName) codecOptions.encodingName = enc;

                enc = codecDef.type;
                break;

            case "function":
                // Codec itself.
                if (!codecOptions.encodingName) codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
    }
};

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM) encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
};

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false)) decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
};

// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        streams(iconv);
    }

    // Load Node primitive extensions.
    extendNode(iconv);
}
});

/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var unpipe_1 = unpipe;

/**
 * Determine if there are Node.js pipe-like data listeners.
 * @private
 */

function hasPipeDataListeners(stream) {
  var listeners = stream.listeners('data');

  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === 'ondata') {
      return true;
    }
  }

  return false;
}

/**
 * Unpipe a stream from all destinations.
 *
 * @param {object} stream
 * @public
 */

function unpipe(stream) {
  if (!stream) {
    throw new TypeError('argument stream is required');
  }

  if (typeof stream.unpipe === 'function') {
    // new-style
    stream.unpipe();
    return;
  }

  // Node.js 0.8 hack
  if (!hasPipeDataListeners(stream)) {
    return;
  }

  var listener;
  var listeners = stream.listeners('close');

  for (var i = 0; i < listeners.length; i++) {
    listener = listeners[i];

    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {
      continue;
    }

    // invoke the listener
    listener.call(stream);
  }
}

/**
 * Module dependencies.
 * @private
 */






/**
 * Module exports.
 * @public
 */

var rawBody = getRawBody;

/**
 * Module variables.
 * @private
 */

var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;

/**
 * Get the decoder for a given encoding.
 *
 * @param {string} encoding
 * @private
 */

function getDecoder(encoding) {
  if (!encoding) return null;

  try {
    return lib.getDecoder(encoding);
  } catch (e) {
    // error getting decoder
    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;

    // the encoding was not found
    throw httpErrors(415, 'specified encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    });
  }
}

/**
 * Get the raw body of a stream (typically HTTP).
 *
 * @param {object} stream
 * @param {object|string|function} [options]
 * @param {function} [callback]
 * @public
 */

function getRawBody(stream, options, callback) {
  var done = callback;
  var opts = options || {};

  if (options === true || typeof options === 'string') {
    // short cut for encoding
    opts = {
      encoding: options
    };
  }

  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // validate callback is a function, if provided
  if (done !== undefined && typeof done !== 'function') {
    throw new TypeError('argument callback must be a function');
  }

  // require the callback without promises
  if (!done && !commonjsGlobal.Promise) {
    throw new TypeError('argument callback is required');
  }

  // get encoding
  var encoding = opts.encoding !== true ? opts.encoding : 'utf-8';

  // convert the limit to an integer
  var limit = bytes_1.parse(opts.limit);

  // convert the expected length to an integer
  var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;

  if (done) {
    // classic callback style
    return readStream(stream, encoding, length, limit, done);
  }

  return new Promise(function executor(resolve, reject) {
    readStream(stream, encoding, length, limit, function onRead(err, buf) {
      if (err) return reject(err);
      resolve(buf);
    });
  });
}

/**
 * Halt a stream.
 *
 * @param {Object} stream
 * @private
 */

function halt(stream) {
  // unpipe everything from the stream
  unpipe_1(stream);

  // pause stream
  if (typeof stream.pause === 'function') {
    stream.pause();
  }
}

/**
 * Read the data from the stream.
 *
 * @param {object} stream
 * @param {string} encoding
 * @param {number} length
 * @param {number} limit
 * @param {function} callback
 * @public
 */

function readStream(stream, encoding, length, limit, callback) {
  var complete = false;
  var sync = true;

  // check the length and limit options.
  // note: we intentionally leave the stream paused,
  // so users should handle the stream themselves.
  if (limit !== null && length !== null && length > limit) {
    return done(httpErrors(413, 'request entity too large', {
      expected: length,
      length: length,
      limit: limit,
      type: 'entity.too.large'
    }));
  }

  // streams1: assert request encoding is buffer.
  // streams2+: assert the stream encoding is buffer.
  //   stream._decoder: streams1
  //   state.encoding: streams2
  //   state.decoder: streams2, specifically < 0.10.6
  var state = stream._readableState;
  if (stream._decoder || state && (state.encoding || state.decoder)) {
    // developer error
    return done(httpErrors(500, 'stream encoding should not be set', {
      type: 'stream.encoding.set'
    }));
  }

  var received = 0;
  var decoder;

  try {
    decoder = getDecoder(encoding);
  } catch (err) {
    return done(err);
  }

  var buffer = decoder ? '' : [];

  // attach listeners
  stream.on('aborted', onAborted);
  stream.on('close', cleanup);
  stream.on('data', onData);
  stream.on('end', onEnd);
  stream.on('error', onEnd);

  // mark sync section complete
  sync = false;

  function done() {
    var args = new Array(arguments.length);

    // copy arguments
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    // mark complete
    complete = true;

    if (sync) {
      process.nextTick(invokeCallback);
    } else {
      invokeCallback();
    }

    function invokeCallback() {
      cleanup();

      if (args[0]) {
        // halt the stream on error
        halt(stream);
      }

      callback.apply(null, args);
    }
  }

  function onAborted() {
    if (complete) return;

    done(httpErrors(400, 'request aborted', {
      code: 'ECONNABORTED',
      expected: length,
      length: length,
      received: received,
      type: 'request.aborted'
    }));
  }

  function onData(chunk) {
    if (complete) return;

    received += chunk.length;

    if (limit !== null && received > limit) {
      done(httpErrors(413, 'request entity too large', {
        limit: limit,
        received: received,
        type: 'entity.too.large'
      }));
    } else if (decoder) {
      buffer += decoder.write(chunk);
    } else {
      buffer.push(chunk);
    }
  }

  function onEnd(err) {
    if (complete) return;
    if (err) return done(err);

    if (length !== null && received !== length) {
      done(httpErrors(400, 'request size did not match content length', {
        expected: length,
        length: length,
        received: received,
        type: 'request.size.invalid'
      }));
    } else {
      var string = decoder ? buffer + (decoder.end() || '') : Buffer.concat(buffer);
      done(null, string);
    }
  }

  function cleanup() {
    buffer = null;

    stream.removeListener('aborted', onAborted);
    stream.removeListener('data', onData);
    stream.removeListener('end', onEnd);
    stream.removeListener('error', onEnd);
    stream.removeListener('close', cleanup);
  }
}

/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var eeFirst = first;

/**
 * Get the first event in a set of event emitters and event pairs.
 *
 * @param {array} stuff
 * @param {function} done
 * @public
 */

function first(stuff, done) {
  if (!Array.isArray(stuff)) throw new TypeError('arg must be an array of [ee, events...] arrays');

  var cleanups = [];

  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];

    if (!Array.isArray(arr) || arr.length < 2) throw new TypeError('each array member must be [ee, events...]');

    var ee = arr[0];

    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);

      // listen to the event
      ee.on(event, fn);
      // push this listener to the list of cleanups
      cleanups.push({
        ee: ee,
        event: event,
        fn: fn
      });
    }
  }

  function callback() {
    cleanup();
    done.apply(null, arguments);
  }

  function cleanup() {
    var x;
    for (var i = 0; i < cleanups.length; i++) {
      x = cleanups[i];
      x.ee.removeListener(x.event, x.fn);
    }
  }

  function thunk(fn) {
    done = fn;
  }

  thunk.cancel = cleanup;

  return thunk;
}

/**
 * Create the event listener.
 * @private
 */

function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === 'error' ? arg1 : null;

    // copy args to prevent arguments escaping scope
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    done(err, ee, event, args);
  };
}

/**
 * Module exports.
 * @public
 */

var onFinished_1 = onFinished;
var isFinished_1 = isFinished;

/**
 * Module dependencies.
 * @private
 */



/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg
 * @param {function} listener
 * @return {object}
 * @public
 */

function onFinished(msg, listener) {
  if (isFinished(msg) !== false) {
    defer(listener, null, msg);
    return msg;
  }

  // attach the listener to the message
  attachListener(msg, listener);

  return msg;
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg
 * @return {boolean}
 * @public
 */

function isFinished(msg) {
  var socket = msg.socket;

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || socket && !socket.writable);
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }

  // don't know
  return undefined;
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg
 * @param {function} callback
 * @private
 */

function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;

  function onFinish(error) {
    eeMsg.cancel();
    eeSocket.cancel();

    finished = true;
    callback(error);
  }

  // finished on first message event
  eeMsg = eeSocket = eeFirst([[msg, 'end', 'finish']], onFinish);

  function onSocket(socket) {
    // remove listener
    msg.removeListener('socket', onSocket);

    if (finished) return;
    if (eeMsg !== eeSocket) return;

    // finished on first socket event
    eeSocket = eeFirst([[socket, 'error', 'close']], onFinish);
  }

  if (msg.socket) {
    // socket already assigned
    onSocket(msg.socket);
    return;
  }

  // wait for socket to be assigned
  msg.on('socket', onSocket);

  if (msg.socket === undefined) {
    // node.js 0.8 patch
    patchAssignSocket(msg, onSocket);
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function attachListener(msg, listener) {
  var attached = msg.__onFinished;

  // create a private single listener with queue
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }

  attached.queue.push(listener);
}

/**
 * Create listener on message.
 *
 * @param {object} msg
 * @return {function}
 * @private
 */

function createListener(msg) {
  function listener(err) {
    if (msg.__onFinished === listener) msg.__onFinished = null;
    if (!listener.queue) return;

    var queue = listener.queue;
    listener.queue = null;

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }

  listener.queue = [];

  return listener;
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res
 * @param {function} callback
 * @private
 */

function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;

  if (typeof assignSocket !== 'function') return;

  // res.on('socket', callback) is broken in 0.8
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
onFinished_1.isFinished = isFinished_1;

/**
 * Module dependencies.
 * @private
 */







/**
 * Module exports.
 */

var read_1 = read;

/**
 * Read a request into a buffer and parse.
 *
 * @param {object} req
 * @param {object} res
 * @param {function} next
 * @param {function} parse
 * @param {function} debug
 * @param {object} options
 * @private
 */

function read(req, res, next, parse, debug, options) {
  var length;
  var opts = options;
  var stream;

  // flag as parsed
  req._body = true;

  // read options
  var encoding = opts.encoding !== null ? opts.encoding : null;
  var verify = opts.verify;

  try {
    // get the content stream
    stream = contentstream(req, debug, opts.inflate);
    length = stream.length;
    stream.length = undefined;
  } catch (err) {
    return next(err);
  }

  // set raw-body options
  opts.length = length;
  opts.encoding = verify ? null : encoding;

  // assert charset is supported
  if (opts.encoding === null && encoding !== null && !lib.encodingExists(encoding)) {
    return next(httpErrors(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
      charset: encoding.toLowerCase(),
      type: 'charset.unsupported'
    }));
  }

  // read body
  debug('read body');
  rawBody(stream, opts, function (error, body) {
    if (error) {
      var _error;

      if (error.type === 'encoding.unsupported') {
        // echo back charset
        _error = httpErrors(415, 'unsupported charset "' + encoding.toUpperCase() + '"', {
          charset: encoding.toLowerCase(),
          type: 'charset.unsupported'
        });
      } else {
        // set status code on error
        _error = httpErrors(400, error);
      }

      // read off entire request
      stream.resume();
      onFinished_1(req, function onfinished() {
        next(httpErrors(400, _error));
      });
      return;
    }

    // verify
    if (verify) {
      try {
        debug('verify body');
        verify(req, res, body, encoding);
      } catch (err) {
        next(httpErrors(403, err, {
          body: body,
          type: err.type || 'entity.verify.failed'
        }));
        return;
      }
    }

    // parse
    var str = body;
    try {
      debug('parse body');
      str = typeof body !== 'string' && encoding !== null ? lib.decode(body, encoding) : body;
      req.body = parse(str);
    } catch (err) {
      next(httpErrors(400, err, {
        body: str,
        type: err.type || 'entity.parse.failed'
      }));
      return;
    }

    next();
  });
}

/**
 * Get the content stream of the request.
 *
 * @param {object} req
 * @param {function} debug
 * @param {boolean} [inflate=true]
 * @return {object}
 * @api private
 */

function contentstream(req, debug, inflate) {
  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase();
  var length = req.headers['content-length'];
  var stream;

  debug('content-encoding "%s"', encoding);

  if (inflate === false && encoding !== 'identity') {
    throw httpErrors(415, 'content encoding unsupported', {
      encoding: encoding,
      type: 'encoding.unsupported'
    });
  }

  switch (encoding) {
    case 'deflate':
      stream = zlib.createInflate();
      debug('inflate body');
      req.pipe(stream);
      break;
    case 'gzip':
      stream = zlib.createGunzip();
      debug('gunzip body');
      req.pipe(stream);
      break;
    case 'identity':
      stream = req;
      stream.length = length;
      break;
    default:
      throw httpErrors(415, 'unsupported content encoding "' + encoding + '"', {
        encoding: encoding,
        type: 'encoding.unsupported'
      });
  }

  return stream;
}

/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * SHT           = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */
var qescRegExp = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */
var quoteRegExp = /([\\"])/g;

/**
 * RegExp to match type in RFC 6838
 *
 * type-name = restricted-name
 * subtype-name = restricted-name
 * restricted-name = restricted-name-first *126restricted-name-chars
 * restricted-name-first  = ALPHA / DIGIT
 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
 *                          "$" / "&" / "-" / "^" / "_"
 * restricted-name-chars =/ "." ; Characters before first dot always
 *                              ; specify a facet name
 * restricted-name-chars =/ "+" ; Characters after last plus always
 *                              ; specify a structured syntax suffix
 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
 * DIGIT =  %x30-39             ; 0-9
 */
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

/**
 * Module exports.
 */

var format_1$2 = format$2;
var parse_1$2 = parse$3;

/**
 * Format object to media type.
 *
 * @param {object} obj
 * @return {string}
 * @api public
 */

function format$2(obj) {
  if (!obj || typeof obj !== 'object') {
    throw new TypeError('argument obj is required');
  }

  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type = obj.type;

  if (!type || !typeNameRegExp.test(type)) {
    throw new TypeError('invalid type');
  }

  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError('invalid subtype');
  }

  // format as type/subtype
  var string = type + '/' + subtype;

  // append +suffix
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError('invalid suffix');
    }

    string += '+' + suffix;
  }

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param;
    var params = Object.keys(parameters).sort();

    for (var i = 0; i < params.length; i++) {
      param = params[i];

      if (!tokenRegExp.test(param)) {
        throw new TypeError('invalid parameter name');
      }

      string += '; ' + param + '=' + qstring$1(parameters[param]);
    }
  }

  return string;
}

/**
 * Parse media type to object.
 *
 * @param {string|object} string
 * @return {Object}
 * @api public
 */

function parse$3(string) {
  if (!string) {
    throw new TypeError('argument string is required');
  }

  // support req/res-like objects as argument
  if (typeof string === 'object') {
    string = getcontenttype$1(string);
  }

  if (typeof string !== 'string') {
    throw new TypeError('argument string is required to be a string');
  }

  var index = string.indexOf(';');
  var type = index !== -1 ? string.substr(0, index) : string;

  var key;
  var match;
  var obj = splitType(type);
  var params = {};
  var value;

  paramRegExp.lastIndex = index;

  while (match = paramRegExp.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format');
    }

    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');
    }

    params[key] = value;
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format');
  }

  obj.parameters = params;

  return obj;
}

/**
 * Get content-type from req/res objects.
 *
 * @param {object}
 * @return {Object}
 * @api private
 */

function getcontenttype$1(obj) {
  if (typeof obj.getHeader === 'function') {
    // res-like
    return obj.getHeader('content-type');
  }

  if (typeof obj.headers === 'object') {
    // req-like
    return obj.headers && obj.headers['content-type'];
  }
}

/**
 * Quote a string if necessary.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring$1(val) {
  var str = String(val);

  // no need to quote tokens
  if (tokenRegExp.test(str)) {
    return str;
  }

  if (str.length > 0 && !textRegExp.test(str)) {
    throw new TypeError('invalid parameter value');
  }

  return '"' + str.replace(quoteRegExp, '\\$1') + '"';
}

/**
 * Simply "type/subtype+siffx" into parts.
 *
 * @param {string} string
 * @return {Object}
 * @api private
 */

function splitType(string) {
  var match = typeRegExp.exec(string.toLowerCase());

  if (!match) {
    throw new TypeError('invalid media type');
  }

  var type = match[1];
  var subtype = match[2];
  var suffix;

  // suffix after last +
  var index = subtype.lastIndexOf('+');
  if (index !== -1) {
    suffix = subtype.substr(index + 1);
    subtype = subtype.substr(0, index);
  }

  var obj = {
    type: type,
    subtype: subtype,
    suffix: suffix
  };

  return obj;
}

var mediaTyper = {
	format: format_1$2,
	parse: parse_1$2
};

var db = {
	"application/1d-interleaved-parityfec": {
		source: "iana"
	},
	"application/3gpdash-qoe-report+xml": {
		source: "iana"
	},
	"application/3gpp-ims+xml": {
		source: "iana"
	},
	"application/a2l": {
		source: "iana"
	},
	"application/activemessage": {
		source: "iana"
	},
	"application/alto-costmap+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-costmapfilter+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-directory+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-endpointcost+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-endpointcostparams+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-endpointprop+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-endpointpropparams+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-error+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-networkmap+json": {
		source: "iana",
		compressible: true
	},
	"application/alto-networkmapfilter+json": {
		source: "iana",
		compressible: true
	},
	"application/aml": {
		source: "iana"
	},
	"application/andrew-inset": {
		source: "iana",
		extensions: ["ez"]
	},
	"application/applefile": {
		source: "iana"
	},
	"application/applixware": {
		source: "apache",
		extensions: ["aw"]
	},
	"application/atf": {
		source: "iana"
	},
	"application/atfx": {
		source: "iana"
	},
	"application/atom+xml": {
		source: "iana",
		compressible: true,
		extensions: ["atom"]
	},
	"application/atomcat+xml": {
		source: "iana",
		extensions: ["atomcat"]
	},
	"application/atomdeleted+xml": {
		source: "iana"
	},
	"application/atomicmail": {
		source: "iana"
	},
	"application/atomsvc+xml": {
		source: "iana",
		extensions: ["atomsvc"]
	},
	"application/atxml": {
		source: "iana"
	},
	"application/auth-policy+xml": {
		source: "iana"
	},
	"application/bacnet-xdd+zip": {
		source: "iana"
	},
	"application/batch-smtp": {
		source: "iana"
	},
	"application/bdoc": {
		compressible: false,
		extensions: ["bdoc"]
	},
	"application/beep+xml": {
		source: "iana"
	},
	"application/calendar+json": {
		source: "iana",
		compressible: true
	},
	"application/calendar+xml": {
		source: "iana"
	},
	"application/call-completion": {
		source: "iana"
	},
	"application/cals-1840": {
		source: "iana"
	},
	"application/cbor": {
		source: "iana"
	},
	"application/cccex": {
		source: "iana"
	},
	"application/ccmp+xml": {
		source: "iana"
	},
	"application/ccxml+xml": {
		source: "iana",
		extensions: ["ccxml"]
	},
	"application/cdfx+xml": {
		source: "iana"
	},
	"application/cdmi-capability": {
		source: "iana",
		extensions: ["cdmia"]
	},
	"application/cdmi-container": {
		source: "iana",
		extensions: ["cdmic"]
	},
	"application/cdmi-domain": {
		source: "iana",
		extensions: ["cdmid"]
	},
	"application/cdmi-object": {
		source: "iana",
		extensions: ["cdmio"]
	},
	"application/cdmi-queue": {
		source: "iana",
		extensions: ["cdmiq"]
	},
	"application/cdni": {
		source: "iana"
	},
	"application/cea": {
		source: "iana"
	},
	"application/cea-2018+xml": {
		source: "iana"
	},
	"application/cellml+xml": {
		source: "iana"
	},
	"application/cfw": {
		source: "iana"
	},
	"application/clue_info+xml": {
		source: "iana"
	},
	"application/cms": {
		source: "iana"
	},
	"application/cnrp+xml": {
		source: "iana"
	},
	"application/coap-group+json": {
		source: "iana",
		compressible: true
	},
	"application/coap-payload": {
		source: "iana"
	},
	"application/commonground": {
		source: "iana"
	},
	"application/conference-info+xml": {
		source: "iana"
	},
	"application/cose": {
		source: "iana"
	},
	"application/cose-key": {
		source: "iana"
	},
	"application/cose-key-set": {
		source: "iana"
	},
	"application/cpl+xml": {
		source: "iana"
	},
	"application/csrattrs": {
		source: "iana"
	},
	"application/csta+xml": {
		source: "iana"
	},
	"application/cstadata+xml": {
		source: "iana"
	},
	"application/csvm+json": {
		source: "iana",
		compressible: true
	},
	"application/cu-seeme": {
		source: "apache",
		extensions: ["cu"]
	},
	"application/cybercash": {
		source: "iana"
	},
	"application/dart": {
		compressible: true
	},
	"application/dash+xml": {
		source: "iana",
		extensions: ["mpd"]
	},
	"application/dashdelta": {
		source: "iana"
	},
	"application/davmount+xml": {
		source: "iana",
		extensions: ["davmount"]
	},
	"application/dca-rft": {
		source: "iana"
	},
	"application/dcd": {
		source: "iana"
	},
	"application/dec-dx": {
		source: "iana"
	},
	"application/dialog-info+xml": {
		source: "iana"
	},
	"application/dicom": {
		source: "iana"
	},
	"application/dicom+json": {
		source: "iana",
		compressible: true
	},
	"application/dicom+xml": {
		source: "iana"
	},
	"application/dii": {
		source: "iana"
	},
	"application/dit": {
		source: "iana"
	},
	"application/dns": {
		source: "iana"
	},
	"application/docbook+xml": {
		source: "apache",
		extensions: ["dbk"]
	},
	"application/dskpp+xml": {
		source: "iana"
	},
	"application/dssc+der": {
		source: "iana",
		extensions: ["dssc"]
	},
	"application/dssc+xml": {
		source: "iana",
		extensions: ["xdssc"]
	},
	"application/dvcs": {
		source: "iana"
	},
	"application/ecmascript": {
		source: "iana",
		compressible: true,
		extensions: ["ecma"]
	},
	"application/edi-consent": {
		source: "iana"
	},
	"application/edi-x12": {
		source: "iana",
		compressible: false
	},
	"application/edifact": {
		source: "iana",
		compressible: false
	},
	"application/efi": {
		source: "iana"
	},
	"application/emergencycalldata.comment+xml": {
		source: "iana"
	},
	"application/emergencycalldata.control+xml": {
		source: "iana"
	},
	"application/emergencycalldata.deviceinfo+xml": {
		source: "iana"
	},
	"application/emergencycalldata.ecall.msd": {
		source: "iana"
	},
	"application/emergencycalldata.providerinfo+xml": {
		source: "iana"
	},
	"application/emergencycalldata.serviceinfo+xml": {
		source: "iana"
	},
	"application/emergencycalldata.subscriberinfo+xml": {
		source: "iana"
	},
	"application/emergencycalldata.veds+xml": {
		source: "iana"
	},
	"application/emma+xml": {
		source: "iana",
		extensions: ["emma"]
	},
	"application/emotionml+xml": {
		source: "iana"
	},
	"application/encaprtp": {
		source: "iana"
	},
	"application/epp+xml": {
		source: "iana"
	},
	"application/epub+zip": {
		source: "iana",
		extensions: ["epub"]
	},
	"application/eshop": {
		source: "iana"
	},
	"application/exi": {
		source: "iana",
		extensions: ["exi"]
	},
	"application/fastinfoset": {
		source: "iana"
	},
	"application/fastsoap": {
		source: "iana"
	},
	"application/fdt+xml": {
		source: "iana"
	},
	"application/fhir+xml": {
		source: "iana"
	},
	"application/fido.trusted-apps+json": {
		compressible: true
	},
	"application/fits": {
		source: "iana"
	},
	"application/font-sfnt": {
		source: "iana"
	},
	"application/font-tdpfr": {
		source: "iana",
		extensions: ["pfr"]
	},
	"application/font-woff": {
		source: "iana",
		compressible: false,
		extensions: ["woff"]
	},
	"application/framework-attributes+xml": {
		source: "iana"
	},
	"application/geo+json": {
		source: "iana",
		compressible: true,
		extensions: ["geojson"]
	},
	"application/geo+json-seq": {
		source: "iana"
	},
	"application/geoxacml+xml": {
		source: "iana"
	},
	"application/gml+xml": {
		source: "iana",
		extensions: ["gml"]
	},
	"application/gpx+xml": {
		source: "apache",
		extensions: ["gpx"]
	},
	"application/gxf": {
		source: "apache",
		extensions: ["gxf"]
	},
	"application/gzip": {
		source: "iana",
		compressible: false,
		extensions: ["gz"]
	},
	"application/h224": {
		source: "iana"
	},
	"application/held+xml": {
		source: "iana"
	},
	"application/hjson": {
		extensions: ["hjson"]
	},
	"application/http": {
		source: "iana"
	},
	"application/hyperstudio": {
		source: "iana",
		extensions: ["stk"]
	},
	"application/ibe-key-request+xml": {
		source: "iana"
	},
	"application/ibe-pkg-reply+xml": {
		source: "iana"
	},
	"application/ibe-pp-data": {
		source: "iana"
	},
	"application/iges": {
		source: "iana"
	},
	"application/im-iscomposing+xml": {
		source: "iana"
	},
	"application/index": {
		source: "iana"
	},
	"application/index.cmd": {
		source: "iana"
	},
	"application/index.obj": {
		source: "iana"
	},
	"application/index.response": {
		source: "iana"
	},
	"application/index.vnd": {
		source: "iana"
	},
	"application/inkml+xml": {
		source: "iana",
		extensions: ["ink", "inkml"]
	},
	"application/iotp": {
		source: "iana"
	},
	"application/ipfix": {
		source: "iana",
		extensions: ["ipfix"]
	},
	"application/ipp": {
		source: "iana"
	},
	"application/isup": {
		source: "iana"
	},
	"application/its+xml": {
		source: "iana"
	},
	"application/java-archive": {
		source: "apache",
		compressible: false,
		extensions: ["jar", "war", "ear"]
	},
	"application/java-serialized-object": {
		source: "apache",
		compressible: false,
		extensions: ["ser"]
	},
	"application/java-vm": {
		source: "apache",
		compressible: false,
		extensions: ["class"]
	},
	"application/javascript": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: ["js", "mjs"]
	},
	"application/jf2feed+json": {
		source: "iana",
		compressible: true
	},
	"application/jose": {
		source: "iana"
	},
	"application/jose+json": {
		source: "iana",
		compressible: true
	},
	"application/jrd+json": {
		source: "iana",
		compressible: true
	},
	"application/json": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: ["json", "map"]
	},
	"application/json-patch+json": {
		source: "iana",
		compressible: true
	},
	"application/json-seq": {
		source: "iana"
	},
	"application/json5": {
		extensions: ["json5"]
	},
	"application/jsonml+json": {
		source: "apache",
		compressible: true,
		extensions: ["jsonml"]
	},
	"application/jwk+json": {
		source: "iana",
		compressible: true
	},
	"application/jwk-set+json": {
		source: "iana",
		compressible: true
	},
	"application/jwt": {
		source: "iana"
	},
	"application/kpml-request+xml": {
		source: "iana"
	},
	"application/kpml-response+xml": {
		source: "iana"
	},
	"application/ld+json": {
		source: "iana",
		compressible: true,
		extensions: ["jsonld"]
	},
	"application/lgr+xml": {
		source: "iana"
	},
	"application/link-format": {
		source: "iana"
	},
	"application/load-control+xml": {
		source: "iana"
	},
	"application/lost+xml": {
		source: "iana",
		extensions: ["lostxml"]
	},
	"application/lostsync+xml": {
		source: "iana"
	},
	"application/lxf": {
		source: "iana"
	},
	"application/mac-binhex40": {
		source: "iana",
		extensions: ["hqx"]
	},
	"application/mac-compactpro": {
		source: "apache",
		extensions: ["cpt"]
	},
	"application/macwriteii": {
		source: "iana"
	},
	"application/mads+xml": {
		source: "iana",
		extensions: ["mads"]
	},
	"application/manifest+json": {
		charset: "UTF-8",
		compressible: true,
		extensions: ["webmanifest"]
	},
	"application/marc": {
		source: "iana",
		extensions: ["mrc"]
	},
	"application/marcxml+xml": {
		source: "iana",
		extensions: ["mrcx"]
	},
	"application/mathematica": {
		source: "iana",
		extensions: ["ma", "nb", "mb"]
	},
	"application/mathml+xml": {
		source: "iana",
		extensions: ["mathml"]
	},
	"application/mathml-content+xml": {
		source: "iana"
	},
	"application/mathml-presentation+xml": {
		source: "iana"
	},
	"application/mbms-associated-procedure-description+xml": {
		source: "iana"
	},
	"application/mbms-deregister+xml": {
		source: "iana"
	},
	"application/mbms-envelope+xml": {
		source: "iana"
	},
	"application/mbms-msk+xml": {
		source: "iana"
	},
	"application/mbms-msk-response+xml": {
		source: "iana"
	},
	"application/mbms-protection-description+xml": {
		source: "iana"
	},
	"application/mbms-reception-report+xml": {
		source: "iana"
	},
	"application/mbms-register+xml": {
		source: "iana"
	},
	"application/mbms-register-response+xml": {
		source: "iana"
	},
	"application/mbms-schedule+xml": {
		source: "iana"
	},
	"application/mbms-user-service-description+xml": {
		source: "iana"
	},
	"application/mbox": {
		source: "iana",
		extensions: ["mbox"]
	},
	"application/media-policy-dataset+xml": {
		source: "iana"
	},
	"application/media_control+xml": {
		source: "iana"
	},
	"application/mediaservercontrol+xml": {
		source: "iana",
		extensions: ["mscml"]
	},
	"application/merge-patch+json": {
		source: "iana",
		compressible: true
	},
	"application/metalink+xml": {
		source: "apache",
		extensions: ["metalink"]
	},
	"application/metalink4+xml": {
		source: "iana",
		extensions: ["meta4"]
	},
	"application/mets+xml": {
		source: "iana",
		extensions: ["mets"]
	},
	"application/mf4": {
		source: "iana"
	},
	"application/mikey": {
		source: "iana"
	},
	"application/mmt-usd+xml": {
		source: "iana"
	},
	"application/mods+xml": {
		source: "iana",
		extensions: ["mods"]
	},
	"application/moss-keys": {
		source: "iana"
	},
	"application/moss-signature": {
		source: "iana"
	},
	"application/mosskey-data": {
		source: "iana"
	},
	"application/mosskey-request": {
		source: "iana"
	},
	"application/mp21": {
		source: "iana",
		extensions: ["m21", "mp21"]
	},
	"application/mp4": {
		source: "iana",
		extensions: ["mp4s", "m4p"]
	},
	"application/mpeg4-generic": {
		source: "iana"
	},
	"application/mpeg4-iod": {
		source: "iana"
	},
	"application/mpeg4-iod-xmt": {
		source: "iana"
	},
	"application/mrb-consumer+xml": {
		source: "iana"
	},
	"application/mrb-publish+xml": {
		source: "iana"
	},
	"application/msc-ivr+xml": {
		source: "iana"
	},
	"application/msc-mixer+xml": {
		source: "iana"
	},
	"application/msword": {
		source: "iana",
		compressible: false,
		extensions: ["doc", "dot"]
	},
	"application/mud+json": {
		source: "iana",
		compressible: true
	},
	"application/mxf": {
		source: "iana",
		extensions: ["mxf"]
	},
	"application/n-quads": {
		source: "iana"
	},
	"application/n-triples": {
		source: "iana"
	},
	"application/nasdata": {
		source: "iana"
	},
	"application/news-checkgroups": {
		source: "iana"
	},
	"application/news-groupinfo": {
		source: "iana"
	},
	"application/news-transmission": {
		source: "iana"
	},
	"application/nlsml+xml": {
		source: "iana"
	},
	"application/node": {
		source: "iana"
	},
	"application/nss": {
		source: "iana"
	},
	"application/ocsp-request": {
		source: "iana"
	},
	"application/ocsp-response": {
		source: "iana"
	},
	"application/octet-stream": {
		source: "iana",
		compressible: false,
		extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
	},
	"application/oda": {
		source: "iana",
		extensions: ["oda"]
	},
	"application/odx": {
		source: "iana"
	},
	"application/oebps-package+xml": {
		source: "iana",
		extensions: ["opf"]
	},
	"application/ogg": {
		source: "iana",
		compressible: false,
		extensions: ["ogx"]
	},
	"application/omdoc+xml": {
		source: "apache",
		extensions: ["omdoc"]
	},
	"application/onenote": {
		source: "apache",
		extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
	},
	"application/oxps": {
		source: "iana",
		extensions: ["oxps"]
	},
	"application/p2p-overlay+xml": {
		source: "iana"
	},
	"application/parityfec": {
		source: "iana"
	},
	"application/passport": {
		source: "iana"
	},
	"application/patch-ops-error+xml": {
		source: "iana",
		extensions: ["xer"]
	},
	"application/pdf": {
		source: "iana",
		compressible: false,
		extensions: ["pdf"]
	},
	"application/pdx": {
		source: "iana"
	},
	"application/pgp-encrypted": {
		source: "iana",
		compressible: false,
		extensions: ["pgp"]
	},
	"application/pgp-keys": {
		source: "iana"
	},
	"application/pgp-signature": {
		source: "iana",
		extensions: ["asc", "sig"]
	},
	"application/pics-rules": {
		source: "apache",
		extensions: ["prf"]
	},
	"application/pidf+xml": {
		source: "iana"
	},
	"application/pidf-diff+xml": {
		source: "iana"
	},
	"application/pkcs10": {
		source: "iana",
		extensions: ["p10"]
	},
	"application/pkcs12": {
		source: "iana"
	},
	"application/pkcs7-mime": {
		source: "iana",
		extensions: ["p7m", "p7c"]
	},
	"application/pkcs7-signature": {
		source: "iana",
		extensions: ["p7s"]
	},
	"application/pkcs8": {
		source: "iana",
		extensions: ["p8"]
	},
	"application/pkcs8-encrypted": {
		source: "iana"
	},
	"application/pkix-attr-cert": {
		source: "iana",
		extensions: ["ac"]
	},
	"application/pkix-cert": {
		source: "iana",
		extensions: ["cer"]
	},
	"application/pkix-crl": {
		source: "iana",
		extensions: ["crl"]
	},
	"application/pkix-pkipath": {
		source: "iana",
		extensions: ["pkipath"]
	},
	"application/pkixcmp": {
		source: "iana",
		extensions: ["pki"]
	},
	"application/pls+xml": {
		source: "iana",
		extensions: ["pls"]
	},
	"application/poc-settings+xml": {
		source: "iana"
	},
	"application/postscript": {
		source: "iana",
		compressible: true,
		extensions: ["ai", "eps", "ps"]
	},
	"application/ppsp-tracker+json": {
		source: "iana",
		compressible: true
	},
	"application/problem+json": {
		source: "iana",
		compressible: true
	},
	"application/problem+xml": {
		source: "iana"
	},
	"application/provenance+xml": {
		source: "iana"
	},
	"application/prs.alvestrand.titrax-sheet": {
		source: "iana"
	},
	"application/prs.cww": {
		source: "iana",
		extensions: ["cww"]
	},
	"application/prs.hpub+zip": {
		source: "iana"
	},
	"application/prs.nprend": {
		source: "iana"
	},
	"application/prs.plucker": {
		source: "iana"
	},
	"application/prs.rdf-xml-crypt": {
		source: "iana"
	},
	"application/prs.xsf+xml": {
		source: "iana"
	},
	"application/pskc+xml": {
		source: "iana",
		extensions: ["pskcxml"]
	},
	"application/qsig": {
		source: "iana"
	},
	"application/raml+yaml": {
		compressible: true,
		extensions: ["raml"]
	},
	"application/raptorfec": {
		source: "iana"
	},
	"application/rdap+json": {
		source: "iana",
		compressible: true
	},
	"application/rdf+xml": {
		source: "iana",
		compressible: true,
		extensions: ["rdf"]
	},
	"application/reginfo+xml": {
		source: "iana",
		extensions: ["rif"]
	},
	"application/relax-ng-compact-syntax": {
		source: "iana",
		extensions: ["rnc"]
	},
	"application/remote-printing": {
		source: "iana"
	},
	"application/reputon+json": {
		source: "iana",
		compressible: true
	},
	"application/resource-lists+xml": {
		source: "iana",
		extensions: ["rl"]
	},
	"application/resource-lists-diff+xml": {
		source: "iana",
		extensions: ["rld"]
	},
	"application/rfc+xml": {
		source: "iana"
	},
	"application/riscos": {
		source: "iana"
	},
	"application/rlmi+xml": {
		source: "iana"
	},
	"application/rls-services+xml": {
		source: "iana",
		extensions: ["rs"]
	},
	"application/route-apd+xml": {
		source: "iana"
	},
	"application/route-s-tsid+xml": {
		source: "iana"
	},
	"application/route-usd+xml": {
		source: "iana"
	},
	"application/rpki-ghostbusters": {
		source: "iana",
		extensions: ["gbr"]
	},
	"application/rpki-manifest": {
		source: "iana",
		extensions: ["mft"]
	},
	"application/rpki-publication": {
		source: "iana"
	},
	"application/rpki-roa": {
		source: "iana",
		extensions: ["roa"]
	},
	"application/rpki-updown": {
		source: "iana"
	},
	"application/rsd+xml": {
		source: "apache",
		extensions: ["rsd"]
	},
	"application/rss+xml": {
		source: "apache",
		compressible: true,
		extensions: ["rss"]
	},
	"application/rtf": {
		source: "iana",
		compressible: true,
		extensions: ["rtf"]
	},
	"application/rtploopback": {
		source: "iana"
	},
	"application/rtx": {
		source: "iana"
	},
	"application/samlassertion+xml": {
		source: "iana"
	},
	"application/samlmetadata+xml": {
		source: "iana"
	},
	"application/sbml+xml": {
		source: "iana",
		extensions: ["sbml"]
	},
	"application/scaip+xml": {
		source: "iana"
	},
	"application/scim+json": {
		source: "iana",
		compressible: true
	},
	"application/scvp-cv-request": {
		source: "iana",
		extensions: ["scq"]
	},
	"application/scvp-cv-response": {
		source: "iana",
		extensions: ["scs"]
	},
	"application/scvp-vp-request": {
		source: "iana",
		extensions: ["spq"]
	},
	"application/scvp-vp-response": {
		source: "iana",
		extensions: ["spp"]
	},
	"application/sdp": {
		source: "iana",
		extensions: ["sdp"]
	},
	"application/sep+xml": {
		source: "iana"
	},
	"application/sep-exi": {
		source: "iana"
	},
	"application/session-info": {
		source: "iana"
	},
	"application/set-payment": {
		source: "iana"
	},
	"application/set-payment-initiation": {
		source: "iana",
		extensions: ["setpay"]
	},
	"application/set-registration": {
		source: "iana"
	},
	"application/set-registration-initiation": {
		source: "iana",
		extensions: ["setreg"]
	},
	"application/sgml": {
		source: "iana"
	},
	"application/sgml-open-catalog": {
		source: "iana"
	},
	"application/shf+xml": {
		source: "iana",
		extensions: ["shf"]
	},
	"application/sieve": {
		source: "iana"
	},
	"application/simple-filter+xml": {
		source: "iana"
	},
	"application/simple-message-summary": {
		source: "iana"
	},
	"application/simplesymbolcontainer": {
		source: "iana"
	},
	"application/slate": {
		source: "iana"
	},
	"application/smil": {
		source: "iana"
	},
	"application/smil+xml": {
		source: "iana",
		extensions: ["smi", "smil"]
	},
	"application/smpte336m": {
		source: "iana"
	},
	"application/soap+fastinfoset": {
		source: "iana"
	},
	"application/soap+xml": {
		source: "iana",
		compressible: true
	},
	"application/sparql-query": {
		source: "iana",
		extensions: ["rq"]
	},
	"application/sparql-results+xml": {
		source: "iana",
		extensions: ["srx"]
	},
	"application/spirits-event+xml": {
		source: "iana"
	},
	"application/sql": {
		source: "iana"
	},
	"application/srgs": {
		source: "iana",
		extensions: ["gram"]
	},
	"application/srgs+xml": {
		source: "iana",
		extensions: ["grxml"]
	},
	"application/sru+xml": {
		source: "iana",
		extensions: ["sru"]
	},
	"application/ssdl+xml": {
		source: "apache",
		extensions: ["ssdl"]
	},
	"application/ssml+xml": {
		source: "iana",
		extensions: ["ssml"]
	},
	"application/tamp-apex-update": {
		source: "iana"
	},
	"application/tamp-apex-update-confirm": {
		source: "iana"
	},
	"application/tamp-community-update": {
		source: "iana"
	},
	"application/tamp-community-update-confirm": {
		source: "iana"
	},
	"application/tamp-error": {
		source: "iana"
	},
	"application/tamp-sequence-adjust": {
		source: "iana"
	},
	"application/tamp-sequence-adjust-confirm": {
		source: "iana"
	},
	"application/tamp-status-query": {
		source: "iana"
	},
	"application/tamp-status-response": {
		source: "iana"
	},
	"application/tamp-update": {
		source: "iana"
	},
	"application/tamp-update-confirm": {
		source: "iana"
	},
	"application/tar": {
		compressible: true
	},
	"application/tei+xml": {
		source: "iana",
		extensions: ["tei", "teicorpus"]
	},
	"application/thraud+xml": {
		source: "iana",
		extensions: ["tfi"]
	},
	"application/timestamp-query": {
		source: "iana"
	},
	"application/timestamp-reply": {
		source: "iana"
	},
	"application/timestamped-data": {
		source: "iana",
		extensions: ["tsd"]
	},
	"application/tnauthlist": {
		source: "iana"
	},
	"application/trig": {
		source: "iana"
	},
	"application/ttml+xml": {
		source: "iana"
	},
	"application/tve-trigger": {
		source: "iana"
	},
	"application/ulpfec": {
		source: "iana"
	},
	"application/urc-grpsheet+xml": {
		source: "iana"
	},
	"application/urc-ressheet+xml": {
		source: "iana"
	},
	"application/urc-targetdesc+xml": {
		source: "iana"
	},
	"application/urc-uisocketdesc+xml": {
		source: "iana"
	},
	"application/vcard+json": {
		source: "iana",
		compressible: true
	},
	"application/vcard+xml": {
		source: "iana"
	},
	"application/vemmi": {
		source: "iana"
	},
	"application/vividence.scriptfile": {
		source: "apache"
	},
	"application/vnd.1000minds.decision-model+xml": {
		source: "iana"
	},
	"application/vnd.3gpp-prose+xml": {
		source: "iana"
	},
	"application/vnd.3gpp-prose-pc3ch+xml": {
		source: "iana"
	},
	"application/vnd.3gpp-v2x-local-service-information": {
		source: "iana"
	},
	"application/vnd.3gpp.access-transfer-events+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.bsf+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.gmop+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-info+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-location-info+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mcptt-signed+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.mid-call+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.pic-bw-large": {
		source: "iana",
		extensions: ["plb"]
	},
	"application/vnd.3gpp.pic-bw-small": {
		source: "iana",
		extensions: ["psb"]
	},
	"application/vnd.3gpp.pic-bw-var": {
		source: "iana",
		extensions: ["pvb"]
	},
	"application/vnd.3gpp.sms": {
		source: "iana"
	},
	"application/vnd.3gpp.sms+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.srvcc-ext+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.srvcc-info+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.state-and-event-info+xml": {
		source: "iana"
	},
	"application/vnd.3gpp.ussd+xml": {
		source: "iana"
	},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
		source: "iana"
	},
	"application/vnd.3gpp2.sms": {
		source: "iana"
	},
	"application/vnd.3gpp2.tcap": {
		source: "iana",
		extensions: ["tcap"]
	},
	"application/vnd.3lightssoftware.imagescal": {
		source: "iana"
	},
	"application/vnd.3m.post-it-notes": {
		source: "iana",
		extensions: ["pwn"]
	},
	"application/vnd.accpac.simply.aso": {
		source: "iana",
		extensions: ["aso"]
	},
	"application/vnd.accpac.simply.imp": {
		source: "iana",
		extensions: ["imp"]
	},
	"application/vnd.acucobol": {
		source: "iana",
		extensions: ["acu"]
	},
	"application/vnd.acucorp": {
		source: "iana",
		extensions: ["atc", "acutc"]
	},
	"application/vnd.adobe.air-application-installer-package+zip": {
		source: "apache",
		extensions: ["air"]
	},
	"application/vnd.adobe.flash.movie": {
		source: "iana"
	},
	"application/vnd.adobe.formscentral.fcdt": {
		source: "iana",
		extensions: ["fcdt"]
	},
	"application/vnd.adobe.fxp": {
		source: "iana",
		extensions: ["fxp", "fxpl"]
	},
	"application/vnd.adobe.partial-upload": {
		source: "iana"
	},
	"application/vnd.adobe.xdp+xml": {
		source: "iana",
		extensions: ["xdp"]
	},
	"application/vnd.adobe.xfdf": {
		source: "iana",
		extensions: ["xfdf"]
	},
	"application/vnd.aether.imp": {
		source: "iana"
	},
	"application/vnd.ah-barcode": {
		source: "iana"
	},
	"application/vnd.ahead.space": {
		source: "iana",
		extensions: ["ahead"]
	},
	"application/vnd.airzip.filesecure.azf": {
		source: "iana",
		extensions: ["azf"]
	},
	"application/vnd.airzip.filesecure.azs": {
		source: "iana",
		extensions: ["azs"]
	},
	"application/vnd.amadeus+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.amazon.ebook": {
		source: "apache",
		extensions: ["azw"]
	},
	"application/vnd.amazon.mobi8-ebook": {
		source: "iana"
	},
	"application/vnd.americandynamics.acc": {
		source: "iana",
		extensions: ["acc"]
	},
	"application/vnd.amiga.ami": {
		source: "iana",
		extensions: ["ami"]
	},
	"application/vnd.amundsen.maze+xml": {
		source: "iana"
	},
	"application/vnd.android.package-archive": {
		source: "apache",
		compressible: false,
		extensions: ["apk"]
	},
	"application/vnd.anki": {
		source: "iana"
	},
	"application/vnd.anser-web-certificate-issue-initiation": {
		source: "iana",
		extensions: ["cii"]
	},
	"application/vnd.anser-web-funds-transfer-initiation": {
		source: "apache",
		extensions: ["fti"]
	},
	"application/vnd.antix.game-component": {
		source: "iana",
		extensions: ["atx"]
	},
	"application/vnd.apache.thrift.binary": {
		source: "iana"
	},
	"application/vnd.apache.thrift.compact": {
		source: "iana"
	},
	"application/vnd.apache.thrift.json": {
		source: "iana"
	},
	"application/vnd.api+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.apothekende.reservation+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.apple.installer+xml": {
		source: "iana",
		extensions: ["mpkg"]
	},
	"application/vnd.apple.mpegurl": {
		source: "iana",
		extensions: ["m3u8"]
	},
	"application/vnd.apple.pkpass": {
		compressible: false,
		extensions: ["pkpass"]
	},
	"application/vnd.arastra.swi": {
		source: "iana"
	},
	"application/vnd.aristanetworks.swi": {
		source: "iana",
		extensions: ["swi"]
	},
	"application/vnd.artsquare": {
		source: "iana"
	},
	"application/vnd.astraea-software.iota": {
		source: "iana",
		extensions: ["iota"]
	},
	"application/vnd.audiograph": {
		source: "iana",
		extensions: ["aep"]
	},
	"application/vnd.autopackage": {
		source: "iana"
	},
	"application/vnd.avalon+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.avistar+xml": {
		source: "iana"
	},
	"application/vnd.balsamiq.bmml+xml": {
		source: "iana"
	},
	"application/vnd.balsamiq.bmpr": {
		source: "iana"
	},
	"application/vnd.bbf.usp.msg": {
		source: "iana"
	},
	"application/vnd.bbf.usp.msg+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.bekitzur-stech+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.bint.med-content": {
		source: "iana"
	},
	"application/vnd.biopax.rdf+xml": {
		source: "iana"
	},
	"application/vnd.blink-idb-value-wrapper": {
		source: "iana"
	},
	"application/vnd.blueice.multipass": {
		source: "iana",
		extensions: ["mpm"]
	},
	"application/vnd.bluetooth.ep.oob": {
		source: "iana"
	},
	"application/vnd.bluetooth.le.oob": {
		source: "iana"
	},
	"application/vnd.bmi": {
		source: "iana",
		extensions: ["bmi"]
	},
	"application/vnd.businessobjects": {
		source: "iana",
		extensions: ["rep"]
	},
	"application/vnd.cab-jscript": {
		source: "iana"
	},
	"application/vnd.canon-cpdl": {
		source: "iana"
	},
	"application/vnd.canon-lips": {
		source: "iana"
	},
	"application/vnd.capasystems-pg+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.cendio.thinlinc.clientconf": {
		source: "iana"
	},
	"application/vnd.century-systems.tcp_stream": {
		source: "iana"
	},
	"application/vnd.chemdraw+xml": {
		source: "iana",
		extensions: ["cdxml"]
	},
	"application/vnd.chess-pgn": {
		source: "iana"
	},
	"application/vnd.chipnuts.karaoke-mmd": {
		source: "iana",
		extensions: ["mmd"]
	},
	"application/vnd.cinderella": {
		source: "iana",
		extensions: ["cdy"]
	},
	"application/vnd.cirpack.isdn-ext": {
		source: "iana"
	},
	"application/vnd.citationstyles.style+xml": {
		source: "iana"
	},
	"application/vnd.claymore": {
		source: "iana",
		extensions: ["cla"]
	},
	"application/vnd.cloanto.rp9": {
		source: "iana",
		extensions: ["rp9"]
	},
	"application/vnd.clonk.c4group": {
		source: "iana",
		extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
	},
	"application/vnd.cluetrust.cartomobile-config": {
		source: "iana",
		extensions: ["c11amc"]
	},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
		source: "iana",
		extensions: ["c11amz"]
	},
	"application/vnd.coffeescript": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.document": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.document-template": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.presentation": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.presentation-template": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.spreadsheet": {
		source: "iana"
	},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
		source: "iana"
	},
	"application/vnd.collection+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.collection.doc+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.collection.next+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.comicbook+zip": {
		source: "iana"
	},
	"application/vnd.comicbook-rar": {
		source: "iana"
	},
	"application/vnd.commerce-battelle": {
		source: "iana"
	},
	"application/vnd.commonspace": {
		source: "iana",
		extensions: ["csp"]
	},
	"application/vnd.contact.cmsg": {
		source: "iana",
		extensions: ["cdbcmsg"]
	},
	"application/vnd.coreos.ignition+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.cosmocaller": {
		source: "iana",
		extensions: ["cmc"]
	},
	"application/vnd.crick.clicker": {
		source: "iana",
		extensions: ["clkx"]
	},
	"application/vnd.crick.clicker.keyboard": {
		source: "iana",
		extensions: ["clkk"]
	},
	"application/vnd.crick.clicker.palette": {
		source: "iana",
		extensions: ["clkp"]
	},
	"application/vnd.crick.clicker.template": {
		source: "iana",
		extensions: ["clkt"]
	},
	"application/vnd.crick.clicker.wordbank": {
		source: "iana",
		extensions: ["clkw"]
	},
	"application/vnd.criticaltools.wbs+xml": {
		source: "iana",
		extensions: ["wbs"]
	},
	"application/vnd.ctc-posml": {
		source: "iana",
		extensions: ["pml"]
	},
	"application/vnd.ctct.ws+xml": {
		source: "iana"
	},
	"application/vnd.cups-pdf": {
		source: "iana"
	},
	"application/vnd.cups-postscript": {
		source: "iana"
	},
	"application/vnd.cups-ppd": {
		source: "iana",
		extensions: ["ppd"]
	},
	"application/vnd.cups-raster": {
		source: "iana"
	},
	"application/vnd.cups-raw": {
		source: "iana"
	},
	"application/vnd.curl": {
		source: "iana"
	},
	"application/vnd.curl.car": {
		source: "apache",
		extensions: ["car"]
	},
	"application/vnd.curl.pcurl": {
		source: "apache",
		extensions: ["pcurl"]
	},
	"application/vnd.cyan.dean.root+xml": {
		source: "iana"
	},
	"application/vnd.cybank": {
		source: "iana"
	},
	"application/vnd.d2l.coursepackage1p0+zip": {
		source: "iana"
	},
	"application/vnd.dart": {
		source: "iana",
		compressible: true,
		extensions: ["dart"]
	},
	"application/vnd.data-vision.rdz": {
		source: "iana",
		extensions: ["rdz"]
	},
	"application/vnd.datapackage+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.dataresource+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.debian.binary-package": {
		source: "iana"
	},
	"application/vnd.dece.data": {
		source: "iana",
		extensions: ["uvf", "uvvf", "uvd", "uvvd"]
	},
	"application/vnd.dece.ttml+xml": {
		source: "iana",
		extensions: ["uvt", "uvvt"]
	},
	"application/vnd.dece.unspecified": {
		source: "iana",
		extensions: ["uvx", "uvvx"]
	},
	"application/vnd.dece.zip": {
		source: "iana",
		extensions: ["uvz", "uvvz"]
	},
	"application/vnd.denovo.fcselayout-link": {
		source: "iana",
		extensions: ["fe_launch"]
	},
	"application/vnd.desmume-movie": {
		source: "iana"
	},
	"application/vnd.desmume.movie": {
		source: "apache"
	},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
		source: "iana"
	},
	"application/vnd.dm.delegation+xml": {
		source: "iana"
	},
	"application/vnd.dna": {
		source: "iana",
		extensions: ["dna"]
	},
	"application/vnd.document+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.dolby.mlp": {
		source: "apache",
		extensions: ["mlp"]
	},
	"application/vnd.dolby.mobile.1": {
		source: "iana"
	},
	"application/vnd.dolby.mobile.2": {
		source: "iana"
	},
	"application/vnd.doremir.scorecloud-binary-document": {
		source: "iana"
	},
	"application/vnd.dpgraph": {
		source: "iana",
		extensions: ["dpg"]
	},
	"application/vnd.dreamfactory": {
		source: "iana",
		extensions: ["dfac"]
	},
	"application/vnd.drive+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ds-keypoint": {
		source: "apache",
		extensions: ["kpxx"]
	},
	"application/vnd.dtg.local": {
		source: "iana"
	},
	"application/vnd.dtg.local.flash": {
		source: "iana"
	},
	"application/vnd.dtg.local.html": {
		source: "iana"
	},
	"application/vnd.dvb.ait": {
		source: "iana",
		extensions: ["ait"]
	},
	"application/vnd.dvb.dvbj": {
		source: "iana"
	},
	"application/vnd.dvb.esgcontainer": {
		source: "iana"
	},
	"application/vnd.dvb.ipdcdftnotifaccess": {
		source: "iana"
	},
	"application/vnd.dvb.ipdcesgaccess": {
		source: "iana"
	},
	"application/vnd.dvb.ipdcesgaccess2": {
		source: "iana"
	},
	"application/vnd.dvb.ipdcesgpdd": {
		source: "iana"
	},
	"application/vnd.dvb.ipdcroaming": {
		source: "iana"
	},
	"application/vnd.dvb.iptv.alfec-base": {
		source: "iana"
	},
	"application/vnd.dvb.iptv.alfec-enhancement": {
		source: "iana"
	},
	"application/vnd.dvb.notif-aggregate-root+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-container+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-generic+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-ia-msglist+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
		source: "iana"
	},
	"application/vnd.dvb.notif-init+xml": {
		source: "iana"
	},
	"application/vnd.dvb.pfr": {
		source: "iana"
	},
	"application/vnd.dvb.service": {
		source: "iana",
		extensions: ["svc"]
	},
	"application/vnd.dxr": {
		source: "iana"
	},
	"application/vnd.dynageo": {
		source: "iana",
		extensions: ["geo"]
	},
	"application/vnd.dzr": {
		source: "iana"
	},
	"application/vnd.easykaraoke.cdgdownload": {
		source: "iana"
	},
	"application/vnd.ecdis-update": {
		source: "iana"
	},
	"application/vnd.ecip.rlp": {
		source: "iana"
	},
	"application/vnd.ecowin.chart": {
		source: "iana",
		extensions: ["mag"]
	},
	"application/vnd.ecowin.filerequest": {
		source: "iana"
	},
	"application/vnd.ecowin.fileupdate": {
		source: "iana"
	},
	"application/vnd.ecowin.series": {
		source: "iana"
	},
	"application/vnd.ecowin.seriesrequest": {
		source: "iana"
	},
	"application/vnd.ecowin.seriesupdate": {
		source: "iana"
	},
	"application/vnd.efi.img": {
		source: "iana"
	},
	"application/vnd.efi.iso": {
		source: "iana"
	},
	"application/vnd.emclient.accessrequest+xml": {
		source: "iana"
	},
	"application/vnd.enliven": {
		source: "iana",
		extensions: ["nml"]
	},
	"application/vnd.enphase.envoy": {
		source: "iana"
	},
	"application/vnd.eprints.data+xml": {
		source: "iana"
	},
	"application/vnd.epson.esf": {
		source: "iana",
		extensions: ["esf"]
	},
	"application/vnd.epson.msf": {
		source: "iana",
		extensions: ["msf"]
	},
	"application/vnd.epson.quickanime": {
		source: "iana",
		extensions: ["qam"]
	},
	"application/vnd.epson.salt": {
		source: "iana",
		extensions: ["slt"]
	},
	"application/vnd.epson.ssf": {
		source: "iana",
		extensions: ["ssf"]
	},
	"application/vnd.ericsson.quickcall": {
		source: "iana"
	},
	"application/vnd.espass-espass+zip": {
		source: "iana"
	},
	"application/vnd.eszigno3+xml": {
		source: "iana",
		extensions: ["es3", "et3"]
	},
	"application/vnd.etsi.aoc+xml": {
		source: "iana"
	},
	"application/vnd.etsi.asic-e+zip": {
		source: "iana"
	},
	"application/vnd.etsi.asic-s+zip": {
		source: "iana"
	},
	"application/vnd.etsi.cug+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvcommand+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvdiscovery+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvprofile+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvsad-bc+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvsad-cod+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvsad-npvr+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvservice+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvsync+xml": {
		source: "iana"
	},
	"application/vnd.etsi.iptvueprofile+xml": {
		source: "iana"
	},
	"application/vnd.etsi.mcid+xml": {
		source: "iana"
	},
	"application/vnd.etsi.mheg5": {
		source: "iana"
	},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
		source: "iana"
	},
	"application/vnd.etsi.pstn+xml": {
		source: "iana"
	},
	"application/vnd.etsi.sci+xml": {
		source: "iana"
	},
	"application/vnd.etsi.simservs+xml": {
		source: "iana"
	},
	"application/vnd.etsi.timestamp-token": {
		source: "iana"
	},
	"application/vnd.etsi.tsl+xml": {
		source: "iana"
	},
	"application/vnd.etsi.tsl.der": {
		source: "iana"
	},
	"application/vnd.eudora.data": {
		source: "iana"
	},
	"application/vnd.evolv.ecig.profile": {
		source: "iana"
	},
	"application/vnd.evolv.ecig.settings": {
		source: "iana"
	},
	"application/vnd.evolv.ecig.theme": {
		source: "iana"
	},
	"application/vnd.ezpix-album": {
		source: "iana",
		extensions: ["ez2"]
	},
	"application/vnd.ezpix-package": {
		source: "iana",
		extensions: ["ez3"]
	},
	"application/vnd.f-secure.mobile": {
		source: "iana"
	},
	"application/vnd.fastcopy-disk-image": {
		source: "iana"
	},
	"application/vnd.fdf": {
		source: "iana",
		extensions: ["fdf"]
	},
	"application/vnd.fdsn.mseed": {
		source: "iana",
		extensions: ["mseed"]
	},
	"application/vnd.fdsn.seed": {
		source: "iana",
		extensions: ["seed", "dataless"]
	},
	"application/vnd.ffsns": {
		source: "iana"
	},
	"application/vnd.filmit.zfc": {
		source: "iana"
	},
	"application/vnd.fints": {
		source: "iana"
	},
	"application/vnd.firemonkeys.cloudcell": {
		source: "iana"
	},
	"application/vnd.flographit": {
		source: "iana",
		extensions: ["gph"]
	},
	"application/vnd.fluxtime.clip": {
		source: "iana",
		extensions: ["ftc"]
	},
	"application/vnd.font-fontforge-sfd": {
		source: "iana"
	},
	"application/vnd.framemaker": {
		source: "iana",
		extensions: ["fm", "frame", "maker", "book"]
	},
	"application/vnd.frogans.fnc": {
		source: "iana",
		extensions: ["fnc"]
	},
	"application/vnd.frogans.ltf": {
		source: "iana",
		extensions: ["ltf"]
	},
	"application/vnd.fsc.weblaunch": {
		source: "iana",
		extensions: ["fsc"]
	},
	"application/vnd.fujitsu.oasys": {
		source: "iana",
		extensions: ["oas"]
	},
	"application/vnd.fujitsu.oasys2": {
		source: "iana",
		extensions: ["oa2"]
	},
	"application/vnd.fujitsu.oasys3": {
		source: "iana",
		extensions: ["oa3"]
	},
	"application/vnd.fujitsu.oasysgp": {
		source: "iana",
		extensions: ["fg5"]
	},
	"application/vnd.fujitsu.oasysprs": {
		source: "iana",
		extensions: ["bh2"]
	},
	"application/vnd.fujixerox.art-ex": {
		source: "iana"
	},
	"application/vnd.fujixerox.art4": {
		source: "iana"
	},
	"application/vnd.fujixerox.ddd": {
		source: "iana",
		extensions: ["ddd"]
	},
	"application/vnd.fujixerox.docuworks": {
		source: "iana",
		extensions: ["xdw"]
	},
	"application/vnd.fujixerox.docuworks.binder": {
		source: "iana",
		extensions: ["xbd"]
	},
	"application/vnd.fujixerox.docuworks.container": {
		source: "iana"
	},
	"application/vnd.fujixerox.hbpl": {
		source: "iana"
	},
	"application/vnd.fut-misnet": {
		source: "iana"
	},
	"application/vnd.fuzzysheet": {
		source: "iana",
		extensions: ["fzs"]
	},
	"application/vnd.genomatix.tuxedo": {
		source: "iana",
		extensions: ["txd"]
	},
	"application/vnd.geo+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.geocube+xml": {
		source: "iana"
	},
	"application/vnd.geogebra.file": {
		source: "iana",
		extensions: ["ggb"]
	},
	"application/vnd.geogebra.tool": {
		source: "iana",
		extensions: ["ggt"]
	},
	"application/vnd.geometry-explorer": {
		source: "iana",
		extensions: ["gex", "gre"]
	},
	"application/vnd.geonext": {
		source: "iana",
		extensions: ["gxt"]
	},
	"application/vnd.geoplan": {
		source: "iana",
		extensions: ["g2w"]
	},
	"application/vnd.geospace": {
		source: "iana",
		extensions: ["g3w"]
	},
	"application/vnd.gerber": {
		source: "iana"
	},
	"application/vnd.globalplatform.card-content-mgt": {
		source: "iana"
	},
	"application/vnd.globalplatform.card-content-mgt-response": {
		source: "iana"
	},
	"application/vnd.gmx": {
		source: "iana",
		extensions: ["gmx"]
	},
	"application/vnd.google-apps.document": {
		compressible: false,
		extensions: ["gdoc"]
	},
	"application/vnd.google-apps.presentation": {
		compressible: false,
		extensions: ["gslides"]
	},
	"application/vnd.google-apps.spreadsheet": {
		compressible: false,
		extensions: ["gsheet"]
	},
	"application/vnd.google-earth.kml+xml": {
		source: "iana",
		compressible: true,
		extensions: ["kml"]
	},
	"application/vnd.google-earth.kmz": {
		source: "iana",
		compressible: false,
		extensions: ["kmz"]
	},
	"application/vnd.gov.sk.e-form+xml": {
		source: "iana"
	},
	"application/vnd.gov.sk.e-form+zip": {
		source: "iana"
	},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
		source: "iana"
	},
	"application/vnd.grafeq": {
		source: "iana",
		extensions: ["gqf", "gqs"]
	},
	"application/vnd.gridmp": {
		source: "iana"
	},
	"application/vnd.groove-account": {
		source: "iana",
		extensions: ["gac"]
	},
	"application/vnd.groove-help": {
		source: "iana",
		extensions: ["ghf"]
	},
	"application/vnd.groove-identity-message": {
		source: "iana",
		extensions: ["gim"]
	},
	"application/vnd.groove-injector": {
		source: "iana",
		extensions: ["grv"]
	},
	"application/vnd.groove-tool-message": {
		source: "iana",
		extensions: ["gtm"]
	},
	"application/vnd.groove-tool-template": {
		source: "iana",
		extensions: ["tpl"]
	},
	"application/vnd.groove-vcard": {
		source: "iana",
		extensions: ["vcg"]
	},
	"application/vnd.hal+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.hal+xml": {
		source: "iana",
		extensions: ["hal"]
	},
	"application/vnd.handheld-entertainment+xml": {
		source: "iana",
		extensions: ["zmm"]
	},
	"application/vnd.hbci": {
		source: "iana",
		extensions: ["hbci"]
	},
	"application/vnd.hc+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.hcl-bireports": {
		source: "iana"
	},
	"application/vnd.hdt": {
		source: "iana"
	},
	"application/vnd.heroku+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.hhe.lesson-player": {
		source: "iana",
		extensions: ["les"]
	},
	"application/vnd.hp-hpgl": {
		source: "iana",
		extensions: ["hpgl"]
	},
	"application/vnd.hp-hpid": {
		source: "iana",
		extensions: ["hpid"]
	},
	"application/vnd.hp-hps": {
		source: "iana",
		extensions: ["hps"]
	},
	"application/vnd.hp-jlyt": {
		source: "iana",
		extensions: ["jlt"]
	},
	"application/vnd.hp-pcl": {
		source: "iana",
		extensions: ["pcl"]
	},
	"application/vnd.hp-pclxl": {
		source: "iana",
		extensions: ["pclxl"]
	},
	"application/vnd.httphone": {
		source: "iana"
	},
	"application/vnd.hydrostatix.sof-data": {
		source: "iana",
		extensions: ["sfd-hdstx"]
	},
	"application/vnd.hyper-item+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.hyperdrive+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.hzn-3d-crossword": {
		source: "iana"
	},
	"application/vnd.ibm.afplinedata": {
		source: "iana"
	},
	"application/vnd.ibm.electronic-media": {
		source: "iana"
	},
	"application/vnd.ibm.minipay": {
		source: "iana",
		extensions: ["mpy"]
	},
	"application/vnd.ibm.modcap": {
		source: "iana",
		extensions: ["afp", "listafp", "list3820"]
	},
	"application/vnd.ibm.rights-management": {
		source: "iana",
		extensions: ["irm"]
	},
	"application/vnd.ibm.secure-container": {
		source: "iana",
		extensions: ["sc"]
	},
	"application/vnd.iccprofile": {
		source: "iana",
		extensions: ["icc", "icm"]
	},
	"application/vnd.ieee.1905": {
		source: "iana"
	},
	"application/vnd.igloader": {
		source: "iana",
		extensions: ["igl"]
	},
	"application/vnd.imagemeter.folder+zip": {
		source: "iana"
	},
	"application/vnd.imagemeter.image+zip": {
		source: "iana"
	},
	"application/vnd.immervision-ivp": {
		source: "iana",
		extensions: ["ivp"]
	},
	"application/vnd.immervision-ivu": {
		source: "iana",
		extensions: ["ivu"]
	},
	"application/vnd.ims.imsccv1p1": {
		source: "iana"
	},
	"application/vnd.ims.imsccv1p2": {
		source: "iana"
	},
	"application/vnd.ims.imsccv1p3": {
		source: "iana"
	},
	"application/vnd.ims.lis.v2.result+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ims.lti.v2.toolproxy+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ims.lti.v2.toolsettings+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.informedcontrol.rms+xml": {
		source: "iana"
	},
	"application/vnd.informix-visionary": {
		source: "iana"
	},
	"application/vnd.infotech.project": {
		source: "iana"
	},
	"application/vnd.infotech.project+xml": {
		source: "iana"
	},
	"application/vnd.innopath.wamp.notification": {
		source: "iana"
	},
	"application/vnd.insors.igm": {
		source: "iana",
		extensions: ["igm"]
	},
	"application/vnd.intercon.formnet": {
		source: "iana",
		extensions: ["xpw", "xpx"]
	},
	"application/vnd.intergeo": {
		source: "iana",
		extensions: ["i2g"]
	},
	"application/vnd.intertrust.digibox": {
		source: "iana"
	},
	"application/vnd.intertrust.nncp": {
		source: "iana"
	},
	"application/vnd.intu.qbo": {
		source: "iana",
		extensions: ["qbo"]
	},
	"application/vnd.intu.qfx": {
		source: "iana",
		extensions: ["qfx"]
	},
	"application/vnd.iptc.g2.catalogitem+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.conceptitem+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.newsitem+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.newsmessage+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.packageitem+xml": {
		source: "iana"
	},
	"application/vnd.iptc.g2.planningitem+xml": {
		source: "iana"
	},
	"application/vnd.ipunplugged.rcprofile": {
		source: "iana",
		extensions: ["rcprofile"]
	},
	"application/vnd.irepository.package+xml": {
		source: "iana",
		extensions: ["irp"]
	},
	"application/vnd.is-xpr": {
		source: "iana",
		extensions: ["xpr"]
	},
	"application/vnd.isac.fcs": {
		source: "iana",
		extensions: ["fcs"]
	},
	"application/vnd.jam": {
		source: "iana",
		extensions: ["jam"]
	},
	"application/vnd.japannet-directory-service": {
		source: "iana"
	},
	"application/vnd.japannet-jpnstore-wakeup": {
		source: "iana"
	},
	"application/vnd.japannet-payment-wakeup": {
		source: "iana"
	},
	"application/vnd.japannet-registration": {
		source: "iana"
	},
	"application/vnd.japannet-registration-wakeup": {
		source: "iana"
	},
	"application/vnd.japannet-setstore-wakeup": {
		source: "iana"
	},
	"application/vnd.japannet-verification": {
		source: "iana"
	},
	"application/vnd.japannet-verification-wakeup": {
		source: "iana"
	},
	"application/vnd.jcp.javame.midlet-rms": {
		source: "iana",
		extensions: ["rms"]
	},
	"application/vnd.jisp": {
		source: "iana",
		extensions: ["jisp"]
	},
	"application/vnd.joost.joda-archive": {
		source: "iana",
		extensions: ["joda"]
	},
	"application/vnd.jsk.isdn-ngn": {
		source: "iana"
	},
	"application/vnd.kahootz": {
		source: "iana",
		extensions: ["ktz", "ktr"]
	},
	"application/vnd.kde.karbon": {
		source: "iana",
		extensions: ["karbon"]
	},
	"application/vnd.kde.kchart": {
		source: "iana",
		extensions: ["chrt"]
	},
	"application/vnd.kde.kformula": {
		source: "iana",
		extensions: ["kfo"]
	},
	"application/vnd.kde.kivio": {
		source: "iana",
		extensions: ["flw"]
	},
	"application/vnd.kde.kontour": {
		source: "iana",
		extensions: ["kon"]
	},
	"application/vnd.kde.kpresenter": {
		source: "iana",
		extensions: ["kpr", "kpt"]
	},
	"application/vnd.kde.kspread": {
		source: "iana",
		extensions: ["ksp"]
	},
	"application/vnd.kde.kword": {
		source: "iana",
		extensions: ["kwd", "kwt"]
	},
	"application/vnd.kenameaapp": {
		source: "iana",
		extensions: ["htke"]
	},
	"application/vnd.kidspiration": {
		source: "iana",
		extensions: ["kia"]
	},
	"application/vnd.kinar": {
		source: "iana",
		extensions: ["kne", "knp"]
	},
	"application/vnd.koan": {
		source: "iana",
		extensions: ["skp", "skd", "skt", "skm"]
	},
	"application/vnd.kodak-descriptor": {
		source: "iana",
		extensions: ["sse"]
	},
	"application/vnd.las.las+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.las.las+xml": {
		source: "iana",
		extensions: ["lasxml"]
	},
	"application/vnd.liberty-request+xml": {
		source: "iana"
	},
	"application/vnd.llamagraphics.life-balance.desktop": {
		source: "iana",
		extensions: ["lbd"]
	},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
		source: "iana",
		extensions: ["lbe"]
	},
	"application/vnd.lotus-1-2-3": {
		source: "iana",
		extensions: ["123"]
	},
	"application/vnd.lotus-approach": {
		source: "iana",
		extensions: ["apr"]
	},
	"application/vnd.lotus-freelance": {
		source: "iana",
		extensions: ["pre"]
	},
	"application/vnd.lotus-notes": {
		source: "iana",
		extensions: ["nsf"]
	},
	"application/vnd.lotus-organizer": {
		source: "iana",
		extensions: ["org"]
	},
	"application/vnd.lotus-screencam": {
		source: "iana",
		extensions: ["scm"]
	},
	"application/vnd.lotus-wordpro": {
		source: "iana",
		extensions: ["lwp"]
	},
	"application/vnd.macports.portpkg": {
		source: "iana",
		extensions: ["portpkg"]
	},
	"application/vnd.mapbox-vector-tile": {
		source: "iana"
	},
	"application/vnd.marlin.drm.actiontoken+xml": {
		source: "iana"
	},
	"application/vnd.marlin.drm.conftoken+xml": {
		source: "iana"
	},
	"application/vnd.marlin.drm.license+xml": {
		source: "iana"
	},
	"application/vnd.marlin.drm.mdcf": {
		source: "iana"
	},
	"application/vnd.mason+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.maxmind.maxmind-db": {
		source: "iana"
	},
	"application/vnd.mcd": {
		source: "iana",
		extensions: ["mcd"]
	},
	"application/vnd.medcalcdata": {
		source: "iana",
		extensions: ["mc1"]
	},
	"application/vnd.mediastation.cdkey": {
		source: "iana",
		extensions: ["cdkey"]
	},
	"application/vnd.meridian-slingshot": {
		source: "iana"
	},
	"application/vnd.mfer": {
		source: "iana",
		extensions: ["mwf"]
	},
	"application/vnd.mfmp": {
		source: "iana",
		extensions: ["mfm"]
	},
	"application/vnd.micro+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.micrografx.flo": {
		source: "iana",
		extensions: ["flo"]
	},
	"application/vnd.micrografx.igx": {
		source: "iana",
		extensions: ["igx"]
	},
	"application/vnd.microsoft.portable-executable": {
		source: "iana"
	},
	"application/vnd.microsoft.windows.thumbnail-cache": {
		source: "iana"
	},
	"application/vnd.miele+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.mif": {
		source: "iana",
		extensions: ["mif"]
	},
	"application/vnd.minisoft-hp3000-save": {
		source: "iana"
	},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
		source: "iana"
	},
	"application/vnd.mobius.daf": {
		source: "iana",
		extensions: ["daf"]
	},
	"application/vnd.mobius.dis": {
		source: "iana",
		extensions: ["dis"]
	},
	"application/vnd.mobius.mbk": {
		source: "iana",
		extensions: ["mbk"]
	},
	"application/vnd.mobius.mqy": {
		source: "iana",
		extensions: ["mqy"]
	},
	"application/vnd.mobius.msl": {
		source: "iana",
		extensions: ["msl"]
	},
	"application/vnd.mobius.plc": {
		source: "iana",
		extensions: ["plc"]
	},
	"application/vnd.mobius.txf": {
		source: "iana",
		extensions: ["txf"]
	},
	"application/vnd.mophun.application": {
		source: "iana",
		extensions: ["mpn"]
	},
	"application/vnd.mophun.certificate": {
		source: "iana",
		extensions: ["mpc"]
	},
	"application/vnd.motorola.flexsuite": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.adsi": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.fis": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.gotap": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.kmr": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.ttc": {
		source: "iana"
	},
	"application/vnd.motorola.flexsuite.wem": {
		source: "iana"
	},
	"application/vnd.motorola.iprm": {
		source: "iana"
	},
	"application/vnd.mozilla.xul+xml": {
		source: "iana",
		compressible: true,
		extensions: ["xul"]
	},
	"application/vnd.ms-3mfdocument": {
		source: "iana"
	},
	"application/vnd.ms-artgalry": {
		source: "iana",
		extensions: ["cil"]
	},
	"application/vnd.ms-asf": {
		source: "iana"
	},
	"application/vnd.ms-cab-compressed": {
		source: "iana",
		extensions: ["cab"]
	},
	"application/vnd.ms-color.iccprofile": {
		source: "apache"
	},
	"application/vnd.ms-excel": {
		source: "iana",
		compressible: false,
		extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
	},
	"application/vnd.ms-excel.addin.macroenabled.12": {
		source: "iana",
		extensions: ["xlam"]
	},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
		source: "iana",
		extensions: ["xlsb"]
	},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
		source: "iana",
		extensions: ["xlsm"]
	},
	"application/vnd.ms-excel.template.macroenabled.12": {
		source: "iana",
		extensions: ["xltm"]
	},
	"application/vnd.ms-fontobject": {
		source: "iana",
		compressible: true,
		extensions: ["eot"]
	},
	"application/vnd.ms-htmlhelp": {
		source: "iana",
		extensions: ["chm"]
	},
	"application/vnd.ms-ims": {
		source: "iana",
		extensions: ["ims"]
	},
	"application/vnd.ms-lrm": {
		source: "iana",
		extensions: ["lrm"]
	},
	"application/vnd.ms-office.activex+xml": {
		source: "iana"
	},
	"application/vnd.ms-officetheme": {
		source: "iana",
		extensions: ["thmx"]
	},
	"application/vnd.ms-opentype": {
		source: "apache",
		compressible: true
	},
	"application/vnd.ms-outlook": {
		compressible: false,
		extensions: ["msg"]
	},
	"application/vnd.ms-package.obfuscated-opentype": {
		source: "apache"
	},
	"application/vnd.ms-pki.seccat": {
		source: "apache",
		extensions: ["cat"]
	},
	"application/vnd.ms-pki.stl": {
		source: "apache",
		extensions: ["stl"]
	},
	"application/vnd.ms-playready.initiator+xml": {
		source: "iana"
	},
	"application/vnd.ms-powerpoint": {
		source: "iana",
		compressible: false,
		extensions: ["ppt", "pps", "pot"]
	},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
		source: "iana",
		extensions: ["ppam"]
	},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
		source: "iana",
		extensions: ["pptm"]
	},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
		source: "iana",
		extensions: ["sldm"]
	},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
		source: "iana",
		extensions: ["ppsm"]
	},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
		source: "iana",
		extensions: ["potm"]
	},
	"application/vnd.ms-printdevicecapabilities+xml": {
		source: "iana"
	},
	"application/vnd.ms-printing.printticket+xml": {
		source: "apache"
	},
	"application/vnd.ms-printschematicket+xml": {
		source: "iana"
	},
	"application/vnd.ms-project": {
		source: "iana",
		extensions: ["mpp", "mpt"]
	},
	"application/vnd.ms-tnef": {
		source: "iana"
	},
	"application/vnd.ms-windows.devicepairing": {
		source: "iana"
	},
	"application/vnd.ms-windows.nwprinting.oob": {
		source: "iana"
	},
	"application/vnd.ms-windows.printerpairing": {
		source: "iana"
	},
	"application/vnd.ms-windows.wsd.oob": {
		source: "iana"
	},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
		source: "iana"
	},
	"application/vnd.ms-wmdrm.lic-resp": {
		source: "iana"
	},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
		source: "iana"
	},
	"application/vnd.ms-wmdrm.meter-resp": {
		source: "iana"
	},
	"application/vnd.ms-word.document.macroenabled.12": {
		source: "iana",
		extensions: ["docm"]
	},
	"application/vnd.ms-word.template.macroenabled.12": {
		source: "iana",
		extensions: ["dotm"]
	},
	"application/vnd.ms-works": {
		source: "iana",
		extensions: ["wps", "wks", "wcm", "wdb"]
	},
	"application/vnd.ms-wpl": {
		source: "iana",
		extensions: ["wpl"]
	},
	"application/vnd.ms-xpsdocument": {
		source: "iana",
		compressible: false,
		extensions: ["xps"]
	},
	"application/vnd.msa-disk-image": {
		source: "iana"
	},
	"application/vnd.mseq": {
		source: "iana",
		extensions: ["mseq"]
	},
	"application/vnd.msign": {
		source: "iana"
	},
	"application/vnd.multiad.creator": {
		source: "iana"
	},
	"application/vnd.multiad.creator.cif": {
		source: "iana"
	},
	"application/vnd.music-niff": {
		source: "iana"
	},
	"application/vnd.musician": {
		source: "iana",
		extensions: ["mus"]
	},
	"application/vnd.muvee.style": {
		source: "iana",
		extensions: ["msty"]
	},
	"application/vnd.mynfc": {
		source: "iana",
		extensions: ["taglet"]
	},
	"application/vnd.ncd.control": {
		source: "iana"
	},
	"application/vnd.ncd.reference": {
		source: "iana"
	},
	"application/vnd.nearst.inv+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.nervana": {
		source: "iana"
	},
	"application/vnd.netfpx": {
		source: "iana"
	},
	"application/vnd.neurolanguage.nlu": {
		source: "iana",
		extensions: ["nlu"]
	},
	"application/vnd.nintendo.nitro.rom": {
		source: "iana"
	},
	"application/vnd.nintendo.snes.rom": {
		source: "iana"
	},
	"application/vnd.nitf": {
		source: "iana",
		extensions: ["ntf", "nitf"]
	},
	"application/vnd.noblenet-directory": {
		source: "iana",
		extensions: ["nnd"]
	},
	"application/vnd.noblenet-sealer": {
		source: "iana",
		extensions: ["nns"]
	},
	"application/vnd.noblenet-web": {
		source: "iana",
		extensions: ["nnw"]
	},
	"application/vnd.nokia.catalogs": {
		source: "iana"
	},
	"application/vnd.nokia.conml+wbxml": {
		source: "iana"
	},
	"application/vnd.nokia.conml+xml": {
		source: "iana"
	},
	"application/vnd.nokia.iptv.config+xml": {
		source: "iana"
	},
	"application/vnd.nokia.isds-radio-presets": {
		source: "iana"
	},
	"application/vnd.nokia.landmark+wbxml": {
		source: "iana"
	},
	"application/vnd.nokia.landmark+xml": {
		source: "iana"
	},
	"application/vnd.nokia.landmarkcollection+xml": {
		source: "iana"
	},
	"application/vnd.nokia.n-gage.ac+xml": {
		source: "iana"
	},
	"application/vnd.nokia.n-gage.data": {
		source: "iana",
		extensions: ["ngdat"]
	},
	"application/vnd.nokia.n-gage.symbian.install": {
		source: "iana",
		extensions: ["n-gage"]
	},
	"application/vnd.nokia.ncd": {
		source: "iana"
	},
	"application/vnd.nokia.pcd+wbxml": {
		source: "iana"
	},
	"application/vnd.nokia.pcd+xml": {
		source: "iana"
	},
	"application/vnd.nokia.radio-preset": {
		source: "iana",
		extensions: ["rpst"]
	},
	"application/vnd.nokia.radio-presets": {
		source: "iana",
		extensions: ["rpss"]
	},
	"application/vnd.novadigm.edm": {
		source: "iana",
		extensions: ["edm"]
	},
	"application/vnd.novadigm.edx": {
		source: "iana",
		extensions: ["edx"]
	},
	"application/vnd.novadigm.ext": {
		source: "iana",
		extensions: ["ext"]
	},
	"application/vnd.ntt-local.content-share": {
		source: "iana"
	},
	"application/vnd.ntt-local.file-transfer": {
		source: "iana"
	},
	"application/vnd.ntt-local.ogw_remote-access": {
		source: "iana"
	},
	"application/vnd.ntt-local.sip-ta_remote": {
		source: "iana"
	},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
		source: "iana"
	},
	"application/vnd.oasis.opendocument.chart": {
		source: "iana",
		extensions: ["odc"]
	},
	"application/vnd.oasis.opendocument.chart-template": {
		source: "iana",
		extensions: ["otc"]
	},
	"application/vnd.oasis.opendocument.database": {
		source: "iana",
		extensions: ["odb"]
	},
	"application/vnd.oasis.opendocument.formula": {
		source: "iana",
		extensions: ["odf"]
	},
	"application/vnd.oasis.opendocument.formula-template": {
		source: "iana",
		extensions: ["odft"]
	},
	"application/vnd.oasis.opendocument.graphics": {
		source: "iana",
		compressible: false,
		extensions: ["odg"]
	},
	"application/vnd.oasis.opendocument.graphics-template": {
		source: "iana",
		extensions: ["otg"]
	},
	"application/vnd.oasis.opendocument.image": {
		source: "iana",
		extensions: ["odi"]
	},
	"application/vnd.oasis.opendocument.image-template": {
		source: "iana",
		extensions: ["oti"]
	},
	"application/vnd.oasis.opendocument.presentation": {
		source: "iana",
		compressible: false,
		extensions: ["odp"]
	},
	"application/vnd.oasis.opendocument.presentation-template": {
		source: "iana",
		extensions: ["otp"]
	},
	"application/vnd.oasis.opendocument.spreadsheet": {
		source: "iana",
		compressible: false,
		extensions: ["ods"]
	},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
		source: "iana",
		extensions: ["ots"]
	},
	"application/vnd.oasis.opendocument.text": {
		source: "iana",
		compressible: false,
		extensions: ["odt"]
	},
	"application/vnd.oasis.opendocument.text-master": {
		source: "iana",
		extensions: ["odm"]
	},
	"application/vnd.oasis.opendocument.text-template": {
		source: "iana",
		extensions: ["ott"]
	},
	"application/vnd.oasis.opendocument.text-web": {
		source: "iana",
		extensions: ["oth"]
	},
	"application/vnd.obn": {
		source: "iana"
	},
	"application/vnd.ocf+cbor": {
		source: "iana"
	},
	"application/vnd.oftn.l10n+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.oipf.contentaccessdownload+xml": {
		source: "iana"
	},
	"application/vnd.oipf.contentaccessstreaming+xml": {
		source: "iana"
	},
	"application/vnd.oipf.cspg-hexbinary": {
		source: "iana"
	},
	"application/vnd.oipf.dae.svg+xml": {
		source: "iana"
	},
	"application/vnd.oipf.dae.xhtml+xml": {
		source: "iana"
	},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
		source: "iana"
	},
	"application/vnd.oipf.pae.gem": {
		source: "iana"
	},
	"application/vnd.oipf.spdiscovery+xml": {
		source: "iana"
	},
	"application/vnd.oipf.spdlist+xml": {
		source: "iana"
	},
	"application/vnd.oipf.ueprofile+xml": {
		source: "iana"
	},
	"application/vnd.oipf.userprofile+xml": {
		source: "iana"
	},
	"application/vnd.olpc-sugar": {
		source: "iana",
		extensions: ["xo"]
	},
	"application/vnd.oma-scws-config": {
		source: "iana"
	},
	"application/vnd.oma-scws-http-request": {
		source: "iana"
	},
	"application/vnd.oma-scws-http-response": {
		source: "iana"
	},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.drm-trigger+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.imd+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.ltkm": {
		source: "iana"
	},
	"application/vnd.oma.bcast.notification+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.provisioningtrigger": {
		source: "iana"
	},
	"application/vnd.oma.bcast.sgboot": {
		source: "iana"
	},
	"application/vnd.oma.bcast.sgdd+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.sgdu": {
		source: "iana"
	},
	"application/vnd.oma.bcast.simple-symbol-container": {
		source: "iana"
	},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.sprov+xml": {
		source: "iana"
	},
	"application/vnd.oma.bcast.stkm": {
		source: "iana"
	},
	"application/vnd.oma.cab-address-book+xml": {
		source: "iana"
	},
	"application/vnd.oma.cab-feature-handler+xml": {
		source: "iana"
	},
	"application/vnd.oma.cab-pcc+xml": {
		source: "iana"
	},
	"application/vnd.oma.cab-subs-invite+xml": {
		source: "iana"
	},
	"application/vnd.oma.cab-user-prefs+xml": {
		source: "iana"
	},
	"application/vnd.oma.dcd": {
		source: "iana"
	},
	"application/vnd.oma.dcdc": {
		source: "iana"
	},
	"application/vnd.oma.dd2+xml": {
		source: "iana",
		extensions: ["dd2"]
	},
	"application/vnd.oma.drm.risd+xml": {
		source: "iana"
	},
	"application/vnd.oma.group-usage-list+xml": {
		source: "iana"
	},
	"application/vnd.oma.lwm2m+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.oma.lwm2m+tlv": {
		source: "iana"
	},
	"application/vnd.oma.pal+xml": {
		source: "iana"
	},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
		source: "iana"
	},
	"application/vnd.oma.poc.final-report+xml": {
		source: "iana"
	},
	"application/vnd.oma.poc.groups+xml": {
		source: "iana"
	},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
		source: "iana"
	},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
		source: "iana"
	},
	"application/vnd.oma.push": {
		source: "iana"
	},
	"application/vnd.oma.scidm.messages+xml": {
		source: "iana"
	},
	"application/vnd.oma.xcap-directory+xml": {
		source: "iana"
	},
	"application/vnd.omads-email+xml": {
		source: "iana"
	},
	"application/vnd.omads-file+xml": {
		source: "iana"
	},
	"application/vnd.omads-folder+xml": {
		source: "iana"
	},
	"application/vnd.omaloc-supl-init": {
		source: "iana"
	},
	"application/vnd.onepager": {
		source: "iana"
	},
	"application/vnd.onepagertamp": {
		source: "iana"
	},
	"application/vnd.onepagertamx": {
		source: "iana"
	},
	"application/vnd.onepagertat": {
		source: "iana"
	},
	"application/vnd.onepagertatp": {
		source: "iana"
	},
	"application/vnd.onepagertatx": {
		source: "iana"
	},
	"application/vnd.openblox.game+xml": {
		source: "iana"
	},
	"application/vnd.openblox.game-binary": {
		source: "iana"
	},
	"application/vnd.openeye.oeb": {
		source: "iana"
	},
	"application/vnd.openofficeorg.extension": {
		source: "apache",
		extensions: ["oxt"]
	},
	"application/vnd.openstreetmap.data+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
		source: "iana",
		compressible: false,
		extensions: ["pptx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
		source: "iana",
		extensions: ["sldx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
		source: "iana",
		extensions: ["ppsx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
		source: "iana",
		extensions: ["potx"]
	},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
		source: "iana",
		compressible: false,
		extensions: ["xlsx"]
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
		source: "iana",
		extensions: ["xltx"]
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
		source: "iana",
		compressible: false,
		extensions: ["docx"]
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
		source: "iana",
		extensions: ["dotx"]
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-package.core-properties+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
		source: "iana"
	},
	"application/vnd.openxmlformats-package.relationships+xml": {
		source: "iana"
	},
	"application/vnd.oracle.resource+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.orange.indata": {
		source: "iana"
	},
	"application/vnd.osa.netdeploy": {
		source: "iana"
	},
	"application/vnd.osgeo.mapguide.package": {
		source: "iana",
		extensions: ["mgp"]
	},
	"application/vnd.osgi.bundle": {
		source: "iana"
	},
	"application/vnd.osgi.dp": {
		source: "iana",
		extensions: ["dp"]
	},
	"application/vnd.osgi.subsystem": {
		source: "iana",
		extensions: ["esa"]
	},
	"application/vnd.otps.ct-kip+xml": {
		source: "iana"
	},
	"application/vnd.oxli.countgraph": {
		source: "iana"
	},
	"application/vnd.pagerduty+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.palm": {
		source: "iana",
		extensions: ["pdb", "pqa", "oprc"]
	},
	"application/vnd.panoply": {
		source: "iana"
	},
	"application/vnd.paos+xml": {
		source: "iana"
	},
	"application/vnd.paos.xml": {
		source: "apache"
	},
	"application/vnd.patentdive": {
		source: "iana"
	},
	"application/vnd.pawaafile": {
		source: "iana",
		extensions: ["paw"]
	},
	"application/vnd.pcos": {
		source: "iana"
	},
	"application/vnd.pg.format": {
		source: "iana",
		extensions: ["str"]
	},
	"application/vnd.pg.osasli": {
		source: "iana",
		extensions: ["ei6"]
	},
	"application/vnd.piaccess.application-licence": {
		source: "iana"
	},
	"application/vnd.picsel": {
		source: "iana",
		extensions: ["efif"]
	},
	"application/vnd.pmi.widget": {
		source: "iana",
		extensions: ["wg"]
	},
	"application/vnd.poc.group-advertisement+xml": {
		source: "iana"
	},
	"application/vnd.pocketlearn": {
		source: "iana",
		extensions: ["plf"]
	},
	"application/vnd.powerbuilder6": {
		source: "iana",
		extensions: ["pbd"]
	},
	"application/vnd.powerbuilder6-s": {
		source: "iana"
	},
	"application/vnd.powerbuilder7": {
		source: "iana"
	},
	"application/vnd.powerbuilder7-s": {
		source: "iana"
	},
	"application/vnd.powerbuilder75": {
		source: "iana"
	},
	"application/vnd.powerbuilder75-s": {
		source: "iana"
	},
	"application/vnd.preminet": {
		source: "iana"
	},
	"application/vnd.previewsystems.box": {
		source: "iana",
		extensions: ["box"]
	},
	"application/vnd.proteus.magazine": {
		source: "iana",
		extensions: ["mgz"]
	},
	"application/vnd.publishare-delta-tree": {
		source: "iana",
		extensions: ["qps"]
	},
	"application/vnd.pvi.ptid1": {
		source: "iana",
		extensions: ["ptid"]
	},
	"application/vnd.pwg-multiplexed": {
		source: "iana"
	},
	"application/vnd.pwg-xhtml-print+xml": {
		source: "iana"
	},
	"application/vnd.qualcomm.brew-app-res": {
		source: "iana"
	},
	"application/vnd.quarantainenet": {
		source: "iana"
	},
	"application/vnd.quark.quarkxpress": {
		source: "iana",
		extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
	},
	"application/vnd.quobject-quoxdocument": {
		source: "iana"
	},
	"application/vnd.radisys.moml+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-audit+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-audit-conf+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-audit-conn+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-audit-dialog+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-audit-stream+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-conf+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-base+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-group+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-speech+xml": {
		source: "iana"
	},
	"application/vnd.radisys.msml-dialog-transform+xml": {
		source: "iana"
	},
	"application/vnd.rainstor.data": {
		source: "iana"
	},
	"application/vnd.rapid": {
		source: "iana"
	},
	"application/vnd.rar": {
		source: "iana"
	},
	"application/vnd.realvnc.bed": {
		source: "iana",
		extensions: ["bed"]
	},
	"application/vnd.recordare.musicxml": {
		source: "iana",
		extensions: ["mxl"]
	},
	"application/vnd.recordare.musicxml+xml": {
		source: "iana",
		extensions: ["musicxml"]
	},
	"application/vnd.renlearn.rlprint": {
		source: "iana"
	},
	"application/vnd.restful+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.rig.cryptonote": {
		source: "iana",
		extensions: ["cryptonote"]
	},
	"application/vnd.rim.cod": {
		source: "apache",
		extensions: ["cod"]
	},
	"application/vnd.rn-realmedia": {
		source: "apache",
		extensions: ["rm"]
	},
	"application/vnd.rn-realmedia-vbr": {
		source: "apache",
		extensions: ["rmvb"]
	},
	"application/vnd.route66.link66+xml": {
		source: "iana",
		extensions: ["link66"]
	},
	"application/vnd.rs-274x": {
		source: "iana"
	},
	"application/vnd.ruckus.download": {
		source: "iana"
	},
	"application/vnd.s3sms": {
		source: "iana"
	},
	"application/vnd.sailingtracker.track": {
		source: "iana",
		extensions: ["st"]
	},
	"application/vnd.sbm.cid": {
		source: "iana"
	},
	"application/vnd.sbm.mid2": {
		source: "iana"
	},
	"application/vnd.scribus": {
		source: "iana"
	},
	"application/vnd.sealed.3df": {
		source: "iana"
	},
	"application/vnd.sealed.csf": {
		source: "iana"
	},
	"application/vnd.sealed.doc": {
		source: "iana"
	},
	"application/vnd.sealed.eml": {
		source: "iana"
	},
	"application/vnd.sealed.mht": {
		source: "iana"
	},
	"application/vnd.sealed.net": {
		source: "iana"
	},
	"application/vnd.sealed.ppt": {
		source: "iana"
	},
	"application/vnd.sealed.tiff": {
		source: "iana"
	},
	"application/vnd.sealed.xls": {
		source: "iana"
	},
	"application/vnd.sealedmedia.softseal.html": {
		source: "iana"
	},
	"application/vnd.sealedmedia.softseal.pdf": {
		source: "iana"
	},
	"application/vnd.seemail": {
		source: "iana",
		extensions: ["see"]
	},
	"application/vnd.sema": {
		source: "iana",
		extensions: ["sema"]
	},
	"application/vnd.semd": {
		source: "iana",
		extensions: ["semd"]
	},
	"application/vnd.semf": {
		source: "iana",
		extensions: ["semf"]
	},
	"application/vnd.shana.informed.formdata": {
		source: "iana",
		extensions: ["ifm"]
	},
	"application/vnd.shana.informed.formtemplate": {
		source: "iana",
		extensions: ["itp"]
	},
	"application/vnd.shana.informed.interchange": {
		source: "iana",
		extensions: ["iif"]
	},
	"application/vnd.shana.informed.package": {
		source: "iana",
		extensions: ["ipk"]
	},
	"application/vnd.sigrok.session": {
		source: "iana"
	},
	"application/vnd.simtech-mindmapper": {
		source: "iana",
		extensions: ["twd", "twds"]
	},
	"application/vnd.siren+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.smaf": {
		source: "iana",
		extensions: ["mmf"]
	},
	"application/vnd.smart.notebook": {
		source: "iana"
	},
	"application/vnd.smart.teacher": {
		source: "iana",
		extensions: ["teacher"]
	},
	"application/vnd.software602.filler.form+xml": {
		source: "iana"
	},
	"application/vnd.software602.filler.form-xml-zip": {
		source: "iana"
	},
	"application/vnd.solent.sdkm+xml": {
		source: "iana",
		extensions: ["sdkm", "sdkd"]
	},
	"application/vnd.spotfire.dxp": {
		source: "iana",
		extensions: ["dxp"]
	},
	"application/vnd.spotfire.sfs": {
		source: "iana",
		extensions: ["sfs"]
	},
	"application/vnd.sqlite3": {
		source: "iana"
	},
	"application/vnd.sss-cod": {
		source: "iana"
	},
	"application/vnd.sss-dtf": {
		source: "iana"
	},
	"application/vnd.sss-ntf": {
		source: "iana"
	},
	"application/vnd.stardivision.calc": {
		source: "apache",
		extensions: ["sdc"]
	},
	"application/vnd.stardivision.draw": {
		source: "apache",
		extensions: ["sda"]
	},
	"application/vnd.stardivision.impress": {
		source: "apache",
		extensions: ["sdd"]
	},
	"application/vnd.stardivision.math": {
		source: "apache",
		extensions: ["smf"]
	},
	"application/vnd.stardivision.writer": {
		source: "apache",
		extensions: ["sdw", "vor"]
	},
	"application/vnd.stardivision.writer-global": {
		source: "apache",
		extensions: ["sgl"]
	},
	"application/vnd.stepmania.package": {
		source: "iana",
		extensions: ["smzip"]
	},
	"application/vnd.stepmania.stepchart": {
		source: "iana",
		extensions: ["sm"]
	},
	"application/vnd.street-stream": {
		source: "iana"
	},
	"application/vnd.sun.wadl+xml": {
		source: "iana",
		compressible: true,
		extensions: ["wadl"]
	},
	"application/vnd.sun.xml.calc": {
		source: "apache",
		extensions: ["sxc"]
	},
	"application/vnd.sun.xml.calc.template": {
		source: "apache",
		extensions: ["stc"]
	},
	"application/vnd.sun.xml.draw": {
		source: "apache",
		extensions: ["sxd"]
	},
	"application/vnd.sun.xml.draw.template": {
		source: "apache",
		extensions: ["std"]
	},
	"application/vnd.sun.xml.impress": {
		source: "apache",
		extensions: ["sxi"]
	},
	"application/vnd.sun.xml.impress.template": {
		source: "apache",
		extensions: ["sti"]
	},
	"application/vnd.sun.xml.math": {
		source: "apache",
		extensions: ["sxm"]
	},
	"application/vnd.sun.xml.writer": {
		source: "apache",
		extensions: ["sxw"]
	},
	"application/vnd.sun.xml.writer.global": {
		source: "apache",
		extensions: ["sxg"]
	},
	"application/vnd.sun.xml.writer.template": {
		source: "apache",
		extensions: ["stw"]
	},
	"application/vnd.sus-calendar": {
		source: "iana",
		extensions: ["sus", "susp"]
	},
	"application/vnd.svd": {
		source: "iana",
		extensions: ["svd"]
	},
	"application/vnd.swiftview-ics": {
		source: "iana"
	},
	"application/vnd.symbian.install": {
		source: "apache",
		extensions: ["sis", "sisx"]
	},
	"application/vnd.syncml+xml": {
		source: "iana",
		extensions: ["xsm"]
	},
	"application/vnd.syncml.dm+wbxml": {
		source: "iana",
		extensions: ["bdm"]
	},
	"application/vnd.syncml.dm+xml": {
		source: "iana",
		extensions: ["xdm"]
	},
	"application/vnd.syncml.dm.notification": {
		source: "iana"
	},
	"application/vnd.syncml.dmddf+wbxml": {
		source: "iana"
	},
	"application/vnd.syncml.dmddf+xml": {
		source: "iana"
	},
	"application/vnd.syncml.dmtnds+wbxml": {
		source: "iana"
	},
	"application/vnd.syncml.dmtnds+xml": {
		source: "iana"
	},
	"application/vnd.syncml.ds.notification": {
		source: "iana"
	},
	"application/vnd.tableschema+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.tao.intent-module-archive": {
		source: "iana",
		extensions: ["tao"]
	},
	"application/vnd.tcpdump.pcap": {
		source: "iana",
		extensions: ["pcap", "cap", "dmp"]
	},
	"application/vnd.tmd.mediaflex.api+xml": {
		source: "iana"
	},
	"application/vnd.tml": {
		source: "iana"
	},
	"application/vnd.tmobile-livetv": {
		source: "iana",
		extensions: ["tmo"]
	},
	"application/vnd.tri.onesource": {
		source: "iana"
	},
	"application/vnd.trid.tpt": {
		source: "iana",
		extensions: ["tpt"]
	},
	"application/vnd.triscape.mxs": {
		source: "iana",
		extensions: ["mxs"]
	},
	"application/vnd.trueapp": {
		source: "iana",
		extensions: ["tra"]
	},
	"application/vnd.truedoc": {
		source: "iana"
	},
	"application/vnd.ubisoft.webplayer": {
		source: "iana"
	},
	"application/vnd.ufdl": {
		source: "iana",
		extensions: ["ufd", "ufdl"]
	},
	"application/vnd.uiq.theme": {
		source: "iana",
		extensions: ["utz"]
	},
	"application/vnd.umajin": {
		source: "iana",
		extensions: ["umj"]
	},
	"application/vnd.unity": {
		source: "iana",
		extensions: ["unityweb"]
	},
	"application/vnd.uoml+xml": {
		source: "iana",
		extensions: ["uoml"]
	},
	"application/vnd.uplanet.alert": {
		source: "iana"
	},
	"application/vnd.uplanet.alert-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.bearer-choice": {
		source: "iana"
	},
	"application/vnd.uplanet.bearer-choice-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.cacheop": {
		source: "iana"
	},
	"application/vnd.uplanet.cacheop-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.channel": {
		source: "iana"
	},
	"application/vnd.uplanet.channel-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.list": {
		source: "iana"
	},
	"application/vnd.uplanet.list-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.listcmd": {
		source: "iana"
	},
	"application/vnd.uplanet.listcmd-wbxml": {
		source: "iana"
	},
	"application/vnd.uplanet.signal": {
		source: "iana"
	},
	"application/vnd.uri-map": {
		source: "iana"
	},
	"application/vnd.valve.source.material": {
		source: "iana"
	},
	"application/vnd.vcx": {
		source: "iana",
		extensions: ["vcx"]
	},
	"application/vnd.vd-study": {
		source: "iana"
	},
	"application/vnd.vectorworks": {
		source: "iana"
	},
	"application/vnd.vel+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.verimatrix.vcas": {
		source: "iana"
	},
	"application/vnd.vidsoft.vidconference": {
		source: "iana"
	},
	"application/vnd.visio": {
		source: "iana",
		extensions: ["vsd", "vst", "vss", "vsw"]
	},
	"application/vnd.visionary": {
		source: "iana",
		extensions: ["vis"]
	},
	"application/vnd.vividence.scriptfile": {
		source: "iana"
	},
	"application/vnd.vsf": {
		source: "iana",
		extensions: ["vsf"]
	},
	"application/vnd.wap.sic": {
		source: "iana"
	},
	"application/vnd.wap.slc": {
		source: "iana"
	},
	"application/vnd.wap.wbxml": {
		source: "iana",
		extensions: ["wbxml"]
	},
	"application/vnd.wap.wmlc": {
		source: "iana",
		extensions: ["wmlc"]
	},
	"application/vnd.wap.wmlscriptc": {
		source: "iana",
		extensions: ["wmlsc"]
	},
	"application/vnd.webturbo": {
		source: "iana",
		extensions: ["wtb"]
	},
	"application/vnd.wfa.p2p": {
		source: "iana"
	},
	"application/vnd.wfa.wsc": {
		source: "iana"
	},
	"application/vnd.windows.devicepairing": {
		source: "iana"
	},
	"application/vnd.wmc": {
		source: "iana"
	},
	"application/vnd.wmf.bootstrap": {
		source: "iana"
	},
	"application/vnd.wolfram.mathematica": {
		source: "iana"
	},
	"application/vnd.wolfram.mathematica.package": {
		source: "iana"
	},
	"application/vnd.wolfram.player": {
		source: "iana",
		extensions: ["nbp"]
	},
	"application/vnd.wordperfect": {
		source: "iana",
		extensions: ["wpd"]
	},
	"application/vnd.wqd": {
		source: "iana",
		extensions: ["wqd"]
	},
	"application/vnd.wrq-hp3000-labelled": {
		source: "iana"
	},
	"application/vnd.wt.stf": {
		source: "iana",
		extensions: ["stf"]
	},
	"application/vnd.wv.csp+wbxml": {
		source: "iana"
	},
	"application/vnd.wv.csp+xml": {
		source: "iana"
	},
	"application/vnd.wv.ssp+xml": {
		source: "iana"
	},
	"application/vnd.xacml+json": {
		source: "iana",
		compressible: true
	},
	"application/vnd.xara": {
		source: "iana",
		extensions: ["xar"]
	},
	"application/vnd.xfdl": {
		source: "iana",
		extensions: ["xfdl"]
	},
	"application/vnd.xfdl.webform": {
		source: "iana"
	},
	"application/vnd.xmi+xml": {
		source: "iana"
	},
	"application/vnd.xmpie.cpkg": {
		source: "iana"
	},
	"application/vnd.xmpie.dpkg": {
		source: "iana"
	},
	"application/vnd.xmpie.plan": {
		source: "iana"
	},
	"application/vnd.xmpie.ppkg": {
		source: "iana"
	},
	"application/vnd.xmpie.xlim": {
		source: "iana"
	},
	"application/vnd.yamaha.hv-dic": {
		source: "iana",
		extensions: ["hvd"]
	},
	"application/vnd.yamaha.hv-script": {
		source: "iana",
		extensions: ["hvs"]
	},
	"application/vnd.yamaha.hv-voice": {
		source: "iana",
		extensions: ["hvp"]
	},
	"application/vnd.yamaha.openscoreformat": {
		source: "iana",
		extensions: ["osf"]
	},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
		source: "iana",
		extensions: ["osfpvg"]
	},
	"application/vnd.yamaha.remote-setup": {
		source: "iana"
	},
	"application/vnd.yamaha.smaf-audio": {
		source: "iana",
		extensions: ["saf"]
	},
	"application/vnd.yamaha.smaf-phrase": {
		source: "iana",
		extensions: ["spf"]
	},
	"application/vnd.yamaha.through-ngn": {
		source: "iana"
	},
	"application/vnd.yamaha.tunnel-udpencap": {
		source: "iana"
	},
	"application/vnd.yaoweme": {
		source: "iana"
	},
	"application/vnd.yellowriver-custom-menu": {
		source: "iana",
		extensions: ["cmp"]
	},
	"application/vnd.youtube.yt": {
		source: "iana"
	},
	"application/vnd.zul": {
		source: "iana",
		extensions: ["zir", "zirz"]
	},
	"application/vnd.zzazz.deck+xml": {
		source: "iana",
		extensions: ["zaz"]
	},
	"application/voicexml+xml": {
		source: "iana",
		extensions: ["vxml"]
	},
	"application/voucher-cms+json": {
		source: "iana",
		compressible: true
	},
	"application/vq-rtcpxr": {
		source: "iana"
	},
	"application/wasm": {
		compressible: true,
		extensions: ["wasm"]
	},
	"application/watcherinfo+xml": {
		source: "iana"
	},
	"application/webpush-options+json": {
		source: "iana",
		compressible: true
	},
	"application/whoispp-query": {
		source: "iana"
	},
	"application/whoispp-response": {
		source: "iana"
	},
	"application/widget": {
		source: "iana",
		extensions: ["wgt"]
	},
	"application/winhlp": {
		source: "apache",
		extensions: ["hlp"]
	},
	"application/wita": {
		source: "iana"
	},
	"application/wordperfect5.1": {
		source: "iana"
	},
	"application/wsdl+xml": {
		source: "iana",
		extensions: ["wsdl"]
	},
	"application/wspolicy+xml": {
		source: "iana",
		extensions: ["wspolicy"]
	},
	"application/x-7z-compressed": {
		source: "apache",
		compressible: false,
		extensions: ["7z"]
	},
	"application/x-abiword": {
		source: "apache",
		extensions: ["abw"]
	},
	"application/x-ace-compressed": {
		source: "apache",
		extensions: ["ace"]
	},
	"application/x-amf": {
		source: "apache"
	},
	"application/x-apple-diskimage": {
		source: "apache",
		extensions: ["dmg"]
	},
	"application/x-arj": {
		compressible: false,
		extensions: ["arj"]
	},
	"application/x-authorware-bin": {
		source: "apache",
		extensions: ["aab", "x32", "u32", "vox"]
	},
	"application/x-authorware-map": {
		source: "apache",
		extensions: ["aam"]
	},
	"application/x-authorware-seg": {
		source: "apache",
		extensions: ["aas"]
	},
	"application/x-bcpio": {
		source: "apache",
		extensions: ["bcpio"]
	},
	"application/x-bdoc": {
		compressible: false,
		extensions: ["bdoc"]
	},
	"application/x-bittorrent": {
		source: "apache",
		extensions: ["torrent"]
	},
	"application/x-blorb": {
		source: "apache",
		extensions: ["blb", "blorb"]
	},
	"application/x-bzip": {
		source: "apache",
		compressible: false,
		extensions: ["bz"]
	},
	"application/x-bzip2": {
		source: "apache",
		compressible: false,
		extensions: ["bz2", "boz"]
	},
	"application/x-cbr": {
		source: "apache",
		extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
	},
	"application/x-cdlink": {
		source: "apache",
		extensions: ["vcd"]
	},
	"application/x-cfs-compressed": {
		source: "apache",
		extensions: ["cfs"]
	},
	"application/x-chat": {
		source: "apache",
		extensions: ["chat"]
	},
	"application/x-chess-pgn": {
		source: "apache",
		extensions: ["pgn"]
	},
	"application/x-chrome-extension": {
		extensions: ["crx"]
	},
	"application/x-cocoa": {
		source: "nginx",
		extensions: ["cco"]
	},
	"application/x-compress": {
		source: "apache"
	},
	"application/x-conference": {
		source: "apache",
		extensions: ["nsc"]
	},
	"application/x-cpio": {
		source: "apache",
		extensions: ["cpio"]
	},
	"application/x-csh": {
		source: "apache",
		extensions: ["csh"]
	},
	"application/x-deb": {
		compressible: false
	},
	"application/x-debian-package": {
		source: "apache",
		extensions: ["deb", "udeb"]
	},
	"application/x-dgc-compressed": {
		source: "apache",
		extensions: ["dgc"]
	},
	"application/x-director": {
		source: "apache",
		extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
	},
	"application/x-doom": {
		source: "apache",
		extensions: ["wad"]
	},
	"application/x-dtbncx+xml": {
		source: "apache",
		extensions: ["ncx"]
	},
	"application/x-dtbook+xml": {
		source: "apache",
		extensions: ["dtb"]
	},
	"application/x-dtbresource+xml": {
		source: "apache",
		extensions: ["res"]
	},
	"application/x-dvi": {
		source: "apache",
		compressible: false,
		extensions: ["dvi"]
	},
	"application/x-envoy": {
		source: "apache",
		extensions: ["evy"]
	},
	"application/x-eva": {
		source: "apache",
		extensions: ["eva"]
	},
	"application/x-font-bdf": {
		source: "apache",
		extensions: ["bdf"]
	},
	"application/x-font-dos": {
		source: "apache"
	},
	"application/x-font-framemaker": {
		source: "apache"
	},
	"application/x-font-ghostscript": {
		source: "apache",
		extensions: ["gsf"]
	},
	"application/x-font-libgrx": {
		source: "apache"
	},
	"application/x-font-linux-psf": {
		source: "apache",
		extensions: ["psf"]
	},
	"application/x-font-pcf": {
		source: "apache",
		extensions: ["pcf"]
	},
	"application/x-font-snf": {
		source: "apache",
		extensions: ["snf"]
	},
	"application/x-font-speedo": {
		source: "apache"
	},
	"application/x-font-sunos-news": {
		source: "apache"
	},
	"application/x-font-type1": {
		source: "apache",
		extensions: ["pfa", "pfb", "pfm", "afm"]
	},
	"application/x-font-vfont": {
		source: "apache"
	},
	"application/x-freearc": {
		source: "apache",
		extensions: ["arc"]
	},
	"application/x-futuresplash": {
		source: "apache",
		extensions: ["spl"]
	},
	"application/x-gca-compressed": {
		source: "apache",
		extensions: ["gca"]
	},
	"application/x-glulx": {
		source: "apache",
		extensions: ["ulx"]
	},
	"application/x-gnumeric": {
		source: "apache",
		extensions: ["gnumeric"]
	},
	"application/x-gramps-xml": {
		source: "apache",
		extensions: ["gramps"]
	},
	"application/x-gtar": {
		source: "apache",
		extensions: ["gtar"]
	},
	"application/x-gzip": {
		source: "apache"
	},
	"application/x-hdf": {
		source: "apache",
		extensions: ["hdf"]
	},
	"application/x-httpd-php": {
		compressible: true,
		extensions: ["php"]
	},
	"application/x-install-instructions": {
		source: "apache",
		extensions: ["install"]
	},
	"application/x-iso9660-image": {
		source: "apache",
		extensions: ["iso"]
	},
	"application/x-java-archive-diff": {
		source: "nginx",
		extensions: ["jardiff"]
	},
	"application/x-java-jnlp-file": {
		source: "apache",
		compressible: false,
		extensions: ["jnlp"]
	},
	"application/x-javascript": {
		compressible: true
	},
	"application/x-latex": {
		source: "apache",
		compressible: false,
		extensions: ["latex"]
	},
	"application/x-lua-bytecode": {
		extensions: ["luac"]
	},
	"application/x-lzh-compressed": {
		source: "apache",
		extensions: ["lzh", "lha"]
	},
	"application/x-makeself": {
		source: "nginx",
		extensions: ["run"]
	},
	"application/x-mie": {
		source: "apache",
		extensions: ["mie"]
	},
	"application/x-mobipocket-ebook": {
		source: "apache",
		extensions: ["prc", "mobi"]
	},
	"application/x-mpegurl": {
		compressible: false
	},
	"application/x-ms-application": {
		source: "apache",
		extensions: ["application"]
	},
	"application/x-ms-shortcut": {
		source: "apache",
		extensions: ["lnk"]
	},
	"application/x-ms-wmd": {
		source: "apache",
		extensions: ["wmd"]
	},
	"application/x-ms-wmz": {
		source: "apache",
		extensions: ["wmz"]
	},
	"application/x-ms-xbap": {
		source: "apache",
		extensions: ["xbap"]
	},
	"application/x-msaccess": {
		source: "apache",
		extensions: ["mdb"]
	},
	"application/x-msbinder": {
		source: "apache",
		extensions: ["obd"]
	},
	"application/x-mscardfile": {
		source: "apache",
		extensions: ["crd"]
	},
	"application/x-msclip": {
		source: "apache",
		extensions: ["clp"]
	},
	"application/x-msdos-program": {
		extensions: ["exe"]
	},
	"application/x-msdownload": {
		source: "apache",
		extensions: ["exe", "dll", "com", "bat", "msi"]
	},
	"application/x-msmediaview": {
		source: "apache",
		extensions: ["mvb", "m13", "m14"]
	},
	"application/x-msmetafile": {
		source: "apache",
		extensions: ["wmf", "wmz", "emf", "emz"]
	},
	"application/x-msmoney": {
		source: "apache",
		extensions: ["mny"]
	},
	"application/x-mspublisher": {
		source: "apache",
		extensions: ["pub"]
	},
	"application/x-msschedule": {
		source: "apache",
		extensions: ["scd"]
	},
	"application/x-msterminal": {
		source: "apache",
		extensions: ["trm"]
	},
	"application/x-mswrite": {
		source: "apache",
		extensions: ["wri"]
	},
	"application/x-netcdf": {
		source: "apache",
		extensions: ["nc", "cdf"]
	},
	"application/x-ns-proxy-autoconfig": {
		compressible: true,
		extensions: ["pac"]
	},
	"application/x-nzb": {
		source: "apache",
		extensions: ["nzb"]
	},
	"application/x-perl": {
		source: "nginx",
		extensions: ["pl", "pm"]
	},
	"application/x-pilot": {
		source: "nginx",
		extensions: ["prc", "pdb"]
	},
	"application/x-pkcs12": {
		source: "apache",
		compressible: false,
		extensions: ["p12", "pfx"]
	},
	"application/x-pkcs7-certificates": {
		source: "apache",
		extensions: ["p7b", "spc"]
	},
	"application/x-pkcs7-certreqresp": {
		source: "apache",
		extensions: ["p7r"]
	},
	"application/x-rar-compressed": {
		source: "apache",
		compressible: false,
		extensions: ["rar"]
	},
	"application/x-redhat-package-manager": {
		source: "nginx",
		extensions: ["rpm"]
	},
	"application/x-research-info-systems": {
		source: "apache",
		extensions: ["ris"]
	},
	"application/x-sea": {
		source: "nginx",
		extensions: ["sea"]
	},
	"application/x-sh": {
		source: "apache",
		compressible: true,
		extensions: ["sh"]
	},
	"application/x-shar": {
		source: "apache",
		extensions: ["shar"]
	},
	"application/x-shockwave-flash": {
		source: "apache",
		compressible: false,
		extensions: ["swf"]
	},
	"application/x-silverlight-app": {
		source: "apache",
		extensions: ["xap"]
	},
	"application/x-sql": {
		source: "apache",
		extensions: ["sql"]
	},
	"application/x-stuffit": {
		source: "apache",
		compressible: false,
		extensions: ["sit"]
	},
	"application/x-stuffitx": {
		source: "apache",
		extensions: ["sitx"]
	},
	"application/x-subrip": {
		source: "apache",
		extensions: ["srt"]
	},
	"application/x-sv4cpio": {
		source: "apache",
		extensions: ["sv4cpio"]
	},
	"application/x-sv4crc": {
		source: "apache",
		extensions: ["sv4crc"]
	},
	"application/x-t3vm-image": {
		source: "apache",
		extensions: ["t3"]
	},
	"application/x-tads": {
		source: "apache",
		extensions: ["gam"]
	},
	"application/x-tar": {
		source: "apache",
		compressible: true,
		extensions: ["tar"]
	},
	"application/x-tcl": {
		source: "apache",
		extensions: ["tcl", "tk"]
	},
	"application/x-tex": {
		source: "apache",
		extensions: ["tex"]
	},
	"application/x-tex-tfm": {
		source: "apache",
		extensions: ["tfm"]
	},
	"application/x-texinfo": {
		source: "apache",
		extensions: ["texinfo", "texi"]
	},
	"application/x-tgif": {
		source: "apache",
		extensions: ["obj"]
	},
	"application/x-ustar": {
		source: "apache",
		extensions: ["ustar"]
	},
	"application/x-virtualbox-hdd": {
		compressible: true,
		extensions: ["hdd"]
	},
	"application/x-virtualbox-ova": {
		compressible: true,
		extensions: ["ova"]
	},
	"application/x-virtualbox-ovf": {
		compressible: true,
		extensions: ["ovf"]
	},
	"application/x-virtualbox-vbox": {
		compressible: true,
		extensions: ["vbox"]
	},
	"application/x-virtualbox-vbox-extpack": {
		compressible: false,
		extensions: ["vbox-extpack"]
	},
	"application/x-virtualbox-vdi": {
		compressible: true,
		extensions: ["vdi"]
	},
	"application/x-virtualbox-vhd": {
		compressible: true,
		extensions: ["vhd"]
	},
	"application/x-virtualbox-vmdk": {
		compressible: true,
		extensions: ["vmdk"]
	},
	"application/x-wais-source": {
		source: "apache",
		extensions: ["src"]
	},
	"application/x-web-app-manifest+json": {
		compressible: true,
		extensions: ["webapp"]
	},
	"application/x-www-form-urlencoded": {
		source: "iana",
		compressible: true
	},
	"application/x-x509-ca-cert": {
		source: "apache",
		extensions: ["der", "crt", "pem"]
	},
	"application/x-xfig": {
		source: "apache",
		extensions: ["fig"]
	},
	"application/x-xliff+xml": {
		source: "apache",
		extensions: ["xlf"]
	},
	"application/x-xpinstall": {
		source: "apache",
		compressible: false,
		extensions: ["xpi"]
	},
	"application/x-xz": {
		source: "apache",
		extensions: ["xz"]
	},
	"application/x-zmachine": {
		source: "apache",
		extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
	},
	"application/x400-bp": {
		source: "iana"
	},
	"application/xacml+xml": {
		source: "iana"
	},
	"application/xaml+xml": {
		source: "apache",
		extensions: ["xaml"]
	},
	"application/xcap-att+xml": {
		source: "iana"
	},
	"application/xcap-caps+xml": {
		source: "iana"
	},
	"application/xcap-diff+xml": {
		source: "iana",
		extensions: ["xdf"]
	},
	"application/xcap-el+xml": {
		source: "iana"
	},
	"application/xcap-error+xml": {
		source: "iana"
	},
	"application/xcap-ns+xml": {
		source: "iana"
	},
	"application/xcon-conference-info+xml": {
		source: "iana"
	},
	"application/xcon-conference-info-diff+xml": {
		source: "iana"
	},
	"application/xenc+xml": {
		source: "iana",
		extensions: ["xenc"]
	},
	"application/xhtml+xml": {
		source: "iana",
		compressible: true,
		extensions: ["xhtml", "xht"]
	},
	"application/xhtml-voice+xml": {
		source: "apache"
	},
	"application/xml": {
		source: "iana",
		compressible: true,
		extensions: ["xml", "xsl", "xsd", "rng"]
	},
	"application/xml-dtd": {
		source: "iana",
		compressible: true,
		extensions: ["dtd"]
	},
	"application/xml-external-parsed-entity": {
		source: "iana"
	},
	"application/xml-patch+xml": {
		source: "iana"
	},
	"application/xmpp+xml": {
		source: "iana"
	},
	"application/xop+xml": {
		source: "iana",
		compressible: true,
		extensions: ["xop"]
	},
	"application/xproc+xml": {
		source: "apache",
		extensions: ["xpl"]
	},
	"application/xslt+xml": {
		source: "iana",
		extensions: ["xslt"]
	},
	"application/xspf+xml": {
		source: "apache",
		extensions: ["xspf"]
	},
	"application/xv+xml": {
		source: "iana",
		extensions: ["mxml", "xhvml", "xvml", "xvm"]
	},
	"application/yang": {
		source: "iana",
		extensions: ["yang"]
	},
	"application/yang-data+json": {
		source: "iana",
		compressible: true
	},
	"application/yang-data+xml": {
		source: "iana"
	},
	"application/yang-patch+json": {
		source: "iana",
		compressible: true
	},
	"application/yang-patch+xml": {
		source: "iana"
	},
	"application/yin+xml": {
		source: "iana",
		extensions: ["yin"]
	},
	"application/zip": {
		source: "iana",
		compressible: false,
		extensions: ["zip"]
	},
	"application/zlib": {
		source: "iana"
	},
	"audio/1d-interleaved-parityfec": {
		source: "iana"
	},
	"audio/32kadpcm": {
		source: "iana"
	},
	"audio/3gpp": {
		source: "iana",
		compressible: false,
		extensions: ["3gpp"]
	},
	"audio/3gpp2": {
		source: "iana"
	},
	"audio/ac3": {
		source: "iana"
	},
	"audio/adpcm": {
		source: "apache",
		extensions: ["adp"]
	},
	"audio/amr": {
		source: "iana"
	},
	"audio/amr-wb": {
		source: "iana"
	},
	"audio/amr-wb+": {
		source: "iana"
	},
	"audio/aptx": {
		source: "iana"
	},
	"audio/asc": {
		source: "iana"
	},
	"audio/atrac-advanced-lossless": {
		source: "iana"
	},
	"audio/atrac-x": {
		source: "iana"
	},
	"audio/atrac3": {
		source: "iana"
	},
	"audio/basic": {
		source: "iana",
		compressible: false,
		extensions: ["au", "snd"]
	},
	"audio/bv16": {
		source: "iana"
	},
	"audio/bv32": {
		source: "iana"
	},
	"audio/clearmode": {
		source: "iana"
	},
	"audio/cn": {
		source: "iana"
	},
	"audio/dat12": {
		source: "iana"
	},
	"audio/dls": {
		source: "iana"
	},
	"audio/dsr-es201108": {
		source: "iana"
	},
	"audio/dsr-es202050": {
		source: "iana"
	},
	"audio/dsr-es202211": {
		source: "iana"
	},
	"audio/dsr-es202212": {
		source: "iana"
	},
	"audio/dv": {
		source: "iana"
	},
	"audio/dvi4": {
		source: "iana"
	},
	"audio/eac3": {
		source: "iana"
	},
	"audio/encaprtp": {
		source: "iana"
	},
	"audio/evrc": {
		source: "iana"
	},
	"audio/evrc-qcp": {
		source: "iana"
	},
	"audio/evrc0": {
		source: "iana"
	},
	"audio/evrc1": {
		source: "iana"
	},
	"audio/evrcb": {
		source: "iana"
	},
	"audio/evrcb0": {
		source: "iana"
	},
	"audio/evrcb1": {
		source: "iana"
	},
	"audio/evrcnw": {
		source: "iana"
	},
	"audio/evrcnw0": {
		source: "iana"
	},
	"audio/evrcnw1": {
		source: "iana"
	},
	"audio/evrcwb": {
		source: "iana"
	},
	"audio/evrcwb0": {
		source: "iana"
	},
	"audio/evrcwb1": {
		source: "iana"
	},
	"audio/evs": {
		source: "iana"
	},
	"audio/fwdred": {
		source: "iana"
	},
	"audio/g711-0": {
		source: "iana"
	},
	"audio/g719": {
		source: "iana"
	},
	"audio/g722": {
		source: "iana"
	},
	"audio/g7221": {
		source: "iana"
	},
	"audio/g723": {
		source: "iana"
	},
	"audio/g726-16": {
		source: "iana"
	},
	"audio/g726-24": {
		source: "iana"
	},
	"audio/g726-32": {
		source: "iana"
	},
	"audio/g726-40": {
		source: "iana"
	},
	"audio/g728": {
		source: "iana"
	},
	"audio/g729": {
		source: "iana"
	},
	"audio/g7291": {
		source: "iana"
	},
	"audio/g729d": {
		source: "iana"
	},
	"audio/g729e": {
		source: "iana"
	},
	"audio/gsm": {
		source: "iana"
	},
	"audio/gsm-efr": {
		source: "iana"
	},
	"audio/gsm-hr-08": {
		source: "iana"
	},
	"audio/ilbc": {
		source: "iana"
	},
	"audio/ip-mr_v2.5": {
		source: "iana"
	},
	"audio/isac": {
		source: "apache"
	},
	"audio/l16": {
		source: "iana"
	},
	"audio/l20": {
		source: "iana"
	},
	"audio/l24": {
		source: "iana",
		compressible: false
	},
	"audio/l8": {
		source: "iana"
	},
	"audio/lpc": {
		source: "iana"
	},
	"audio/melp": {
		source: "iana"
	},
	"audio/melp1200": {
		source: "iana"
	},
	"audio/melp2400": {
		source: "iana"
	},
	"audio/melp600": {
		source: "iana"
	},
	"audio/midi": {
		source: "apache",
		extensions: ["mid", "midi", "kar", "rmi"]
	},
	"audio/mobile-xmf": {
		source: "iana"
	},
	"audio/mp3": {
		compressible: false,
		extensions: ["mp3"]
	},
	"audio/mp4": {
		source: "iana",
		compressible: false,
		extensions: ["m4a", "mp4a"]
	},
	"audio/mp4a-latm": {
		source: "iana"
	},
	"audio/mpa": {
		source: "iana"
	},
	"audio/mpa-robust": {
		source: "iana"
	},
	"audio/mpeg": {
		source: "iana",
		compressible: false,
		extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
	},
	"audio/mpeg4-generic": {
		source: "iana"
	},
	"audio/musepack": {
		source: "apache"
	},
	"audio/ogg": {
		source: "iana",
		compressible: false,
		extensions: ["oga", "ogg", "spx"]
	},
	"audio/opus": {
		source: "iana"
	},
	"audio/parityfec": {
		source: "iana"
	},
	"audio/pcma": {
		source: "iana"
	},
	"audio/pcma-wb": {
		source: "iana"
	},
	"audio/pcmu": {
		source: "iana"
	},
	"audio/pcmu-wb": {
		source: "iana"
	},
	"audio/prs.sid": {
		source: "iana"
	},
	"audio/qcelp": {
		source: "iana"
	},
	"audio/raptorfec": {
		source: "iana"
	},
	"audio/red": {
		source: "iana"
	},
	"audio/rtp-enc-aescm128": {
		source: "iana"
	},
	"audio/rtp-midi": {
		source: "iana"
	},
	"audio/rtploopback": {
		source: "iana"
	},
	"audio/rtx": {
		source: "iana"
	},
	"audio/s3m": {
		source: "apache",
		extensions: ["s3m"]
	},
	"audio/silk": {
		source: "apache",
		extensions: ["sil"]
	},
	"audio/smv": {
		source: "iana"
	},
	"audio/smv-qcp": {
		source: "iana"
	},
	"audio/smv0": {
		source: "iana"
	},
	"audio/sp-midi": {
		source: "iana"
	},
	"audio/speex": {
		source: "iana"
	},
	"audio/t140c": {
		source: "iana"
	},
	"audio/t38": {
		source: "iana"
	},
	"audio/telephone-event": {
		source: "iana"
	},
	"audio/tone": {
		source: "iana"
	},
	"audio/uemclip": {
		source: "iana"
	},
	"audio/ulpfec": {
		source: "iana"
	},
	"audio/vdvi": {
		source: "iana"
	},
	"audio/vmr-wb": {
		source: "iana"
	},
	"audio/vnd.3gpp.iufp": {
		source: "iana"
	},
	"audio/vnd.4sb": {
		source: "iana"
	},
	"audio/vnd.audiokoz": {
		source: "iana"
	},
	"audio/vnd.celp": {
		source: "iana"
	},
	"audio/vnd.cisco.nse": {
		source: "iana"
	},
	"audio/vnd.cmles.radio-events": {
		source: "iana"
	},
	"audio/vnd.cns.anp1": {
		source: "iana"
	},
	"audio/vnd.cns.inf1": {
		source: "iana"
	},
	"audio/vnd.dece.audio": {
		source: "iana",
		extensions: ["uva", "uvva"]
	},
	"audio/vnd.digital-winds": {
		source: "iana",
		extensions: ["eol"]
	},
	"audio/vnd.dlna.adts": {
		source: "iana"
	},
	"audio/vnd.dolby.heaac.1": {
		source: "iana"
	},
	"audio/vnd.dolby.heaac.2": {
		source: "iana"
	},
	"audio/vnd.dolby.mlp": {
		source: "iana"
	},
	"audio/vnd.dolby.mps": {
		source: "iana"
	},
	"audio/vnd.dolby.pl2": {
		source: "iana"
	},
	"audio/vnd.dolby.pl2x": {
		source: "iana"
	},
	"audio/vnd.dolby.pl2z": {
		source: "iana"
	},
	"audio/vnd.dolby.pulse.1": {
		source: "iana"
	},
	"audio/vnd.dra": {
		source: "iana",
		extensions: ["dra"]
	},
	"audio/vnd.dts": {
		source: "iana",
		extensions: ["dts"]
	},
	"audio/vnd.dts.hd": {
		source: "iana",
		extensions: ["dtshd"]
	},
	"audio/vnd.dvb.file": {
		source: "iana"
	},
	"audio/vnd.everad.plj": {
		source: "iana"
	},
	"audio/vnd.hns.audio": {
		source: "iana"
	},
	"audio/vnd.lucent.voice": {
		source: "iana",
		extensions: ["lvp"]
	},
	"audio/vnd.ms-playready.media.pya": {
		source: "iana",
		extensions: ["pya"]
	},
	"audio/vnd.nokia.mobile-xmf": {
		source: "iana"
	},
	"audio/vnd.nortel.vbk": {
		source: "iana"
	},
	"audio/vnd.nuera.ecelp4800": {
		source: "iana",
		extensions: ["ecelp4800"]
	},
	"audio/vnd.nuera.ecelp7470": {
		source: "iana",
		extensions: ["ecelp7470"]
	},
	"audio/vnd.nuera.ecelp9600": {
		source: "iana",
		extensions: ["ecelp9600"]
	},
	"audio/vnd.octel.sbc": {
		source: "iana"
	},
	"audio/vnd.presonus.multitrack": {
		source: "iana"
	},
	"audio/vnd.qcelp": {
		source: "iana"
	},
	"audio/vnd.rhetorex.32kadpcm": {
		source: "iana"
	},
	"audio/vnd.rip": {
		source: "iana",
		extensions: ["rip"]
	},
	"audio/vnd.rn-realaudio": {
		compressible: false
	},
	"audio/vnd.sealedmedia.softseal.mpeg": {
		source: "iana"
	},
	"audio/vnd.vmx.cvsd": {
		source: "iana"
	},
	"audio/vnd.wave": {
		compressible: false
	},
	"audio/vorbis": {
		source: "iana",
		compressible: false
	},
	"audio/vorbis-config": {
		source: "iana"
	},
	"audio/wav": {
		compressible: false,
		extensions: ["wav"]
	},
	"audio/wave": {
		compressible: false,
		extensions: ["wav"]
	},
	"audio/webm": {
		source: "apache",
		compressible: false,
		extensions: ["weba"]
	},
	"audio/x-aac": {
		source: "apache",
		compressible: false,
		extensions: ["aac"]
	},
	"audio/x-aiff": {
		source: "apache",
		extensions: ["aif", "aiff", "aifc"]
	},
	"audio/x-caf": {
		source: "apache",
		compressible: false,
		extensions: ["caf"]
	},
	"audio/x-flac": {
		source: "apache",
		extensions: ["flac"]
	},
	"audio/x-m4a": {
		source: "nginx",
		extensions: ["m4a"]
	},
	"audio/x-matroska": {
		source: "apache",
		extensions: ["mka"]
	},
	"audio/x-mpegurl": {
		source: "apache",
		extensions: ["m3u"]
	},
	"audio/x-ms-wax": {
		source: "apache",
		extensions: ["wax"]
	},
	"audio/x-ms-wma": {
		source: "apache",
		extensions: ["wma"]
	},
	"audio/x-pn-realaudio": {
		source: "apache",
		extensions: ["ram", "ra"]
	},
	"audio/x-pn-realaudio-plugin": {
		source: "apache",
		extensions: ["rmp"]
	},
	"audio/x-realaudio": {
		source: "nginx",
		extensions: ["ra"]
	},
	"audio/x-tta": {
		source: "apache"
	},
	"audio/x-wav": {
		source: "apache",
		extensions: ["wav"]
	},
	"audio/xm": {
		source: "apache",
		extensions: ["xm"]
	},
	"chemical/x-cdx": {
		source: "apache",
		extensions: ["cdx"]
	},
	"chemical/x-cif": {
		source: "apache",
		extensions: ["cif"]
	},
	"chemical/x-cmdf": {
		source: "apache",
		extensions: ["cmdf"]
	},
	"chemical/x-cml": {
		source: "apache",
		extensions: ["cml"]
	},
	"chemical/x-csml": {
		source: "apache",
		extensions: ["csml"]
	},
	"chemical/x-pdb": {
		source: "apache"
	},
	"chemical/x-xyz": {
		source: "apache",
		extensions: ["xyz"]
	},
	"font/collection": {
		source: "iana",
		extensions: ["ttc"]
	},
	"font/otf": {
		source: "iana",
		compressible: true,
		extensions: ["otf"]
	},
	"font/sfnt": {
		source: "iana"
	},
	"font/ttf": {
		source: "iana",
		extensions: ["ttf"]
	},
	"font/woff": {
		source: "iana",
		extensions: ["woff"]
	},
	"font/woff2": {
		source: "iana",
		extensions: ["woff2"]
	},
	"image/aces": {
		source: "iana"
	},
	"image/apng": {
		compressible: false,
		extensions: ["apng"]
	},
	"image/bmp": {
		source: "iana",
		compressible: true,
		extensions: ["bmp"]
	},
	"image/cgm": {
		source: "iana",
		extensions: ["cgm"]
	},
	"image/dicom-rle": {
		source: "iana"
	},
	"image/emf": {
		source: "iana"
	},
	"image/fits": {
		source: "iana"
	},
	"image/g3fax": {
		source: "iana",
		extensions: ["g3"]
	},
	"image/gif": {
		source: "iana",
		compressible: false,
		extensions: ["gif"]
	},
	"image/ief": {
		source: "iana",
		extensions: ["ief"]
	},
	"image/jls": {
		source: "iana"
	},
	"image/jp2": {
		source: "iana",
		compressible: false,
		extensions: ["jp2", "jpg2"]
	},
	"image/jpeg": {
		source: "iana",
		compressible: false,
		extensions: ["jpeg", "jpg", "jpe"]
	},
	"image/jpm": {
		source: "iana",
		compressible: false,
		extensions: ["jpm"]
	},
	"image/jpx": {
		source: "iana",
		compressible: false,
		extensions: ["jpx", "jpf"]
	},
	"image/ktx": {
		source: "iana",
		extensions: ["ktx"]
	},
	"image/naplps": {
		source: "iana"
	},
	"image/pjpeg": {
		compressible: false
	},
	"image/png": {
		source: "iana",
		compressible: false,
		extensions: ["png"]
	},
	"image/prs.btif": {
		source: "iana",
		extensions: ["btif"]
	},
	"image/prs.pti": {
		source: "iana"
	},
	"image/pwg-raster": {
		source: "iana"
	},
	"image/sgi": {
		source: "apache",
		extensions: ["sgi"]
	},
	"image/svg+xml": {
		source: "iana",
		compressible: true,
		extensions: ["svg", "svgz"]
	},
	"image/t38": {
		source: "iana"
	},
	"image/tiff": {
		source: "iana",
		compressible: false,
		extensions: ["tiff", "tif"]
	},
	"image/tiff-fx": {
		source: "iana"
	},
	"image/vnd.adobe.photoshop": {
		source: "iana",
		compressible: true,
		extensions: ["psd"]
	},
	"image/vnd.airzip.accelerator.azv": {
		source: "iana"
	},
	"image/vnd.cns.inf2": {
		source: "iana"
	},
	"image/vnd.dece.graphic": {
		source: "iana",
		extensions: ["uvi", "uvvi", "uvg", "uvvg"]
	},
	"image/vnd.djvu": {
		source: "iana",
		extensions: ["djvu", "djv"]
	},
	"image/vnd.dvb.subtitle": {
		source: "iana",
		extensions: ["sub"]
	},
	"image/vnd.dwg": {
		source: "iana",
		extensions: ["dwg"]
	},
	"image/vnd.dxf": {
		source: "iana",
		extensions: ["dxf"]
	},
	"image/vnd.fastbidsheet": {
		source: "iana",
		extensions: ["fbs"]
	},
	"image/vnd.fpx": {
		source: "iana",
		extensions: ["fpx"]
	},
	"image/vnd.fst": {
		source: "iana",
		extensions: ["fst"]
	},
	"image/vnd.fujixerox.edmics-mmr": {
		source: "iana",
		extensions: ["mmr"]
	},
	"image/vnd.fujixerox.edmics-rlc": {
		source: "iana",
		extensions: ["rlc"]
	},
	"image/vnd.globalgraphics.pgb": {
		source: "iana"
	},
	"image/vnd.microsoft.icon": {
		source: "iana"
	},
	"image/vnd.mix": {
		source: "iana"
	},
	"image/vnd.mozilla.apng": {
		source: "iana"
	},
	"image/vnd.ms-modi": {
		source: "iana",
		extensions: ["mdi"]
	},
	"image/vnd.ms-photo": {
		source: "apache",
		extensions: ["wdp"]
	},
	"image/vnd.net-fpx": {
		source: "iana",
		extensions: ["npx"]
	},
	"image/vnd.radiance": {
		source: "iana"
	},
	"image/vnd.sealed.png": {
		source: "iana"
	},
	"image/vnd.sealedmedia.softseal.gif": {
		source: "iana"
	},
	"image/vnd.sealedmedia.softseal.jpg": {
		source: "iana"
	},
	"image/vnd.svf": {
		source: "iana"
	},
	"image/vnd.tencent.tap": {
		source: "iana"
	},
	"image/vnd.valve.source.texture": {
		source: "iana"
	},
	"image/vnd.wap.wbmp": {
		source: "iana",
		extensions: ["wbmp"]
	},
	"image/vnd.xiff": {
		source: "iana",
		extensions: ["xif"]
	},
	"image/vnd.zbrush.pcx": {
		source: "iana"
	},
	"image/webp": {
		source: "apache",
		extensions: ["webp"]
	},
	"image/wmf": {
		source: "iana"
	},
	"image/x-3ds": {
		source: "apache",
		extensions: ["3ds"]
	},
	"image/x-cmu-raster": {
		source: "apache",
		extensions: ["ras"]
	},
	"image/x-cmx": {
		source: "apache",
		extensions: ["cmx"]
	},
	"image/x-freehand": {
		source: "apache",
		extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
	},
	"image/x-icon": {
		source: "apache",
		compressible: true,
		extensions: ["ico"]
	},
	"image/x-jng": {
		source: "nginx",
		extensions: ["jng"]
	},
	"image/x-mrsid-image": {
		source: "apache",
		extensions: ["sid"]
	},
	"image/x-ms-bmp": {
		source: "nginx",
		compressible: true,
		extensions: ["bmp"]
	},
	"image/x-pcx": {
		source: "apache",
		extensions: ["pcx"]
	},
	"image/x-pict": {
		source: "apache",
		extensions: ["pic", "pct"]
	},
	"image/x-portable-anymap": {
		source: "apache",
		extensions: ["pnm"]
	},
	"image/x-portable-bitmap": {
		source: "apache",
		extensions: ["pbm"]
	},
	"image/x-portable-graymap": {
		source: "apache",
		extensions: ["pgm"]
	},
	"image/x-portable-pixmap": {
		source: "apache",
		extensions: ["ppm"]
	},
	"image/x-rgb": {
		source: "apache",
		extensions: ["rgb"]
	},
	"image/x-tga": {
		source: "apache",
		extensions: ["tga"]
	},
	"image/x-xbitmap": {
		source: "apache",
		extensions: ["xbm"]
	},
	"image/x-xcf": {
		compressible: false
	},
	"image/x-xpixmap": {
		source: "apache",
		extensions: ["xpm"]
	},
	"image/x-xwindowdump": {
		source: "apache",
		extensions: ["xwd"]
	},
	"message/cpim": {
		source: "iana"
	},
	"message/delivery-status": {
		source: "iana"
	},
	"message/disposition-notification": {
		source: "iana",
		extensions: ["disposition-notification"]
	},
	"message/external-body": {
		source: "iana"
	},
	"message/feedback-report": {
		source: "iana"
	},
	"message/global": {
		source: "iana",
		extensions: ["u8msg"]
	},
	"message/global-delivery-status": {
		source: "iana",
		extensions: ["u8dsn"]
	},
	"message/global-disposition-notification": {
		source: "iana",
		extensions: ["u8mdn"]
	},
	"message/global-headers": {
		source: "iana",
		extensions: ["u8hdr"]
	},
	"message/http": {
		source: "iana",
		compressible: false
	},
	"message/imdn+xml": {
		source: "iana",
		compressible: true
	},
	"message/news": {
		source: "iana"
	},
	"message/partial": {
		source: "iana",
		compressible: false
	},
	"message/rfc822": {
		source: "iana",
		compressible: true,
		extensions: ["eml", "mime"]
	},
	"message/s-http": {
		source: "iana"
	},
	"message/sip": {
		source: "iana"
	},
	"message/sipfrag": {
		source: "iana"
	},
	"message/tracking-status": {
		source: "iana"
	},
	"message/vnd.si.simp": {
		source: "iana"
	},
	"message/vnd.wfa.wsc": {
		source: "iana",
		extensions: ["wsc"]
	},
	"model/3mf": {
		source: "iana"
	},
	"model/gltf+json": {
		source: "iana",
		compressible: true,
		extensions: ["gltf"]
	},
	"model/gltf-binary": {
		source: "iana",
		compressible: true,
		extensions: ["glb"]
	},
	"model/iges": {
		source: "iana",
		compressible: false,
		extensions: ["igs", "iges"]
	},
	"model/mesh": {
		source: "iana",
		compressible: false,
		extensions: ["msh", "mesh", "silo"]
	},
	"model/vnd.collada+xml": {
		source: "iana",
		extensions: ["dae"]
	},
	"model/vnd.dwf": {
		source: "iana",
		extensions: ["dwf"]
	},
	"model/vnd.flatland.3dml": {
		source: "iana"
	},
	"model/vnd.gdl": {
		source: "iana",
		extensions: ["gdl"]
	},
	"model/vnd.gs-gdl": {
		source: "apache"
	},
	"model/vnd.gs.gdl": {
		source: "iana"
	},
	"model/vnd.gtw": {
		source: "iana",
		extensions: ["gtw"]
	},
	"model/vnd.moml+xml": {
		source: "iana"
	},
	"model/vnd.mts": {
		source: "iana",
		extensions: ["mts"]
	},
	"model/vnd.opengex": {
		source: "iana"
	},
	"model/vnd.parasolid.transmit.binary": {
		source: "iana"
	},
	"model/vnd.parasolid.transmit.text": {
		source: "iana"
	},
	"model/vnd.rosette.annotated-data-model": {
		source: "iana"
	},
	"model/vnd.valve.source.compiled-map": {
		source: "iana"
	},
	"model/vnd.vtu": {
		source: "iana",
		extensions: ["vtu"]
	},
	"model/vrml": {
		source: "iana",
		compressible: false,
		extensions: ["wrl", "vrml"]
	},
	"model/x3d+binary": {
		source: "apache",
		compressible: false,
		extensions: ["x3db", "x3dbz"]
	},
	"model/x3d+fastinfoset": {
		source: "iana"
	},
	"model/x3d+vrml": {
		source: "apache",
		compressible: false,
		extensions: ["x3dv", "x3dvz"]
	},
	"model/x3d+xml": {
		source: "iana",
		compressible: true,
		extensions: ["x3d", "x3dz"]
	},
	"model/x3d-vrml": {
		source: "iana"
	},
	"multipart/alternative": {
		source: "iana",
		compressible: false
	},
	"multipart/appledouble": {
		source: "iana"
	},
	"multipart/byteranges": {
		source: "iana"
	},
	"multipart/digest": {
		source: "iana"
	},
	"multipart/encrypted": {
		source: "iana",
		compressible: false
	},
	"multipart/form-data": {
		source: "iana",
		compressible: false
	},
	"multipart/header-set": {
		source: "iana"
	},
	"multipart/mixed": {
		source: "iana",
		compressible: false
	},
	"multipart/multilingual": {
		source: "iana"
	},
	"multipart/parallel": {
		source: "iana"
	},
	"multipart/related": {
		source: "iana",
		compressible: false
	},
	"multipart/report": {
		source: "iana"
	},
	"multipart/signed": {
		source: "iana",
		compressible: false
	},
	"multipart/vnd.bint.med-plus": {
		source: "iana"
	},
	"multipart/voice-message": {
		source: "iana"
	},
	"multipart/x-mixed-replace": {
		source: "iana"
	},
	"text/1d-interleaved-parityfec": {
		source: "iana"
	},
	"text/cache-manifest": {
		source: "iana",
		compressible: true,
		extensions: ["appcache", "manifest"]
	},
	"text/calendar": {
		source: "iana",
		extensions: ["ics", "ifb"]
	},
	"text/calender": {
		compressible: true
	},
	"text/cmd": {
		compressible: true
	},
	"text/coffeescript": {
		extensions: ["coffee", "litcoffee"]
	},
	"text/css": {
		source: "iana",
		charset: "UTF-8",
		compressible: true,
		extensions: ["css"]
	},
	"text/csv": {
		source: "iana",
		compressible: true,
		extensions: ["csv"]
	},
	"text/csv-schema": {
		source: "iana"
	},
	"text/directory": {
		source: "iana"
	},
	"text/dns": {
		source: "iana"
	},
	"text/ecmascript": {
		source: "iana"
	},
	"text/encaprtp": {
		source: "iana"
	},
	"text/enriched": {
		source: "iana"
	},
	"text/fwdred": {
		source: "iana"
	},
	"text/grammar-ref-list": {
		source: "iana"
	},
	"text/html": {
		source: "iana",
		compressible: true,
		extensions: ["html", "htm", "shtml"]
	},
	"text/jade": {
		extensions: ["jade"]
	},
	"text/javascript": {
		source: "iana",
		compressible: true
	},
	"text/jcr-cnd": {
		source: "iana"
	},
	"text/jsx": {
		compressible: true,
		extensions: ["jsx"]
	},
	"text/less": {
		extensions: ["less"]
	},
	"text/markdown": {
		source: "iana",
		compressible: true,
		extensions: ["markdown", "md"]
	},
	"text/mathml": {
		source: "nginx",
		extensions: ["mml"]
	},
	"text/mizar": {
		source: "iana"
	},
	"text/n3": {
		source: "iana",
		compressible: true,
		extensions: ["n3"]
	},
	"text/parameters": {
		source: "iana"
	},
	"text/parityfec": {
		source: "iana"
	},
	"text/plain": {
		source: "iana",
		compressible: true,
		extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
	},
	"text/provenance-notation": {
		source: "iana"
	},
	"text/prs.fallenstein.rst": {
		source: "iana"
	},
	"text/prs.lines.tag": {
		source: "iana",
		extensions: ["dsc"]
	},
	"text/prs.prop.logic": {
		source: "iana"
	},
	"text/raptorfec": {
		source: "iana"
	},
	"text/red": {
		source: "iana"
	},
	"text/rfc822-headers": {
		source: "iana"
	},
	"text/richtext": {
		source: "iana",
		compressible: true,
		extensions: ["rtx"]
	},
	"text/rtf": {
		source: "iana",
		compressible: true,
		extensions: ["rtf"]
	},
	"text/rtp-enc-aescm128": {
		source: "iana"
	},
	"text/rtploopback": {
		source: "iana"
	},
	"text/rtx": {
		source: "iana"
	},
	"text/sgml": {
		source: "iana",
		extensions: ["sgml", "sgm"]
	},
	"text/shex": {
		extensions: ["shex"]
	},
	"text/slim": {
		extensions: ["slim", "slm"]
	},
	"text/strings": {
		source: "iana"
	},
	"text/stylus": {
		extensions: ["stylus", "styl"]
	},
	"text/t140": {
		source: "iana"
	},
	"text/tab-separated-values": {
		source: "iana",
		compressible: true,
		extensions: ["tsv"]
	},
	"text/troff": {
		source: "iana",
		extensions: ["t", "tr", "roff", "man", "me", "ms"]
	},
	"text/turtle": {
		source: "iana",
		extensions: ["ttl"]
	},
	"text/ulpfec": {
		source: "iana"
	},
	"text/uri-list": {
		source: "iana",
		compressible: true,
		extensions: ["uri", "uris", "urls"]
	},
	"text/vcard": {
		source: "iana",
		compressible: true,
		extensions: ["vcard"]
	},
	"text/vnd.a": {
		source: "iana"
	},
	"text/vnd.abc": {
		source: "iana"
	},
	"text/vnd.ascii-art": {
		source: "iana"
	},
	"text/vnd.curl": {
		source: "iana",
		extensions: ["curl"]
	},
	"text/vnd.curl.dcurl": {
		source: "apache",
		extensions: ["dcurl"]
	},
	"text/vnd.curl.mcurl": {
		source: "apache",
		extensions: ["mcurl"]
	},
	"text/vnd.curl.scurl": {
		source: "apache",
		extensions: ["scurl"]
	},
	"text/vnd.debian.copyright": {
		source: "iana"
	},
	"text/vnd.dmclientscript": {
		source: "iana"
	},
	"text/vnd.dvb.subtitle": {
		source: "iana",
		extensions: ["sub"]
	},
	"text/vnd.esmertec.theme-descriptor": {
		source: "iana"
	},
	"text/vnd.fly": {
		source: "iana",
		extensions: ["fly"]
	},
	"text/vnd.fmi.flexstor": {
		source: "iana",
		extensions: ["flx"]
	},
	"text/vnd.graphviz": {
		source: "iana",
		extensions: ["gv"]
	},
	"text/vnd.in3d.3dml": {
		source: "iana",
		extensions: ["3dml"]
	},
	"text/vnd.in3d.spot": {
		source: "iana",
		extensions: ["spot"]
	},
	"text/vnd.iptc.newsml": {
		source: "iana"
	},
	"text/vnd.iptc.nitf": {
		source: "iana"
	},
	"text/vnd.latex-z": {
		source: "iana"
	},
	"text/vnd.motorola.reflex": {
		source: "iana"
	},
	"text/vnd.ms-mediapackage": {
		source: "iana"
	},
	"text/vnd.net2phone.commcenter.command": {
		source: "iana"
	},
	"text/vnd.radisys.msml-basic-layout": {
		source: "iana"
	},
	"text/vnd.si.uricatalogue": {
		source: "iana"
	},
	"text/vnd.sun.j2me.app-descriptor": {
		source: "iana",
		extensions: ["jad"]
	},
	"text/vnd.trolltech.linguist": {
		source: "iana"
	},
	"text/vnd.wap.si": {
		source: "iana"
	},
	"text/vnd.wap.sl": {
		source: "iana"
	},
	"text/vnd.wap.wml": {
		source: "iana",
		extensions: ["wml"]
	},
	"text/vnd.wap.wmlscript": {
		source: "iana",
		extensions: ["wmls"]
	},
	"text/vtt": {
		charset: "UTF-8",
		compressible: true,
		extensions: ["vtt"]
	},
	"text/x-asm": {
		source: "apache",
		extensions: ["s", "asm"]
	},
	"text/x-c": {
		source: "apache",
		extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
	},
	"text/x-component": {
		source: "nginx",
		extensions: ["htc"]
	},
	"text/x-fortran": {
		source: "apache",
		extensions: ["f", "for", "f77", "f90"]
	},
	"text/x-gwt-rpc": {
		compressible: true
	},
	"text/x-handlebars-template": {
		extensions: ["hbs"]
	},
	"text/x-java-source": {
		source: "apache",
		extensions: ["java"]
	},
	"text/x-jquery-tmpl": {
		compressible: true
	},
	"text/x-lua": {
		extensions: ["lua"]
	},
	"text/x-markdown": {
		compressible: true,
		extensions: ["mkd"]
	},
	"text/x-nfo": {
		source: "apache",
		extensions: ["nfo"]
	},
	"text/x-opml": {
		source: "apache",
		extensions: ["opml"]
	},
	"text/x-org": {
		compressible: true,
		extensions: ["org"]
	},
	"text/x-pascal": {
		source: "apache",
		extensions: ["p", "pas"]
	},
	"text/x-processing": {
		compressible: true,
		extensions: ["pde"]
	},
	"text/x-sass": {
		extensions: ["sass"]
	},
	"text/x-scss": {
		extensions: ["scss"]
	},
	"text/x-setext": {
		source: "apache",
		extensions: ["etx"]
	},
	"text/x-sfv": {
		source: "apache",
		extensions: ["sfv"]
	},
	"text/x-suse-ymp": {
		compressible: true,
		extensions: ["ymp"]
	},
	"text/x-uuencode": {
		source: "apache",
		extensions: ["uu"]
	},
	"text/x-vcalendar": {
		source: "apache",
		extensions: ["vcs"]
	},
	"text/x-vcard": {
		source: "apache",
		extensions: ["vcf"]
	},
	"text/xml": {
		source: "iana",
		compressible: true,
		extensions: ["xml"]
	},
	"text/xml-external-parsed-entity": {
		source: "iana"
	},
	"text/yaml": {
		extensions: ["yaml", "yml"]
	},
	"video/1d-interleaved-parityfec": {
		source: "iana"
	},
	"video/3gpp": {
		source: "iana",
		extensions: ["3gp", "3gpp"]
	},
	"video/3gpp-tt": {
		source: "iana"
	},
	"video/3gpp2": {
		source: "iana",
		extensions: ["3g2"]
	},
	"video/bmpeg": {
		source: "iana"
	},
	"video/bt656": {
		source: "iana"
	},
	"video/celb": {
		source: "iana"
	},
	"video/dv": {
		source: "iana"
	},
	"video/encaprtp": {
		source: "iana"
	},
	"video/h261": {
		source: "iana",
		extensions: ["h261"]
	},
	"video/h263": {
		source: "iana",
		extensions: ["h263"]
	},
	"video/h263-1998": {
		source: "iana"
	},
	"video/h263-2000": {
		source: "iana"
	},
	"video/h264": {
		source: "iana",
		extensions: ["h264"]
	},
	"video/h264-rcdo": {
		source: "iana"
	},
	"video/h264-svc": {
		source: "iana"
	},
	"video/h265": {
		source: "iana"
	},
	"video/iso.segment": {
		source: "iana"
	},
	"video/jpeg": {
		source: "iana",
		extensions: ["jpgv"]
	},
	"video/jpeg2000": {
		source: "iana"
	},
	"video/jpm": {
		source: "apache",
		extensions: ["jpm", "jpgm"]
	},
	"video/mj2": {
		source: "iana",
		extensions: ["mj2", "mjp2"]
	},
	"video/mp1s": {
		source: "iana"
	},
	"video/mp2p": {
		source: "iana"
	},
	"video/mp2t": {
		source: "iana",
		extensions: ["ts"]
	},
	"video/mp4": {
		source: "iana",
		compressible: false,
		extensions: ["mp4", "mp4v", "mpg4"]
	},
	"video/mp4v-es": {
		source: "iana"
	},
	"video/mpeg": {
		source: "iana",
		compressible: false,
		extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
	},
	"video/mpeg4-generic": {
		source: "iana"
	},
	"video/mpv": {
		source: "iana"
	},
	"video/nv": {
		source: "iana"
	},
	"video/ogg": {
		source: "iana",
		compressible: false,
		extensions: ["ogv"]
	},
	"video/parityfec": {
		source: "iana"
	},
	"video/pointer": {
		source: "iana"
	},
	"video/quicktime": {
		source: "iana",
		compressible: false,
		extensions: ["qt", "mov"]
	},
	"video/raptorfec": {
		source: "iana"
	},
	"video/raw": {
		source: "iana"
	},
	"video/rtp-enc-aescm128": {
		source: "iana"
	},
	"video/rtploopback": {
		source: "iana"
	},
	"video/rtx": {
		source: "iana"
	},
	"video/smpte291": {
		source: "iana"
	},
	"video/smpte292m": {
		source: "iana"
	},
	"video/ulpfec": {
		source: "iana"
	},
	"video/vc1": {
		source: "iana"
	},
	"video/vnd.cctv": {
		source: "iana"
	},
	"video/vnd.dece.hd": {
		source: "iana",
		extensions: ["uvh", "uvvh"]
	},
	"video/vnd.dece.mobile": {
		source: "iana",
		extensions: ["uvm", "uvvm"]
	},
	"video/vnd.dece.mp4": {
		source: "iana"
	},
	"video/vnd.dece.pd": {
		source: "iana",
		extensions: ["uvp", "uvvp"]
	},
	"video/vnd.dece.sd": {
		source: "iana",
		extensions: ["uvs", "uvvs"]
	},
	"video/vnd.dece.video": {
		source: "iana",
		extensions: ["uvv", "uvvv"]
	},
	"video/vnd.directv.mpeg": {
		source: "iana"
	},
	"video/vnd.directv.mpeg-tts": {
		source: "iana"
	},
	"video/vnd.dlna.mpeg-tts": {
		source: "iana"
	},
	"video/vnd.dvb.file": {
		source: "iana",
		extensions: ["dvb"]
	},
	"video/vnd.fvt": {
		source: "iana",
		extensions: ["fvt"]
	},
	"video/vnd.hns.video": {
		source: "iana"
	},
	"video/vnd.iptvforum.1dparityfec-1010": {
		source: "iana"
	},
	"video/vnd.iptvforum.1dparityfec-2005": {
		source: "iana"
	},
	"video/vnd.iptvforum.2dparityfec-1010": {
		source: "iana"
	},
	"video/vnd.iptvforum.2dparityfec-2005": {
		source: "iana"
	},
	"video/vnd.iptvforum.ttsavc": {
		source: "iana"
	},
	"video/vnd.iptvforum.ttsmpeg2": {
		source: "iana"
	},
	"video/vnd.motorola.video": {
		source: "iana"
	},
	"video/vnd.motorola.videop": {
		source: "iana"
	},
	"video/vnd.mpegurl": {
		source: "iana",
		extensions: ["mxu", "m4u"]
	},
	"video/vnd.ms-playready.media.pyv": {
		source: "iana",
		extensions: ["pyv"]
	},
	"video/vnd.nokia.interleaved-multimedia": {
		source: "iana"
	},
	"video/vnd.nokia.mp4vr": {
		source: "iana"
	},
	"video/vnd.nokia.videovoip": {
		source: "iana"
	},
	"video/vnd.objectvideo": {
		source: "iana"
	},
	"video/vnd.radgamettools.bink": {
		source: "iana"
	},
	"video/vnd.radgamettools.smacker": {
		source: "iana"
	},
	"video/vnd.sealed.mpeg1": {
		source: "iana"
	},
	"video/vnd.sealed.mpeg4": {
		source: "iana"
	},
	"video/vnd.sealed.swf": {
		source: "iana"
	},
	"video/vnd.sealedmedia.softseal.mov": {
		source: "iana"
	},
	"video/vnd.uvvu.mp4": {
		source: "iana",
		extensions: ["uvu", "uvvu"]
	},
	"video/vnd.vivo": {
		source: "iana",
		extensions: ["viv"]
	},
	"video/vp8": {
		source: "iana"
	},
	"video/webm": {
		source: "apache",
		compressible: false,
		extensions: ["webm"]
	},
	"video/x-f4v": {
		source: "apache",
		extensions: ["f4v"]
	},
	"video/x-fli": {
		source: "apache",
		extensions: ["fli"]
	},
	"video/x-flv": {
		source: "apache",
		compressible: false,
		extensions: ["flv"]
	},
	"video/x-m4v": {
		source: "apache",
		extensions: ["m4v"]
	},
	"video/x-matroska": {
		source: "apache",
		compressible: false,
		extensions: ["mkv", "mk3d", "mks"]
	},
	"video/x-mng": {
		source: "apache",
		extensions: ["mng"]
	},
	"video/x-ms-asf": {
		source: "apache",
		extensions: ["asf", "asx"]
	},
	"video/x-ms-vob": {
		source: "apache",
		extensions: ["vob"]
	},
	"video/x-ms-wm": {
		source: "apache",
		extensions: ["wm"]
	},
	"video/x-ms-wmv": {
		source: "apache",
		compressible: false,
		extensions: ["wmv"]
	},
	"video/x-ms-wmx": {
		source: "apache",
		extensions: ["wmx"]
	},
	"video/x-ms-wvx": {
		source: "apache",
		extensions: ["wvx"]
	},
	"video/x-msvideo": {
		source: "apache",
		extensions: ["avi"]
	},
	"video/x-sgi-movie": {
		source: "apache",
		extensions: ["movie"]
	},
	"video/x-smv": {
		source: "apache",
		extensions: ["smv"]
	},
	"x-conference/x-cooltalk": {
		source: "apache",
		extensions: ["ice"]
	},
	"x-shader/x-fragment": {
		compressible: true
	},
	"x-shader/x-vertex": {
		compressible: true
	}
};

var db$1 = /*#__PURE__*/Object.freeze({
	default: db
});

var require$$0$2 = ( db$1 && db ) || db$1;

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

var mimeDb = require$$0$2;

var mimeTypes = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @private
 */


var extname = path.extname;

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;

/**
 * Module exports.
 * @public
 */

exports.charset = charset;
exports.charsets = { lookup: charset };
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset(type) {
  if (!type || typeof type !== 'string') {
    return false;
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && mimeDb[match[1].toLowerCase()];

  if (mime && mime.charset) {
    return mime.charset;
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8';
  }

  return false;
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType(str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false;
  }

  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

  if (!mime) {
    return false;
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime);
    if (charset) mime += '; charset=' + charset.toLowerCase();
  }

  return mime;
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension(type) {
  if (!type || typeof type !== 'string') {
    return false;
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type);

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()];

  if (!exts || !exts.length) {
    return false;
  }

  return exts[0];
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup(path$$1) {
  if (!path$$1 || typeof path$$1 !== 'string') {
    return false;
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path$$1).toLowerCase().substr(1);

  if (!extension) {
    return false;
  }

  return exports.types[extension] || false;
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps(extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana'];

  Object.keys(mimeDb).forEach(function forEachMimeType(type) {
    var mime = mimeDb[type];
    var exts = mime.extensions;

    if (!exts || !exts.length) {
      return;
    }

    // mime -> extensions
    extensions[type] = exts;

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];

      if (types[extension]) {
        var from = preference.indexOf(mimeDb[types[extension]].source);
        var to = preference.indexOf(mime.source);

        if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
          // skip the remapping
          continue;
        }
      }

      // set the extension -> mime
      types[extension] = type;
    }
  });
}
});
var mimeTypes_1 = mimeTypes.charset;
var mimeTypes_2 = mimeTypes.charsets;
var mimeTypes_3 = mimeTypes.contentType;
var mimeTypes_4 = mimeTypes.extension;
var mimeTypes_5 = mimeTypes.extensions;
var mimeTypes_6 = mimeTypes.lookup;
var mimeTypes_7 = mimeTypes.types;

/**
 * Module dependencies.
 * @private
 */




/**
 * Module exports.
 * @public
 */

var typeIs = typeofrequest;
var is = typeis;
var hasBody = hasbody;
var normalize_1 = normalize;
var match = mimeMatch;

/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @public
 */

function typeis(value, types_) {
  var i;
  var types = types_;

  // remove parameters and normalize
  var val = tryNormalizeType(value);

  // no type or invalid
  if (!val) {
    return false;
  }

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length - 1);
    for (i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  }

  // no types, return the content type
  if (!types || !types.length) {
    return val;
  }

  var type;
  for (i = 0; i < types.length; i++) {
    if (mimeMatch(normalize(type = types[i]), val)) {
      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;
    }
  }

  // no matches
  return false;
}

/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @public
 */

function hasbody(req) {
  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);
}

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

function typeofrequest(req, types_) {
  var types = types_;

  // no body
  if (!hasbody(req)) {
    return null;
  }

  // support flattened arguments
  if (arguments.length > 2) {
    types = new Array(arguments.length - 1);
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i + 1];
    }
  }

  // request content type
  var value = req.headers['content-type'];

  return typeis(value, types);
}

/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @private
 */

function normalize(type) {
  if (typeof type !== 'string') {
    // invalid type
    return false;
  }

  switch (type) {
    case 'urlencoded':
      return 'application/x-www-form-urlencoded';
    case 'multipart':
      return 'multipart/*';
  }

  if (type[0] === '+') {
    // "+json" -> "*/*+json" expando
    return '*/*' + type;
  }

  return type.indexOf('/') === -1 ? mimeTypes.lookup(type) : type;
}

/**
 * Check if `expected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @private
 */

function mimeMatch(expected, actual) {
  // invalid type
  if (expected === false) {
    return false;
  }

  // split types
  var actualParts = actual.split('/');
  var expectedParts = expected.split('/');

  // invalid format
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  }

  // validate type
  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {
    return false;
  }

  // validate suffix wildcard
  if (expectedParts[1].substr(0, 2) === '*+') {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  }

  // validate subtype
  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {
    return false;
  }

  return true;
}

/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function normalizeType(value) {
  // parse the type
  var type = mediaTyper.parse(value);

  // remove the parameters
  type.parameters = undefined;

  // reformat it
  return mediaTyper.format(type);
}

/**
 * Try to normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @private
 */

function tryNormalizeType(value) {
  try {
    return normalizeType(value);
  } catch (err) {
    return null;
  }
}
typeIs.is = is;
typeIs.hasBody = hasBody;
typeIs.normalize = normalize_1;
typeIs.match = match;

/**
 * Module dependencies.
 * @private
 */




var debug$1 = src('body-parser:json');



/**
 * Module exports.
 */

var json_1 = json;

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*(.)/; // eslint-disable-line no-control-regex

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function json(options) {
  var opts = options || {};

  var limit = typeof opts.limit !== 'number' ? bytes_1.parse(opts.limit || '100kb') : opts.limit;
  var inflate = opts.inflate !== false;
  var reviver = opts.reviver;
  var strict = opts.strict !== false;
  var type = opts.type || 'application/json';
  var verify = opts.verify || false;

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function');
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;

  function parse(body) {
    if (body.length === 0) {
      // special-case empty json body, as it's a common client-side mistake
      // TODO: maybe make this configurable or part of "strict" option
      return {};
    }

    if (strict) {
      var first = firstchar(body);

      if (first !== '{' && first !== '[') {
        debug$1('strict violation');
        throw createStrictSyntaxError(body, first);
      }
    }

    try {
      debug$1('parse json');
      return JSON.parse(body, reviver);
    } catch (e) {
      throw normalizeJsonSyntaxError(e, {
        stack: e.stack
      });
    }
  }

  return function jsonParser(req, res, next) {
    if (req._body) {
      debug$1('body already parsed');
      next();
      return;
    }

    req.body = req.body || {};

    // skip requests without bodies
    if (!typeIs.hasBody(req)) {
      debug$1('skip empty body');
      next();
      return;
    }

    debug$1('content-type %j', req.headers['content-type']);

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug$1('skip parsing');
      next();
      return;
    }

    // assert charset per RFC 7159 sec 8.1
    var charset = getCharset(req) || 'utf-8';
    if (charset.substr(0, 4) !== 'utf-') {
      debug$1('invalid charset');
      next(httpErrors(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }));
      return;
    }

    // read
    read_1(req, res, next, parse, debug$1, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    });
  };
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

function createStrictSyntaxError(str, char) {
  var index = str.indexOf(char);
  var partial = str.substring(0, index) + '#';

  try {
    JSON.parse(partial); /* istanbul ignore next */throw new SyntaxError('strict violation');
  } catch (e) {
    return normalizeJsonSyntaxError(e, {
      message: e.message.replace('#', char),
      stack: e.stack
    });
  }
}

/**
 * Get the first non-whitespace character in a string.
 *
 * @param {string} str
 * @return {function}
 * @private
 */

function firstchar(str) {
  return FIRST_CHAR_REGEXP.exec(str)[1];
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset(req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase();
  } catch (e) {
    return undefined;
  }
}

/**
 * Normalize a SyntaxError for JSON.parse.
 *
 * @param {SyntaxError} error
 * @param {object} obj
 * @return {SyntaxError}
 */

function normalizeJsonSyntaxError(error, obj) {
  var keys = Object.getOwnPropertyNames(error);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (key !== 'stack' && key !== 'message') {
      delete error[key];
    }
  }

  var props = Object.keys(obj);

  for (var j = 0; j < props.length; j++) {
    var prop = props[j];
    error[prop] = obj[prop];
  }

  return error;
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker(type) {
  return function checkType(req) {
    return Boolean(typeIs(req, type));
  };
}

/**
 * Module dependencies.
 */


var debug$2 = src('body-parser:raw');



/**
 * Module exports.
 */

var raw_1 = raw;

/**
 * Create a middleware to parse raw bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function raw(options) {
  var opts = options || {};

  var inflate = opts.inflate !== false;
  var limit = typeof opts.limit !== 'number' ? bytes_1.parse(opts.limit || '100kb') : opts.limit;
  var type = opts.type || 'application/octet-stream';
  var verify = opts.verify || false;

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function');
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function' ? typeChecker$1(type) : type;

  function parse(buf) {
    return buf;
  }

  return function rawParser(req, res, next) {
    if (req._body) {
      debug$2('body already parsed');
      next();
      return;
    }

    req.body = req.body || {};

    // skip requests without bodies
    if (!typeIs.hasBody(req)) {
      debug$2('skip empty body');
      next();
      return;
    }

    debug$2('content-type %j', req.headers['content-type']);

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug$2('skip parsing');
      next();
      return;
    }

    // read
    read_1(req, res, next, parse, debug$2, {
      encoding: null,
      inflate: inflate,
      limit: limit,
      verify: verify
    });
  };
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker$1(type) {
  return function checkType(req) {
    return Boolean(typeIs(req, type));
  };
}

/**
 * Module dependencies.
 */



var debug$3 = src('body-parser:text');



/**
 * Module exports.
 */

var text_1 = text;

/**
 * Create a middleware to parse text bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @api public
 */

function text(options) {
  var opts = options || {};

  var defaultCharset = opts.defaultCharset || 'utf-8';
  var inflate = opts.inflate !== false;
  var limit = typeof opts.limit !== 'number' ? bytes_1.parse(opts.limit || '100kb') : opts.limit;
  var type = opts.type || 'text/plain';
  var verify = opts.verify || false;

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function');
  }

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function' ? typeChecker$2(type) : type;

  function parse(buf) {
    return buf;
  }

  return function textParser(req, res, next) {
    if (req._body) {
      debug$3('body already parsed');
      next();
      return;
    }

    req.body = req.body || {};

    // skip requests without bodies
    if (!typeIs.hasBody(req)) {
      debug$3('skip empty body');
      next();
      return;
    }

    debug$3('content-type %j', req.headers['content-type']);

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug$3('skip parsing');
      next();
      return;
    }

    // get charset
    var charset = getCharset$1(req) || defaultCharset;

    // read
    read_1(req, res, next, parse, debug$3, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    });
  };
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset$1(req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase();
  } catch (e) {
    return undefined;
  }
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker$2(type) {
  return function checkType(req) {
    return Boolean(typeIs(req, type));
  };
}

var utils = createCommonjsModule(function (module, exports) {

var has = Object.prototype.hasOwnProperty;

var hexTable = function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}();

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

exports.arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (c === 0x2D // -
        || c === 0x2E // .
        || c === 0x5F // _
        || c === 0x7E // ~
        || c >= 0x30 && c <= 0x39 // 0-9
        || c >= 0x41 && c <= 0x5A // a-z
        || c >= 0x61 && c <= 0x7A // A-Z
        ) {
                out += string.charAt(i);
                continue;
            }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F]);
            continue;
        }

        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | string.charCodeAt(i) & 0x3FF);
        out += hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
    }

    return out;
};

exports.compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

exports.isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
});
var utils_1 = utils.arrayToObject;
var utils_2 = utils.merge;
var utils_3 = utils.assign;
var utils_4 = utils.decode;
var utils_5 = utils.encode;
var utils_6 = utils.compact;
var utils_7 = utils.isRegExp;
var utils_8 = utils.isBuffer;

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var formats = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) {
        // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
        // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        } else {
            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
        }
    }

    return values;
};

var stringify_1 = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode ? encoder : null, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

var has = Object.prototype.hasOwnProperty;

var defaults$1 = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults$1.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults$1.decoder);
            val = options.decoder(part.slice(pos + 1), defaults$1.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var parse$4 = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults$1.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults$1.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults$1.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults$1.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults$1.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults$1.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults$1.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults$1.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults$1.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

var lib$1 = {
    formats: formats,
    parse: parse$4,
    stringify: stringify_1
};

/**
 * Module dependencies.
 * @private
 */




var debug$4 = src('body-parser:urlencoded');
var deprecate = depd_1('body-parser');



/**
 * Module exports.
 */

var urlencoded_1 = urlencoded;

/**
 * Cache of parser modules.
 */

var parsers = Object.create(null);

/**
 * Create a middleware to parse urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

function urlencoded(options) {
  var opts = options || {};

  // notice because option default will flip in next major
  if (opts.extended === undefined) {
    deprecate('undefined extended: provide extended option');
  }

  var extended = opts.extended !== false;
  var inflate = opts.inflate !== false;
  var limit = typeof opts.limit !== 'number' ? bytes_1.parse(opts.limit || '100kb') : opts.limit;
  var type = opts.type || 'application/x-www-form-urlencoded';
  var verify = opts.verify || false;

  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function');
  }

  // create the appropriate query parser
  var queryparse = extended ? extendedparser(opts) : simpleparser(opts);

  // create the appropriate type checking function
  var shouldParse = typeof type !== 'function' ? typeChecker$3(type) : type;

  function parse(body) {
    return body.length ? queryparse(body) : {};
  }

  return function urlencodedParser(req, res, next) {
    if (req._body) {
      debug$4('body already parsed');
      next();
      return;
    }

    req.body = req.body || {};

    // skip requests without bodies
    if (!typeIs.hasBody(req)) {
      debug$4('skip empty body');
      next();
      return;
    }

    debug$4('content-type %j', req.headers['content-type']);

    // determine if request should be parsed
    if (!shouldParse(req)) {
      debug$4('skip parsing');
      next();
      return;
    }

    // assert charset
    var charset = getCharset$2(req) || 'utf-8';
    if (charset !== 'utf-8') {
      debug$4('invalid charset');
      next(httpErrors(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }));
      return;
    }

    // read
    read_1(req, res, next, parse, debug$4, {
      debug: debug$4,
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    });
  };
}

/**
 * Get the extended query parser.
 *
 * @param {object} options
 */

function extendedparser(options) {
  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
  var parse = parser('qs');

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number');
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0;
  }

  return function queryparse(body) {
    var paramCount = parameterCount(body, parameterLimit);

    if (paramCount === undefined) {
      debug$4('too many parameters');
      throw httpErrors(413, 'too many parameters', {
        type: 'parameters.too.many'
      });
    }

    var arrayLimit = Math.max(100, paramCount);

    debug$4('parse extended urlencoding');
    return parse(body, {
      allowPrototypes: true,
      arrayLimit: arrayLimit,
      depth: Infinity,
      parameterLimit: parameterLimit
    });
  };
}

/**
 * Get the charset of a request.
 *
 * @param {object} req
 * @api private
 */

function getCharset$2(req) {
  try {
    return (contentType.parse(req).parameters.charset || '').toLowerCase();
  } catch (e) {
    return undefined;
  }
}

/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount(body, limit) {
  var count = 0;
  var index = 0;

  while ((index = body.indexOf('&', index)) !== -1) {
    count++;
    index++;

    if (count === limit) {
      return undefined;
    }
  }

  return count;
}

/**
 * Get parser for module name dynamically.
 *
 * @param {string} name
 * @return {function}
 * @api private
 */

function parser(name) {
  var mod = parsers[name];

  if (mod !== undefined) {
    return mod.parse;
  }

  // this uses a switch for static require analysis
  switch (name) {
    case 'qs':
      mod = lib$1;
      break;
    case 'querystring':
      mod = querystring;
      break;
  }

  // store to prevent invoking require()
  parsers[name] = mod;

  return mod.parse;
}

/**
 * Get the simple query parser.
 *
 * @param {object} options
 */

function simpleparser(options) {
  var parameterLimit = options.parameterLimit !== undefined ? options.parameterLimit : 1000;
  var parse = parser('querystring');

  if (isNaN(parameterLimit) || parameterLimit < 1) {
    throw new TypeError('option parameterLimit must be a positive number');
  }

  if (isFinite(parameterLimit)) {
    parameterLimit = parameterLimit | 0;
  }

  return function queryparse(body) {
    var paramCount = parameterCount(body, parameterLimit);

    if (paramCount === undefined) {
      debug$4('too many parameters');
      throw httpErrors(413, 'too many parameters', {
        type: 'parameters.too.many'
      });
    }

    debug$4('parse urlencoding');
    return parse(body, undefined, undefined, { maxKeys: parameterLimit });
  };
}

/**
 * Get the simple type checker.
 *
 * @param {string} type
 * @return {function}
 */

function typeChecker$3(type) {
  return function checkType(req) {
    return Boolean(typeIs(req, type));
  };
}

var bodyParser_1 = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @private
 */

var deprecate = depd_1('body-parser');

/**
 * Cache of loaded parsers.
 * @private
 */

var parsers = Object.create(null);

/**
 * @typedef Parsers
 * @type {function}
 * @property {function} json
 * @property {function} raw
 * @property {function} text
 * @property {function} urlencoded
 */

/**
 * Module exports.
 * @type {Parsers}
 */

exports = module.exports = deprecate.function(bodyParser, 'bodyParser: use individual json/urlencoded middlewares');

/**
 * JSON parser.
 * @public
 */

Object.defineProperty(exports, 'json', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('json')
});

/**
 * Raw parser.
 * @public
 */

Object.defineProperty(exports, 'raw', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('raw')
});

/**
 * Text parser.
 * @public
 */

Object.defineProperty(exports, 'text', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('text')
});

/**
 * URL-encoded parser.
 * @public
 */

Object.defineProperty(exports, 'urlencoded', {
  configurable: true,
  enumerable: true,
  get: createParserGetter('urlencoded')
});

/**
 * Create a middleware to parse json and urlencoded bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @deprecated
 * @public
 */

function bodyParser(options) {
  var opts = {};

  // exclude type option
  if (options) {
    for (var prop in options) {
      if (prop !== 'type') {
        opts[prop] = options[prop];
      }
    }
  }

  var _urlencoded = exports.urlencoded(opts);
  var _json = exports.json(opts);

  return function bodyParser(req, res, next) {
    _json(req, res, function (err) {
      if (err) return next(err);
      _urlencoded(req, res, next);
    });
  };
}

/**
 * Create a getter for loading a parser.
 * @private
 */

function createParserGetter(name) {
  return function get() {
    return loadParser(name);
  };
}

/**
 * Load a parser module.
 * @private
 */

function loadParser(parserName) {
  var parser = parsers[parserName];

  if (parser !== undefined) {
    return parser;
  }

  // this uses a switch for static require analysis
  switch (parserName) {
    case 'json':
      parser = json_1;
      break;
    case 'raw':
      parser = raw_1;
      break;
    case 'text':
      parser = text_1;
      break;
    case 'urlencoded':
      parser = urlencoded_1;
      break;
  }

  // store to prevent invoking require()
  return parsers[parserName] = parser;
}
});

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var charset = preferredCharsets;
var preferredCharsets_1 = preferredCharsets;

/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */

function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;

  var charset = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var i = 0; i < params.length; i++) {
      var p = params[i].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a charset.
 * @private
 */

function getCharsetPriority(charset, accepted, index) {
  var priority = { o: -1, q: 0, s: 0 };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the charset.
 * @private
 */

function specify(charset, spec, index) {
  var s = 0;
  if (spec.charset.toLowerCase() === charset.toLowerCase()) {
    s |= 1;
  } else if (spec.charset !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */

function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  });

  // sorted list of accepted charsets
  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}

/**
 * Get full charset string.
 * @private
 */

function getFullCharset(spec) {
  return spec.charset;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality(spec) {
  return spec.q > 0;
}
charset.preferredCharsets = preferredCharsets_1;

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var encoding = preferredEncodings;
var preferredEncodings_1 = preferredEncodings;

/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify$1('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */

function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;

  var encoding = match[1];
  var q = 1;
  if (match[2]) {
    var params = match[2].split(';');
    for (var i = 0; i < params.length; i++) {
      var p = params[i].trim().split('=');
      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}

/**
 * Get the priority of an encoding.
 * @private
 */

function getEncodingPriority(encoding, accepted, index) {
  var priority = { o: -1, q: 0, s: 0 };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the encoding.
 * @private
 */

function specify$1(encoding, spec, index) {
  var s = 0;
  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
    s |= 1;
  } else if (spec.encoding !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts.filter(isQuality$1).sort(compareSpecs$1).map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  });

  // sorted list of accepted encodings
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$1(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}

/**
 * Get full encoding string.
 * @private
 */

function getFullEncoding(spec) {
  return spec.encoding;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$1(spec) {
  return spec.q > 0;
}
encoding.preferredEncodings = preferredEncodings_1;

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var language = preferredLanguages;
var preferredLanguages_1 = preferredLanguages;

/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var langauge = parseLanguage(accepts[i].trim(), i);

    if (langauge) {
      accepts[j++] = langauge;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a language from the Accept-Language header.
 * @private
 */

function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;

  var prefix = match[1],
      suffix = match[2],
      full = prefix;

  if (suffix) full += "-" + suffix;

  var q = 1;
  if (match[3]) {
    var params = match[3].split(';');
    for (var i = 0; i < params.length; i++) {
      var p = params[i].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}

/**
 * Get the priority of a language.
 * @private
 */

function getLanguagePriority(language, accepted, index) {
  var priority = { o: -1, q: 0, s: 0 };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the language.
 * @private
 */

function specify$2(language, spec, index) {
  var p = parseLanguage(language);
  if (!p) return null;
  var s = 0;
  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts.filter(isQuality$2).sort(compareSpecs$2).map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  });

  // sorted list of accepted languages
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$2(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}

/**
 * Get full language string.
 * @private
 */

function getFullLanguage(spec) {
  return spec.full;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$2(spec) {
  return spec.q > 0;
}
language.preferredLanguages = preferredLanguages_1;

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var mediaType = preferredMediaTypes;
var preferredMediaTypes_1 = preferredMediaTypes;

/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  }

  // trim accepts
  accepts.length = j;

  return accepts;
}

/**
 * Parse a media type from the Accept header.
 * @private
 */

function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;

  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1];

      // get the value, unwrapping quotes
      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      }

      // store parameter
      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}

/**
 * Get the priority of a media type.
 * @private
 */

function getMediaTypePriority(type, accepted, index) {
  var priority = { o: -1, q: 0, s: 0 };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}

/**
 * Get the specificity of the media type.
 * @private
 */

function specify$3(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4;
  } else if (spec.type != '*') {
    return null;
  }

  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2;
  } else if (spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);
  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1;
    } else {
      return null;
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

/**
 * Get the preferred media types from an Accept header.
 * @public
 */

function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts.filter(isQuality$3).sort(compareSpecs$3).map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  });

  // sorted list of accepted types
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}

/**
 * Compare two specs.
 * @private
 */

function compareSpecs$3(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}

/**
 * Get full type string.
 * @private
 */

function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}

/**
 * Check if a spec has any quality.
 * @private
 */

function isQuality$3(spec) {
  return spec.q > 0;
}

/**
 * Count the number of quotes in a string.
 * @private
 */

function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}

/**
 * Split a key value pair.
 * @private
 */

function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}

/**
 * Split an Accept header into media types.
 * @private
 */

function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  }

  // trim accepts
  accepts.length = j + 1;

  return accepts;
}

/**
 * Split a string of parameters.
 * @private
 */

function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  }

  // trim parameters
  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}
mediaType.preferredMediaTypes = preferredMediaTypes_1;

/**
 * Cached loaded submodules.
 * @private
 */

var modules = Object.create(null);

/**
 * Module exports.
 * @public
 */

var negotiator = Negotiator;
var Negotiator_1 = Negotiator;

/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset$$1(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  var preferredCharsets = loadModule('charset').preferredCharsets;
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding$$1(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  var preferredEncodings = loadModule('encoding').preferredEncodings;
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language$$1(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  var preferredLanguages = loadModule('language').preferredLanguages;
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType$$1(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;
  return preferredMediaTypes(this.request.headers.accept, available);
};

// Backwards compatibility
Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

/**
 * Load the given module.
 * @private
 */

function loadModule(moduleName) {
  var module = modules[moduleName];

  if (module !== undefined) {
    return module;
  }

  // This uses a switch for static require analysis
  switch (moduleName) {
    case 'charset':
      module = charset;
      break;
    case 'encoding':
      module = encoding;
      break;
    case 'language':
      module = language;
      break;
    case 'mediaType':
      module = mediaType;
      break;
    default:
      throw new Error('Cannot find module \'' + moduleName + '\'');
  }

  // Store to prevent invoking require()
  modules[moduleName] = module;

  return module;
}
negotiator.Negotiator = Negotiator_1;

/**
 * Module dependencies.
 * @private
 */




/**
 * Module exports.
 * @public
 */

var accepts = Accepts;

/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts(req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req);
  }

  this.headers = req.headers;
  this.negotiator = new negotiator(req);
}

/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */

Accepts.prototype.type = Accepts.prototype.types = function (types_) {
  var types = types_;

  // support flattened arguments
  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length);
    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i];
    }
  }

  // no types, return all requested types
  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes();
  }

  // no accept header, return first given type
  if (!this.headers.accept) {
    return types[0];
  }

  var mimes = types.map(extToMime);
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first = accepts[0];

  return first ? types[mimes.indexOf(first)] : false;
};

/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_;

  // support flattened arguments
  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length);
    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i];
    }
  }

  // no encodings, return all requested encodings
  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings();
  }

  return this.negotiator.encodings(encodings)[0] || false;
};

/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */

Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_;

  // support flattened arguments
  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length);
    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i];
    }
  }

  // no charsets, return all requested charsets
  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets();
  }

  return this.negotiator.charsets(charsets)[0] || false;
};

/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */

Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
  var languages = languages_;

  // support flattened arguments
  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length);
    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i];
    }
  }

  // no languages, return all requested languages
  if (!languages || languages.length === 0) {
    return this.negotiator.languages();
  }

  return this.negotiator.languages(languages)[0] || false;
};

/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function extToMime(type) {
  return type.indexOf('/') === -1 ? mimeTypes.lookup(type) : type;
}

/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */

function validMime(type) {
  return typeof type === 'string';
}

var safeBuffer = createCommonjsModule(function (module, exports) {
/* eslint-disable node/no-deprecated-api */

var Buffer = _buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = _buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(_buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return _buffer.SlowBuffer(size);
};
});
var safeBuffer_1 = safeBuffer.Buffer;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module variables.
 * @private
 */

var COMPRESSIBLE_TYPE_REGEXP = /^text\/|\+(?:json|text|xml)$/i;
var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;

/**
 * Module exports.
 * @public
 */

var compressible_1 = compressible;

/**
 * Checks if a type is compressible.
 *
 * @param {string} type
 * @return {Boolean} compressible
 * @public
 */

function compressible(type) {
  if (!type || typeof type !== 'string') {
    return false;
  }

  // strip parameters
  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && match[1].toLowerCase();
  var data = mimeDb[mime];

  // return database information
  if (data && data.compressible !== undefined) {
    return data.compressible;
  }

  // fallback to regexp or unknown
  return COMPRESSIBLE_TYPE_REGEXP.test(mime) || undefined;
}

var debug$5 = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$1 = debug$5.coerce;
var debug_2$1 = debug$5.disable;
var debug_3$1 = debug$5.enable;
var debug_4$1 = debug$5.enabled;
var debug_5$1 = debug$5.humanize;
var debug_6$1 = debug$5.names;
var debug_7$1 = debug$5.skips;
var debug_8$1 = debug$5.formatters;

var browser$1 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$5;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$1 = browser$1.log;
var browser_2$1 = browser$1.formatArgs;
var browser_3$1 = browser$1.save;
var browser_4$1 = browser$1.load;
var browser_5$1 = browser$1.useColors;
var browser_6$1 = browser$1.storage;
var browser_7$1 = browser$1.colors;

var node$1 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$5;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$1 = node$1.init;
var node_2$1 = node$1.log;
var node_3$1 = node$1.formatArgs;
var node_4$1 = node$1.save;
var node_5$1 = node$1.load;
var node_6$1 = node$1.useColors;
var node_7$1 = node$1.colors;
var node_8$1 = node$1.inspectOpts;

var src$1 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$1;
} else {
  module.exports = node$1;
}
});

/*!
 * on-headers
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Execute a listener when a response is about to write headers.
 *
 * @param {Object} res
 * @return {Function} listener
 * @api public
 */

var onHeaders = function onHeaders(res, listener) {
  if (!res) {
    throw new TypeError('argument res is required');
  }

  if (typeof listener !== 'function') {
    throw new TypeError('argument listener must be a function');
  }

  res.writeHead = createWriteHead(res.writeHead, listener);
};

function createWriteHead(prevWriteHead, listener) {
  var fired = false;

  // return function with core name and argument list
  return function writeHead(statusCode) {
    // set headers from arguments
    var args = setWriteHeadHeaders.apply(this, arguments);

    // fire listener
    if (!fired) {
      fired = true;
      listener.call(this);

      // pass-along an updated status code
      if (typeof args[0] === 'number' && this.statusCode !== args[0]) {
        args[0] = this.statusCode;
        args.length = 1;
      }
    }

    prevWriteHead.apply(this, args);
  };
}

function setWriteHeadHeaders(statusCode) {
  var length = arguments.length;
  var headerIndex = length > 1 && typeof arguments[1] === 'string' ? 2 : 1;

  var headers = length >= headerIndex + 1 ? arguments[headerIndex] : undefined;

  this.statusCode = statusCode;

  // the following block is from node.js core
  if (Array.isArray(headers)) {
    // handle array case
    for (var i = 0, len = headers.length; i < len; ++i) {
      this.setHeader(headers[i][0], headers[i][1]);
    }
  } else if (headers) {
    // handle object case
    var keys = Object.keys(headers);
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i];
      if (k) this.setHeader(k, headers[k]);
    }
  }

  // copy leading arguments
  var args = new Array(Math.min(length, headerIndex));
  for (var i = 0; i < args.length; i++) {
    args[i] = arguments[i];
  }

  return args;
}

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

var vary_1 = vary;
var append_1 = append;

/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append(header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required');
  }

  if (!field) {
    throw new TypeError('field argument is required');
  }

  // get fields array
  var fields = !Array.isArray(field) ? parse$5(String(field)) : field;

  // assert on invalid field names
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name');
    }
  }

  // existing, unspecified vary
  if (header === '*') {
    return header;
  }

  // enumerate current values
  var val = header;
  var vals = parse$5(header.toLowerCase());

  // unspecified vary
  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*';
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();

    // append value (case-preserving)
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ', ' + fields[i] : fields[i];
    }
  }

  return val;
}

/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */

function parse$5(header) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 0x2c:
        /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }

  // final token
  list.push(header.substring(start, end));

  return list;
}

/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */

function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required');
  }

  // get existing header
  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val) ? val.join(', ') : String(val);

  // set new header
  if (val = append(header, field)) {
    res.setHeader('Vary', val);
  }
}
vary_1.append = append_1;

/**
 * Module dependencies.
 * @private
 */


var Buffer$8 = safeBuffer.Buffer;


var debug$6 = src$1('compression');




/**
 * Module exports.
 */

var compression_1 = compression;
var filter = shouldCompress;

/**
 * Module variables.
 * @private
 */

var cacheControlNoTransformRegExp = /(?:^|,)\s*?no-transform\s*?(?:,|$)/;

/**
 * Compress response data with gzip / deflate.
 *
 * @param {Object} [options]
 * @return {Function} middleware
 * @public
 */

function compression(options) {
  var opts = options || {};

  // options
  var filter = opts.filter || shouldCompress;
  var threshold = bytes_1.parse(opts.threshold);

  if (threshold == null) {
    threshold = 1024;
  }

  return function compression(req, res, next) {
    var ended = false;
    var length;
    var listeners = [];
    var stream;

    var _end = res.end;
    var _on = res.on;
    var _write = res.write;

    // flush
    res.flush = function flush() {
      if (stream) {
        stream.flush();
      }
    };

    // proxy

    res.write = function write(chunk, encoding) {
      if (ended) {
        return false;
      }

      if (!this._header) {
        this._implicitHeader();
      }

      return stream ? stream.write(Buffer$8.from(chunk, encoding)) : _write.call(this, chunk, encoding);
    };

    res.end = function end(chunk, encoding) {
      if (ended) {
        return false;
      }

      if (!this._header) {
        // estimate the length
        if (!this.getHeader('Content-Length')) {
          length = chunkLength(chunk, encoding);
        }

        this._implicitHeader();
      }

      if (!stream) {
        return _end.call(this, chunk, encoding);
      }

      // mark ended
      ended = true;

      // write Buffer for Node.js 0.8
      return chunk ? stream.end(Buffer$8.from(chunk, encoding)) : stream.end();
    };

    res.on = function on(type, listener) {
      if (!listeners || type !== 'drain') {
        return _on.call(this, type, listener);
      }

      if (stream) {
        return stream.on(type, listener);
      }

      // buffer listeners for future stream
      listeners.push([type, listener]);

      return this;
    };

    function nocompress(msg) {
      debug$6('no compression: %s', msg);
      addListeners(res, _on, listeners);
      listeners = null;
    }

    onHeaders(res, function onResponseHeaders() {
      // determine if request is filtered
      if (!filter(req, res)) {
        nocompress('filtered');
        return;
      }

      // determine if the entity should be transformed
      if (!shouldTransform(req, res)) {
        nocompress('no transform');
        return;
      }

      // vary
      vary_1(res, 'Accept-Encoding');

      // content-length below threshold
      if (Number(res.getHeader('Content-Length')) < threshold || length < threshold) {
        nocompress('size below threshold');
        return;
      }

      var encoding = res.getHeader('Content-Encoding') || 'identity';

      // already encoded
      if (encoding !== 'identity') {
        nocompress('already encoded');
        return;
      }

      // head
      if (req.method === 'HEAD') {
        nocompress('HEAD request');
        return;
      }

      // compression method
      var accept = accepts(req);
      var method = accept.encoding(['gzip', 'deflate', 'identity']);

      // we really don't prefer deflate
      if (method === 'deflate' && accept.encoding(['gzip'])) {
        method = accept.encoding(['gzip', 'identity']);
      }

      // negotiation failed
      if (!method || method === 'identity') {
        nocompress('not acceptable');
        return;
      }

      // compression stream
      debug$6('%s compression', method);
      stream = method === 'gzip' ? zlib.createGzip(opts) : zlib.createDeflate(opts);

      // add buffered listeners to stream
      addListeners(stream, stream.on, listeners);

      // header fields
      res.setHeader('Content-Encoding', method);
      res.removeHeader('Content-Length');

      // compression
      stream.on('data', function onStreamData(chunk) {
        if (_write.call(res, chunk) === false) {
          stream.pause();
        }
      });

      stream.on('end', function onStreamEnd() {
        _end.call(res);
      });

      _on.call(res, 'drain', function onResponseDrain() {
        stream.resume();
      });
    });

    next();
  };
}

/**
 * Add bufferred listeners to stream
 * @private
 */

function addListeners(stream, on, listeners) {
  for (var i = 0; i < listeners.length; i++) {
    on.apply(stream, listeners[i]);
  }
}

/**
 * Get the length of a given chunk
 */

function chunkLength(chunk, encoding) {
  if (!chunk) {
    return 0;
  }

  return !Buffer$8.isBuffer(chunk) ? Buffer$8.byteLength(chunk, encoding) : chunk.length;
}

/**
 * Default filter function.
 * @private
 */

function shouldCompress(req, res) {
  var type = res.getHeader('Content-Type');

  if (type === undefined || !compressible_1(type)) {
    debug$6('%s not compressible', type);
    return false;
  }

  return true;
}

/**
 * Determine if the entity should be transformed.
 * @private
 */

function shouldTransform(req, res) {
  var cacheControl = res.getHeader('Cache-Control');

  // Don't compress for Cache-Control: no-transform
  // https://tools.ietf.org/html/rfc7234#section-5.2.2.4
  return !cacheControl || !cacheControlNoTransformRegExp.test(cacheControl);
}
compression_1.filter = filter;

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var parse_1$3 = parse$6;
var serialize_1 = serialize;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
var pairSplitRegExp = /; */;

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse$6(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    // skip things that don't look like key=value
    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim();
    var val = pair.substr(++eq_idx, pair.length).trim();

    // quoted values
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    // only assign once
    if (undefined == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */

function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');
    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

var cookie = {
	parse: parse_1$3,
	serialize: serialize_1
};

var cookieSignature = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */



/**
 * Sign the given `val` with `secret`.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String}
 * @api private
 */

exports.sign = function (val, secret) {
  if ('string' != typeof val) throw new TypeError("Cookie value must be provided as a string.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  return val + '.' + crypto.createHmac('sha256', secret).update(val).digest('base64').replace(/\=+$/, '');
};

/**
 * Unsign and decode the given `val` with `secret`,
 * returning `false` if the signature is invalid.
 *
 * @param {String} val
 * @param {String} secret
 * @return {String|Boolean}
 * @api private
 */

exports.unsign = function (val, secret) {
  if ('string' != typeof val) throw new TypeError("Signed cookie string must be provided.");
  if ('string' != typeof secret) throw new TypeError("Secret string must be provided.");
  var str = val.slice(0, val.lastIndexOf('.')),
      mac = exports.sign(str, secret);

  return sha1(mac) == sha1(val) ? str : false;
};

/**
 * Private
 */

function sha1(str) {
  return crypto.createHash('sha1').update(str).digest('hex');
}
});
var cookieSignature_1 = cookieSignature.sign;
var cookieSignature_2 = cookieSignature.unsign;

/**
 * Module dependencies.
 * @private
 */




/**
 * Module exports.
 * @public
 */

var cookieParser_1 = cookieParser;
var JSONCookie_1 = JSONCookie;
var JSONCookies_1 = JSONCookies;
var signedCookie_1 = signedCookie;
var signedCookies_1 = signedCookies;

/**
 * Parse Cookie header and populate `req.cookies`
 * with an object keyed by the cookie names.
 *
 * @param {string|array} [secret] A string (or array of strings) representing cookie signing secret(s).
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function cookieParser(secret, options) {
  return function cookieParser(req, res, next) {
    if (req.cookies) {
      return next();
    }

    var cookies = req.headers.cookie;
    var secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];

    req.secret = secrets[0];
    req.cookies = Object.create(null);
    req.signedCookies = Object.create(null);

    // no cookies
    if (!cookies) {
      return next();
    }

    req.cookies = cookie.parse(cookies, options);

    // parse signed cookies
    if (secrets.length !== 0) {
      req.signedCookies = signedCookies(req.cookies, secrets);
      req.signedCookies = JSONCookies(req.signedCookies);
    }

    // parse JSON cookies
    req.cookies = JSONCookies(req.cookies);

    next();
  };
}

/**
 * Parse JSON cookie string.
 *
 * @param {String} str
 * @return {Object} Parsed object or undefined if not json cookie
 * @public
 */

function JSONCookie(str) {
  if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') {
    return undefined;
  }

  try {
    return JSON.parse(str.slice(2));
  } catch (err) {
    return undefined;
  }
}

/**
 * Parse JSON cookies.
 *
 * @param {Object} obj
 * @return {Object}
 * @public
 */

function JSONCookies(obj) {
  var cookies = Object.keys(obj);
  var key;
  var val;

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i];
    val = JSONCookie(obj[key]);

    if (val) {
      obj[key] = val;
    }
  }

  return obj;
}

/**
 * Parse a signed cookie string, return the decoded value.
 *
 * @param {String} str signed cookie string
 * @param {string|array} secret
 * @return {String} decoded value
 * @public
 */

function signedCookie(str, secret) {
  if (typeof str !== 'string') {
    return undefined;
  }

  if (str.substr(0, 2) !== 's:') {
    return str;
  }

  var secrets = !secret || Array.isArray(secret) ? secret || [] : [secret];

  for (var i = 0; i < secrets.length; i++) {
    var val = cookieSignature.unsign(str.slice(2), secrets[i]);

    if (val !== false) {
      return val;
    }
  }

  return false;
}

/**
 * Parse signed cookies, returning an object containing the decoded key/value
 * pairs, while removing the signed key from obj.
 *
 * @param {Object} obj
 * @param {string|array} secret
 * @return {Object}
 * @public
 */

function signedCookies(obj, secret) {
  var cookies = Object.keys(obj);
  var dec;
  var key;
  var ret = Object.create(null);
  var val;

  for (var i = 0; i < cookies.length; i++) {
    key = cookies[i];
    val = obj[key];
    dec = signedCookie(val, secret);

    if (val !== dec) {
      ret[key] = dec;
      delete obj[key];
    }
  }

  return ret;
}
cookieParser_1.JSONCookie = JSONCookie_1;
cookieParser_1.JSONCookies = JSONCookies_1;
cookieParser_1.signedCookie = signedCookie_1;
cookieParser_1.signedCookies = signedCookies_1;

var setprototypeof$1 = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf$1 : mixinProperties$1);

function setProtoOf$1(obj, proto) {
	obj.__proto__ = proto;
	return obj;
}

function mixinProperties$1(obj, proto) {
	for (var prop in proto) {
		obj[prop] = proto[prop];
	}
	return obj;
}

var httpErrors$1 = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 * @private
 */





/**
 * Module exports.
 * @public
 */

module.exports = createError;
module.exports.HttpError = createHttpErrorConstructor();

// Populate exports for all constructors
populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);

/**
 * Create a new HTTP Error.
 *
 * @returns {Error}
 * @public
 */

function createError() {
  // so much arity going on ~_~
  var err;
  var msg;
  var status = 500;
  var props = {};
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (arg instanceof Error) {
      err = arg;
      status = err.status || err.statusCode || status;
      continue;
    }
    switch (typeof arg) {
      case 'string':
        msg = arg;
        break;
      case 'number':
        status = arg;
        break;
      case 'object':
        props = arg;
        break;
    }
  }

  if (typeof status !== 'number' || !statuses[status]) {
    status = 500;
  }

  // constructor
  var HttpError = createError[status];

  if (!err) {
    // create error
    err = HttpError ? new HttpError(msg) : new Error(msg || statuses[status]);
    Error.captureStackTrace(err, createError);
  }

  if (!HttpError || !(err instanceof HttpError)) {
    // add properties to generic error
    err.expose = status < 500;
    err.status = err.statusCode = status;
  }

  for (var key in props) {
    if (key !== 'status' && key !== 'statusCode') {
      err[key] = props[key];
    }
  }

  return err;
}

/**
 * Create HTTP error abstract base class.
 * @private
 */

function createHttpErrorConstructor() {
  function HttpError() {
    throw new TypeError('cannot construct abstract class');
  }

  inherits(HttpError, Error);

  return HttpError;
}

/**
 * Create a constructor for a client error.
 * @private
 */

function createClientErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ClientError(message) {
    // create the error object
    var err = new Error(message != null ? message : statuses[code]);

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ClientError);

    // adjust the [[Prototype]]
    setprototypeof$1(err, ClientError.prototype);

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });

    return err;
  }

  inherits(ClientError, HttpError);

  ClientError.prototype.status = code;
  ClientError.prototype.statusCode = code;
  ClientError.prototype.expose = true;

  return ClientError;
}

/**
 * Create a constructor for a server error.
 * @private
 */

function createServerErrorConstructor(HttpError, name, code) {
  var className = name.match(/Error$/) ? name : name + 'Error';

  function ServerError(message) {
    // create the error object
    var err = new Error(message != null ? message : statuses[code]);

    // capture a stack trace to the construction point
    Error.captureStackTrace(err, ServerError);

    // adjust the [[Prototype]]
    setprototypeof$1(err, ServerError.prototype);

    // redefine the error name
    Object.defineProperty(err, 'name', {
      enumerable: false,
      configurable: true,
      value: className,
      writable: true
    });

    return err;
  }

  inherits(ServerError, HttpError);

  ServerError.prototype.status = code;
  ServerError.prototype.statusCode = code;
  ServerError.prototype.expose = false;

  return ServerError;
}

/**
 * Populate the exports object with constructors for every error class.
 * @private
 */

function populateConstructorExports(exports, codes, HttpError) {
  codes.forEach(function forEachCode(code) {
    var CodeError;
    var name = toIdentifier(statuses[code]);

    switch (String(code).charAt(0)) {
      case '4':
        CodeError = createClientErrorConstructor(HttpError, name, code);
        break;
      case '5':
        CodeError = createServerErrorConstructor(HttpError, name, code);
        break;
    }

    if (CodeError) {
      // export the constructor
      exports[code] = CodeError;
      exports[name] = CodeError;
    }
  });

  // backwards-compatibility
  exports["I'mateapot"] = exports.ImATeapot;
}

/**
 * Convert a string of words to a JavaScript identifier.
 * @private
 */

function toIdentifier(str) {
  return str.split(' ').map(function (token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join('').replace(/[^ _0-9a-z]/gi, '');
}
});
var httpErrors_1$1 = httpErrors$1.HttpError;

var rndm = createCommonjsModule(function (module, exports) {
var base62 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
var base36 = 'abcdefghijklmnopqrstuvwxyz0123456789';
var base10 = '0123456789';

exports = module.exports = create(base62);
exports.base62 = exports;
exports.base36 = create(base36);
exports.base10 = create(base10);

exports.create = create;

function create(chars) {
  assert(typeof chars === 'string', 'the list of characters must be a string!');
  var length = Buffer.byteLength(chars);
  return function rndm(len) {
    len = len || 10;
    assert(typeof len === 'number' && len >= 0, 'the length of the random string must be a number!');
    var salt = '';
    for (var i = 0; i < len; i++) salt += chars[Math.floor(length * Math.random())];
    return salt;
  };
}
});
var rndm_1 = rndm.base62;
var rndm_2 = rndm.base36;
var rndm_3 = rndm.base10;
var rndm_4 = rndm.create;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module variables.
 * @private
 */

var generateAttempts = crypto.randomBytes === crypto.pseudoRandomBytes ? 1 : 3;

/**
 * Module exports.
 * @public
 */

var randomBytes_1 = randomBytes;
var sync = randomBytesSync;

/**
 * Generates strong pseudo-random bytes.
 *
 * @param {number} size
 * @param {function} [callback]
 * @return {Promise}
 * @public
 */

function randomBytes(size, callback) {
  // validate callback is a function, if provided
  if (callback !== undefined && typeof callback !== 'function') {
    throw new TypeError('argument callback must be a function');
  }

  // require the callback without promises
  if (!callback && !commonjsGlobal.Promise) {
    throw new TypeError('argument callback is required');
  }

  if (callback) {
    // classic callback style
    return generateRandomBytes(size, generateAttempts, callback);
  }

  return new Promise(function executor(resolve, reject) {
    generateRandomBytes(size, generateAttempts, function onRandomBytes(err, str) {
      if (err) return reject(err);
      resolve(str);
    });
  });
}

/**
 * Generates strong pseudo-random bytes sync.
 *
 * @param {number} size
 * @return {Buffer}
 * @public
 */

function randomBytesSync(size) {
  var err = null;

  for (var i = 0; i < generateAttempts; i++) {
    try {
      return crypto.randomBytes(size);
    } catch (e) {
      err = e;
    }
  }

  throw err;
}

/**
 * Generates strong pseudo-random bytes.
 *
 * @param {number} size
 * @param {number} attempts
 * @param {function} callback
 * @private
 */

function generateRandomBytes(size, attempts, callback) {
  crypto.randomBytes(size, function onRandomBytes(err, buf) {
    if (!err) return callback(null, buf);
    if (! --attempts) return callback(err);
    setTimeout(generateRandomBytes.bind(null, size, attempts, callback), 10);
  });
}
randomBytes_1.sync = sync;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module variables.
 * @private
 */

var EQUAL_GLOBAL_REGEXP = /=/g;
var PLUS_GLOBAL_REGEXP = /\+/g;
var SLASH_GLOBAL_REGEXP = /\//g;

/**
 * Module exports.
 * @public
 */

var uidSafe = uid;
var sync$1 = uidSync;

/**
 * Create a unique ID.
 *
 * @param {number} length
 * @param {function} [callback]
 * @return {Promise}
 * @public
 */

function uid(length, callback) {
  // validate callback is a function, if provided
  if (callback !== undefined && typeof callback !== 'function') {
    throw new TypeError('argument callback must be a function');
  }

  // require the callback without promises
  if (!callback && !commonjsGlobal.Promise) {
    throw new TypeError('argument callback is required');
  }

  if (callback) {
    // classic callback style
    return generateUid(length, callback);
  }

  return new Promise(function executor(resolve, reject) {
    generateUid(length, function onUid(err, str) {
      if (err) return reject(err);
      resolve(str);
    });
  });
}

/**
 * Create a unique ID sync.
 *
 * @param {number} length
 * @return {string}
 * @public
 */

function uidSync(length) {
  return toString(randomBytes_1.sync(length));
}

/**
 * Generate a unique ID string.
 *
 * @param {number} length
 * @param {function} callback
 * @private
 */

function generateUid(length, callback) {
  randomBytes_1(length, function (err, buf) {
    if (err) return callback(err);
    callback(null, toString(buf));
  });
}

/**
 * Change a Buffer into a string.
 *
 * @param {Buffer} buf
 * @return {string}
 * @private
 */

function toString(buf) {
  return buf.toString('base64').replace(PLUS_GLOBAL_REGEXP, '-').replace(SLASH_GLOBAL_REGEXP, '_').replace(EQUAL_GLOBAL_REGEXP, '');
}
uidSafe.sync = sync$1;

// Implements Brad Hill's Double HMAC pattern from
// https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/february/double-hmac-verification/.
// The approach is similar to the node's native implementation of timing safe buffer comparison that will be available on v6+.
// https://github.com/nodejs/node/issues/3043
// https://github.com/nodejs/node/pull/3073



function bufferEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

function timeSafeCompare(a, b) {
  var sa = String(a);
  var sb = String(b);
  var key = crypto.pseudoRandomBytes(32);
  var ah = crypto.createHmac('sha256', key).update(sa).digest();
  var bh = crypto.createHmac('sha256', key).update(sb).digest();

  return bufferEqual(ah, bh) && a === b;
}

var lib$2 = timeSafeCompare;

/**
 * Module dependencies.
 * @private
 */






/**
 * Module variables.
 * @private
 */

var EQUAL_GLOBAL_REGEXP$1 = /=/g;
var PLUS_GLOBAL_REGEXP$1 = /\+/g;
var SLASH_GLOBAL_REGEXP$1 = /\//g;

/**
 * Module exports.
 * @public
 */

var csrf = Tokens;

/**
 * Token generation/verification class.
 *
 * @param {object} [options]
 * @param {number} [options.saltLength=8] The string length of the salt
 * @param {number} [options.secretLength=18] The byte length of the secret key
 * @public
 */

function Tokens(options) {
  if (!(this instanceof Tokens)) {
    return new Tokens(options);
  }

  var opts = options || {};

  var saltLength = opts.saltLength !== undefined ? opts.saltLength : 8;

  if (typeof saltLength !== 'number' || !isFinite(saltLength) || saltLength < 1) {
    throw new TypeError('option saltLength must be finite number > 1');
  }

  var secretLength = opts.secretLength !== undefined ? opts.secretLength : 18;

  if (typeof secretLength !== 'number' || !isFinite(secretLength) || secretLength < 1) {
    throw new TypeError('option secretLength must be finite number > 1');
  }

  this.saltLength = saltLength;
  this.secretLength = secretLength;
}

/**
 * Create a new CSRF token.
 *
 * @param {string} secret The secret for the token.
 * @public
 */

Tokens.prototype.create = function create(secret) {
  if (!secret || typeof secret !== 'string') {
    throw new TypeError('argument secret is required');
  }

  return this._tokenize(secret, rndm(this.saltLength));
};

/**
 * Create a new secret key.
 *
 * @param {function} [callback]
 * @public
 */

Tokens.prototype.secret = function secret(callback) {
  return uidSafe(this.secretLength, callback);
};

/**
 * Create a new secret key synchronously.
 * @public
 */

Tokens.prototype.secretSync = function secretSync() {
  return uidSafe.sync(this.secretLength);
};

/**
 * Tokenize a secret and salt.
 * @private
 */

Tokens.prototype._tokenize = function tokenize(secret, salt) {
  return salt + '-' + hash(salt + '-' + secret);
};

/**
 * Verify if a given token is valid for a given secret.
 *
 * @param {string} secret
 * @param {string} token
 * @public
 */

Tokens.prototype.verify = function verify(secret, token) {
  if (!secret || typeof secret !== 'string') {
    return false;
  }

  if (!token || typeof token !== 'string') {
    return false;
  }

  var index = token.indexOf('-');

  if (index === -1) {
    return false;
  }

  var salt = token.substr(0, index);
  var expected = this._tokenize(secret, salt);

  return lib$2(token, expected);
};

/**
 * Hash a string with SHA1, returning url-safe base64
 * @param {string} str
 * @private
 */

function hash(str) {
  return crypto.createHash('sha1').update(str, 'ascii').digest('base64').replace(PLUS_GLOBAL_REGEXP$1, '-').replace(SLASH_GLOBAL_REGEXP$1, '_').replace(EQUAL_GLOBAL_REGEXP$1, '');
}

/**
 * Module dependencies.
 * @private
 */



var sign = cookieSignature.sign;


/**
 * Module exports.
 * @public
 */

var csurf_1 = csurf;

/**
 * CSRF protection middleware.
 *
 * This middleware adds a `req.csrfToken()` function to make a token
 * which should be added to requests which mutate
 * state, within a hidden form field, query-string etc. This
 * token is validated against the visitor's session.
 *
 * @param {Object} options
 * @return {Function} middleware
 * @public
 */

function csurf(options) {
  var opts = options || {};

  // get cookie options
  var cookie$$1 = getCookieOptions(opts.cookie);

  // get session options
  var sessionKey = opts.sessionKey || 'session';

  // get value getter
  var value = opts.value || defaultValue;

  // token repo
  var tokens = new csrf(opts);

  // ignored methods
  var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods;

  if (!Array.isArray(ignoreMethods)) {
    throw new TypeError('option ignoreMethods must be an array');
  }

  // generate lookup
  var ignoreMethod = getIgnoredMethods(ignoreMethods);

  return function csrf$$1(req, res, next) {
    // validate the configuration against request
    if (!verifyConfiguration(req, sessionKey, cookie$$1)) {
      return next(new Error('misconfigured csrf'));
    }

    // get the secret from the request
    var secret = getSecret(req, sessionKey, cookie$$1);
    var token;

    // lazy-load token getter
    req.csrfToken = function csrfToken() {
      var sec = !cookie$$1 ? getSecret(req, sessionKey, cookie$$1) : secret;

      // use cached token if secret has not changed
      if (token && sec === secret) {
        return token;
      }

      // generate & set new secret
      if (sec === undefined) {
        sec = tokens.secretSync();
        setSecret(req, res, sessionKey, sec, cookie$$1);
      }

      // update changed secret
      secret = sec;

      // create new token
      token = tokens.create(secret);

      return token;
    };

    // generate & set secret
    if (!secret) {
      secret = tokens.secretSync();
      setSecret(req, res, sessionKey, secret, cookie$$1);
    }

    // verify the incoming token
    if (!ignoreMethod[req.method] && !tokens.verify(secret, value(req))) {
      return next(httpErrors$1(403, 'invalid csrf token', {
        code: 'EBADCSRFTOKEN'
      }));
    }

    next();
  };
}

/**
 * Default value function, checking the `req.body`
 * and `req.query` for the CSRF token.
 *
 * @param {IncomingMessage} req
 * @return {String}
 * @api private
 */

function defaultValue(req) {
  return req.body && req.body._csrf || req.query && req.query._csrf || req.headers['csrf-token'] || req.headers['xsrf-token'] || req.headers['x-csrf-token'] || req.headers['x-xsrf-token'];
}

/**
 * Get options for cookie.
 *
 * @param {boolean|object} [options]
 * @returns {object}
 * @api private
 */

function getCookieOptions(options) {
  if (options !== true && typeof options !== 'object') {
    return undefined;
  }

  var opts = {
    key: '_csrf',
    path: '/'
  };

  if (options && typeof options === 'object') {
    for (var prop in options) {
      var val = options[prop];

      if (val !== undefined) {
        opts[prop] = val;
      }
    }
  }

  return opts;
}

/**
 * Get a lookup of ignored methods.
 *
 * @param {array} methods
 * @returns {object}
 * @api private
 */

function getIgnoredMethods(methods) {
  var obj = Object.create(null);

  for (var i = 0; i < methods.length; i++) {
    var method = methods[i].toUpperCase();
    obj[method] = true;
  }

  return obj;
}

/**
 * Get the token secret from the request.
 *
 * @param {IncomingMessage} req
 * @param {String} sessionKey
 * @param {Object} [cookie]
 * @api private
 */

function getSecret(req, sessionKey, cookie$$1) {
  // get the bag & key
  var bag = getSecretBag(req, sessionKey, cookie$$1);
  var key = cookie$$1 ? cookie$$1.key : 'csrfSecret';

  if (!bag) {
    /* istanbul ignore next: should never actually run */
    throw new Error('misconfigured csrf');
  }

  // return secret from bag
  return bag[key];
}

/**
 * Get the token secret bag from the request.
 *
 * @param {IncomingMessage} req
 * @param {String} sessionKey
 * @param {Object} [cookie]
 * @api private
 */

function getSecretBag(req, sessionKey, cookie$$1) {
  if (cookie$$1) {
    // get secret from cookie
    var cookieKey = cookie$$1.signed ? 'signedCookies' : 'cookies';

    return req[cookieKey];
  } else {
    // get secret from session
    return req[sessionKey];
  }
}

/**
 * Set a cookie on the HTTP response.
 *
 * @param {OutgoingMessage} res
 * @param {string} name
 * @param {string} val
 * @param {Object} [options]
 * @api private
 */

function setCookie(res, name, val, options) {
  var data = cookie.serialize(name, val, options);

  var prev = res.getHeader('set-cookie') || [];
  var header = Array.isArray(prev) ? prev.concat(data) : Array.isArray(data) ? [prev].concat(data) : [prev, data];

  res.setHeader('set-cookie', header);
}

/**
 * Set the token secret on the request.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {string} sessionKey
 * @param {string} val
 * @param {Object} [cookie]
 * @api private
 */

function setSecret(req, res, sessionKey, val, cookie$$1) {
  if (cookie$$1) {
    // set secret on cookie
    if (cookie$$1.signed) {
      var secret = req.secret;

      if (!secret) {
        /* istanbul ignore next: should never actually run */
        throw new Error('misconfigured csrf');
      }

      val = 's:' + sign(val, secret);
    }

    setCookie(res, cookie$$1.key, val, cookie$$1);
  } else if (req[sessionKey]) {
    // set secret on session
    req[sessionKey].csrfSecret = val;
  } else {
    /* istanbul ignore next: should never actually run */
    throw new Error('misconfigured csrf');
  }
}

/**
 * Verify the configuration against the request.
 * @private
 */

function verifyConfiguration(req, sessionKey, cookie$$1) {
  if (!getSecretBag(req, sessionKey, cookie$$1)) {
    return false;
  }

  if (cookie$$1 && cookie$$1.signed && !req.secret) {
    return false;
  }

  return true;
}

var debug$7 = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * Active `debug` instances.
 */
exports.instances = [];

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  var prevTime;

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);
  debug.destroy = destroy;

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  exports.instances.push(debug);

  return debug;
}

function destroy() {
  var index = exports.instances.indexOf(this);
  if (index !== -1) {
    exports.instances.splice(index, 1);
    return true;
  } else {
    return false;
  }
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var i;
  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }

  for (i = 0; i < exports.instances.length; i++) {
    var instance = exports.instances[i];
    instance.enabled = exports.enabled(instance.namespace);
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  if (name[name.length - 1] === '*') {
    return true;
  }
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$2 = debug$7.coerce;
var debug_2$2 = debug$7.disable;
var debug_3$2 = debug$7.enable;
var debug_4$2 = debug$7.enabled;
var debug_5$2 = debug$7.humanize;
var debug_6$2 = debug$7.instances;
var debug_7$2 = debug$7.names;
var debug_8$2 = debug$7.skips;
var debug_9 = debug$7.formatters;

var browser$2 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$7;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$2 = browser$2.log;
var browser_2$2 = browser$2.formatArgs;
var browser_3$2 = browser$2.save;
var browser_4$2 = browser$2.load;
var browser_5$2 = browser$2.useColors;
var browser_6$2 = browser$2.storage;
var browser_7$2 = browser$2.colors;

var argv = process.argv;

var terminator = argv.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

var supportsColor = function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
}();

var node$2 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$7;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  var supportsColor$$1 = supportsColor;
  if (supportsColor$$1 && supportsColor$$1.level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (err) {}
// swallow - we only care if `supports-color` is available; it doesn't have to be.


/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = '\u001b[3' + (c < 8 ? c : '8;5;' + c);
    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  } else {
    return new Date().toISOString() + ' ';
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */

function log() {
  return process.stderr.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$2 = node$2.init;
var node_2$2 = node$2.log;
var node_3$2 = node$2.formatArgs;
var node_4$2 = node$2.save;
var node_5$2 = node$2.load;
var node_6$2 = node$2.useColors;
var node_7$2 = node$2.colors;
var node_8$2 = node$2.inspectOpts;

var src$2 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer') {
  module.exports = browser$2;
} else {
  module.exports = node$2;
}
});

/*
 * Parses a string or buffer into an object
 * @param {String|Buffer} src - source to be parsed
 * @returns {Object}
*/
function parse$7(src) {
  var obj = {};

  // convert Buffers before splitting into lines and processing
  src.toString().split('\n').forEach(function (line) {
    // matching "KEY' and 'VAL' in 'KEY=VAL'
    var keyValueArr = line.match(/^\s*([\w\.\-]+)\s*=\s*(.*)?\s*$/);
    // matched?
    if (keyValueArr != null) {
      var key = keyValueArr[1];

      // default undefined or missing values to empty string
      var value = keyValueArr[2] ? keyValueArr[2] : '';

      // expand newlines in quoted values
      var len = value ? value.length : 0;
      if (len > 0 && value.charAt(0) === '"' && value.charAt(len - 1) === '"') {
        value = value.replace(/\\n/gm, '\n');
      }

      // remove any surrounding quotes and extra spaces
      value = value.replace(/(^['"]|['"]$)/g, '').trim();

      obj[key] = value;
    }
  });

  return obj;
}

/*
 * Main entry point into dotenv. Allows configuration before loading .env
 * @param {Object} options - valid options: path ('.env'), encoding ('utf8')
 * @returns {Boolean}
*/
function config(options) {
  var path$$1 = '.env';
  var encoding = 'utf8';

  if (options) {
    if (options.path) {
      path$$1 = options.path;
    }
    if (options.encoding) {
      encoding = options.encoding;
    }
  }

  try {
    // specifying an encoding returns a string instead of a buffer
    var parsedObj = parse$7(fs.readFileSync(path$$1, { encoding: encoding }));

    Object.keys(parsedObj).forEach(function (key) {
      process.env[key] = process.env[key] || parsedObj[key];
    });

    return { parsed: parsedObj };
  } catch (e) {
    return { error: e };
  }
}

var config_1 = config;
var load = config;
var parse_1$4 = parse$7;

var main = {
	config: config_1,
	load: load,
	parse: parse_1$4
};

/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var mergeDescriptors = merge;

/**
 * Module variables.
 * @private
 */

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Merge the property descriptors of `src` into `dest`
 *
 * @param {object} dest Object to add descriptors to
 * @param {object} src Object to clone descriptors from
 * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
 * @returns {object} Reference to dest
 * @public
 */

function merge(dest, src, redefine) {
  if (!dest) {
    throw new TypeError('argument dest is required');
  }

  if (!src) {
    throw new TypeError('argument src is required');
  }

  if (redefine === undefined) {
    // Default to true
    redefine = true;
  }

  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
    if (!redefine && hasOwnProperty.call(dest, name)) {
      // Skip desriptor
      return;
    }

    // Copy descriptor
    var descriptor = Object.getOwnPropertyDescriptor(src, name);
    Object.defineProperty(dest, name, descriptor);
  });

  return dest;
}

var debug$8 = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$3 = debug$8.coerce;
var debug_2$3 = debug$8.disable;
var debug_3$3 = debug$8.enable;
var debug_4$3 = debug$8.enabled;
var debug_5$3 = debug$8.humanize;
var debug_6$3 = debug$8.names;
var debug_7$3 = debug$8.skips;
var debug_8$3 = debug$8.formatters;

var browser$3 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$8;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$3 = browser$3.log;
var browser_2$3 = browser$3.formatArgs;
var browser_3$3 = browser$3.save;
var browser_4$3 = browser$3.load;
var browser_5$3 = browser$3.useColors;
var browser_6$3 = browser$3.storage;
var browser_7$3 = browser$3.colors;

var node$3 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$8;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$3 = node$3.init;
var node_2$3 = node$3.log;
var node_3$3 = node$3.formatArgs;
var node_4$3 = node$3.save;
var node_5$3 = node$3.load;
var node_6$3 = node$3.useColors;
var node_7$3 = node$3.colors;
var node_8$3 = node$3.inspectOpts;

var src$3 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$3;
} else {
  module.exports = node$3;
}
});

/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var encodeurl = encodeUrl;

/**
 * RegExp to match non-URL code points, *after* encoding (i.e. not including "%")
 * and including invalid escape sequences.
 * @private
 */

var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;

/**
 * RegExp to match unmatched surrogate pair.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;

/**
 * String to replace unmatched surrogate pair with.
 * @private
 */

var UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\uFFFD$2';

/**
 * Encode a URL to a percent-encoded form, excluding already-encoded sequences.
 *
 * This function will take an already-encoded URL and encode all the non-URL
 * code points. This function will not encode the "%" character unless it is
 * not part of a valid sequence (`%20` will be left as-is, but `%foo` will
 * be encoded as `%25foo`).
 *
 * This encode is meant to be "safe" and does not throw errors. It will try as
 * hard as it can to properly encode the given URL, including replacing any raw,
 * unpaired surrogate pairs with the Unicode replacement character prior to
 * encoding.
 *
 * @param {string} url
 * @return {string}
 * @public
 */

function encodeUrl(url$$1) {
  return String(url$$1).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

var escapeHtml_1 = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#39;';
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}

/**
 * Module dependencies.
 * @private
 */


var parse$8 = url.parse;
var Url = url.Url;

/**
 * Module exports.
 * @public
 */

var parseurl_1 = parseurl;
var original = originalurl;

/**
 * Parse the `req` url with memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function parseurl(req) {
  var url$$1 = req.url;

  if (url$$1 === undefined) {
    // URL is undefined
    return undefined;
  }

  var parsed = req._parsedUrl;

  if (fresh(url$$1, parsed)) {
    // Return cached URL parse
    return parsed;
  }

  // Parse the URL
  parsed = fastparse(url$$1);
  parsed._raw = url$$1;

  return req._parsedUrl = parsed;
}
/**
 * Parse the `req` original url with fallback and memoization.
 *
 * @param {ServerRequest} req
 * @return {Object}
 * @public
 */

function originalurl(req) {
  var url$$1 = req.originalUrl;

  if (typeof url$$1 !== 'string') {
    // Fallback
    return parseurl(req);
  }

  var parsed = req._parsedOriginalUrl;

  if (fresh(url$$1, parsed)) {
    // Return cached URL parse
    return parsed;
  }

  // Parse the URL
  parsed = fastparse(url$$1);
  parsed._raw = url$$1;

  return req._parsedOriginalUrl = parsed;
}
/**
 * Parse the `str` url with fast-path short-cut.
 *
 * @param {string} str
 * @return {Object}
 * @private
 */

function fastparse(str) {
  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {
      return parse$8(str);
    }

  var pathname = str;
  var query = null;
  var search = null;

  // This takes the regexp from https://github.com/joyent/node/pull/7878
  // Which is /^(\/[^?#\s]*)(\?[^#\s]*)?$/
  // And unrolls it into a for loop
  for (var i = 1; i < str.length; i++) {
    switch (str.charCodeAt(i)) {
      case 0x3f:
        /* ?  */
        if (search === null) {
          pathname = str.substring(0, i);
          query = str.substring(i + 1);
          search = str.substring(i);
        }
        break;
      case 0x09: /* \t */
      case 0x0a: /* \n */
      case 0x0c: /* \f */
      case 0x0d: /* \r */
      case 0x20: /*    */
      case 0x23: /* #  */
      case 0xa0:
      case 0xfeff:
        return parse$8(str);
    }
  }

  var url$$1 = Url !== undefined ? new Url() : {};
  url$$1.path = str;
  url$$1.href = str;
  url$$1.pathname = pathname;
  url$$1.query = query;
  url$$1.search = search;

  return url$$1;
}

/**
 * Determine if parsed is still fresh for url.
 *
 * @param {string} url
 * @param {object} parsedUrl
 * @return {boolean}
 * @private
 */

function fresh(url$$1, parsedUrl) {
  return typeof parsedUrl === 'object' && parsedUrl !== null && (Url === undefined || parsedUrl instanceof Url) && parsedUrl._raw === url$$1;
}
parseurl_1.original = original;

var codes$3 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

var codes$4 = /*#__PURE__*/Object.freeze({
	default: codes$3
});

var codes$5 = ( codes$4 && codes$3 ) || codes$4;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module exports.
 * @public
 */

var statuses$1 = status$1;

// array of status codes
status$1.codes = populateStatusesMap$1(status$1, codes$5);

// status codes for redirects
status$1.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true

  // status codes for empty bodies
};status$1.empty = {
  204: true,
  205: true,
  304: true

  // status codes for when you should retry the request
};status$1.retry = {
  502: true,
  503: true,
  504: true

  /**
   * Populate the statuses map for given codes.
   * @private
   */

};function populateStatusesMap$1(statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode(code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr;
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status$1(code) {
  if (typeof code === 'number') {
    if (!status$1[code]) throw new Error('invalid status code: ' + code);
    return code;
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string');
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status$1[n]) throw new Error('invalid status code: ' + n);
    return n;
  }

  n = status$1[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}

/**
 * Module dependencies.
 * @private
 */

var debug$9 = src$3('finalhandler');







/**
 * Module variables.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;

/* istanbul ignore next */
var defer$1 = typeof setImmediate === 'function' ? setImmediate : function (fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished$1 = onFinished_1.isFinished;

/**
 * Create a minimal HTML document.
 *
 * @param {string} message
 * @private
 */

function createHtmlDocument(message) {
  var body = escapeHtml_1(message).replace(NEWLINE_REGEXP, '<br>').replace(DOUBLE_SPACE_REGEXP, ' &nbsp;');

  return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>Error</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '</html>\n';
}

/**
 * Module exports.
 * @public
 */

var finalhandler_1 = finalhandler;

/**
 * Create a function to handle the final response.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {Object} [options]
 * @return {Function}
 * @public
 */

function finalhandler(req, res, options) {
  var opts = options || {};

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development';

  // get error callback
  var onerror = opts.onerror;

  return function (err) {
    var headers;
    var msg;
    var status;

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug$9('cannot 404 after headers sent');
      return;
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err);

      // respect headers from error
      if (status !== undefined) {
        headers = getErrorHeaders(err);
      }

      // fallback to status code on response
      if (status === undefined) {
        status = getResponseStatusCode(res);
      }

      // get error message
      msg = getErrorMessage(err, status, env);
    } else {
      // not found
      status = 404;
      msg = 'Cannot ' + req.method + ' ' + encodeurl(parseurl_1.original(req).pathname);
    }

    debug$9('default %s', status);

    // schedule onerror callback
    if (err && onerror) {
      defer$1(onerror, err, req, res);
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug$9('cannot %d after headers sent', status);
      req.socket.destroy();
      return;
    }

    // send response
    send(req, res, status, headers, msg);
  };
}

/**
 * Get headers from Error object.
 *
 * @param {Error} err
 * @return {object}
 * @private
 */

function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined;
  }

  var headers = Object.create(null);
  var keys = Object.keys(err.headers);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    headers[key] = err.headers[key];
  }

  return headers;
}

/**
 * Get message from Error object, fallback to status message.
 *
 * @param {Error} err
 * @param {number} status
 * @param {string} env
 * @return {string}
 * @private
 */

function getErrorMessage(err, status, env) {
  var msg;

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack;

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString();
    }
  }

  return msg || statuses$1[status];
}

/**
 * Get status code from Error object.
 *
 * @param {Error} err
 * @return {number}
 * @private
 */

function getErrorStatusCode(err) {
  // check err.status
  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {
    return err.status;
  }

  // check err.statusCode
  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }

  return undefined;
}

/**
 * Get status code from response.
 *
 * @param {OutgoingMessage} res
 * @return {number}
 * @private
 */

function getResponseStatusCode(res) {
  var status = res.statusCode;

  // default status code to 500 if outside valid range
  if (typeof status !== 'number' || status < 400 || status > 599) {
    status = 500;
  }

  return status;
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent(res) {
  return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;
}

/**
 * Send response.
 *
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {number} status
 * @param {object} headers
 * @param {string} message
 * @private
 */

function send(req, res, status, headers, message) {
  function write() {
    // response body
    var body = createHtmlDocument(message);

    // response status
    res.statusCode = status;
    res.statusMessage = statuses$1[status];

    // response headers
    setHeaders(res, headers);

    // security headers
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    res.setHeader('X-Content-Type-Options', 'nosniff');

    // standard headers
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'));

    if (req.method === 'HEAD') {
      res.end();
      return;
    }

    res.end(body, 'utf8');
  }

  if (isFinished$1(req)) {
    write();
    return;
  }

  // unpipe everything from the request
  unpipe_1(req);

  // flush the request
  onFinished_1(req, write);
  req.resume();
}

/**
 * Set response headers from an object.
 *
 * @param {OutgoingMessage} res
 * @param {object} headers
 * @private
 */

function setHeaders(res, headers) {
  if (!headers) {
    return;
  }

  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res.setHeader(key, headers[key]);
  }
}

var debug$a = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$4 = debug$a.coerce;
var debug_2$4 = debug$a.disable;
var debug_3$4 = debug$a.enable;
var debug_4$4 = debug$a.enabled;
var debug_5$4 = debug$a.humanize;
var debug_6$4 = debug$a.names;
var debug_7$4 = debug$a.skips;
var debug_8$4 = debug$a.formatters;

var browser$4 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$a;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$4 = browser$4.log;
var browser_2$4 = browser$4.formatArgs;
var browser_3$4 = browser$4.save;
var browser_4$4 = browser$4.load;
var browser_5$4 = browser$4.useColors;
var browser_6$4 = browser$4.storage;
var browser_7$4 = browser$4.colors;

var node$4 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$a;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$4 = node$4.init;
var node_2$4 = node$4.log;
var node_3$4 = node$4.formatArgs;
var node_4$4 = node$4.save;
var node_5$4 = node$4.load;
var node_6$4 = node$4.useColors;
var node_7$4 = node$4.colors;
var node_8$4 = node$4.inspectOpts;

var src$4 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$4;
} else {
  module.exports = node$4;
}
});

/**
 * Expose `arrayFlatten`.
 */

var arrayFlatten_1 = arrayFlatten;

/**
 * Recursive flatten function with depth.
 *
 * @param  {Array}  array
 * @param  {Array}  result
 * @param  {Number} depth
 * @return {Array}
 */
function flattenWithDepth(array, result, depth) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];

    if (depth > 0 && Array.isArray(value)) {
      flattenWithDepth(value, result, depth - 1);
    } else {
      result.push(value);
    }
  }

  return result;
}

/**
 * Recursive flatten function. Omitting depth is slightly faster.
 *
 * @param  {Array} array
 * @param  {Array} result
 * @return {Array}
 */
function flattenForever(array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];

    if (Array.isArray(value)) {
      flattenForever(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
}

/**
 * Flatten an array, with the ability to define a depth.
 *
 * @param  {Array}  array
 * @param  {Number} depth
 * @return {Array}
 */
function arrayFlatten(array, depth) {
  if (depth == null) {
    return flattenForever(array, []);
  }

  return flattenWithDepth(array, [], depth);
}

/**
 * Expose `pathtoRegexp`.
 */

var pathToRegexp = pathtoRegexp;

/**
 * Match matching groups in a regular expression.
 */
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

function pathtoRegexp(path$$1, keys, options) {
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
  var m;

  if (path$$1 instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path$$1.source)) {
      keys.push({
        name: name++,
        optional: false,
        offset: m.index
      });
    }

    return path$$1;
  }

  if (Array.isArray(path$$1)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path$$1 = path$$1.map(function (value) {
      return pathtoRegexp(value, keys, options).source;
    });

    return new RegExp('(?:' + path$$1.join('|') + ')', flags);
  }

  path$$1 = ('^' + path$$1 + (strict ? '' : path$$1[path$$1.length - 1] === '/' ? '?' : '/?')).replace(/\/\(/g, '/(?:').replace(/([\/\.])/g, '\\$1').replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
    slash = slash || '';
    format = format || '';
    capture = capture || '([^\\/' + format + ']+?)';
    optional = optional || '';

    keys.push({
      name: key,
      optional: !!optional,
      offset: offset + extraOffset
    });

    var result = '' + (optional ? '' : slash) + '(?:' + format + (optional ? slash : '') + capture + (star ? '((?:[\\/' + format + '].+?)?)' : '') + ')' + optional;

    extraOffset += result.length - match.length;

    return result;
  }).replace(/\*/g, function (star, index) {
    var len = keys.length;

    while (len-- > keysOffset && keys[len].offset > index) {
      keys[len].offset += 3; // Replacement length minus asterisk length.
    }

    return '(.*)';
  });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path$$1)) {
    var escapeCount = 0;
    var index = m.index;

    while (path$$1.charAt(--index) === '\\') {
      escapeCount++;
    }

    // It's possible to escape the bracket.
    if (escapeCount % 2 === 1) {
      continue;
    }

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

  // If the path is non-ending, match until the end or a slash.
  path$$1 += end ? '$' : path$$1[path$$1.length - 1] === '/' ? '' : '(?=\\/|$)';

  return new RegExp(path$$1, flags);
}

/**
 * Module dependencies.
 * @private
 */


var debug$b = src$4('express:router:layer');

/**
 * Module variables.
 * @private
 */

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

/**
 * Module exports.
 * @public
 */

var layer = Layer;

function Layer(path$$1, options, fn) {
  if (!(this instanceof Layer)) {
    return new Layer(path$$1, options, fn);
  }

  debug$b('new %o', path$$1);
  var opts = options || {};

  this.handle = fn;
  this.name = fn.name || '<anonymous>';
  this.params = undefined;
  this.path = undefined;
  this.regexp = pathToRegexp(path$$1, this.keys = [], opts);

  // set fast path flags
  this.regexp.fast_star = path$$1 === '*';
  this.regexp.fast_slash = path$$1 === '/' && opts.end === false;
}

/**
 * Handle the error for the layer.
 *
 * @param {Error} error
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_error = function handle_error(error, req, res, next) {
  var fn = this.handle;

  if (fn.length !== 4) {
    // not a standard error handler
    return next(error);
  }

  try {
    fn(error, req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Handle the request for the layer.
 *
 * @param {Request} req
 * @param {Response} res
 * @param {function} next
 * @api private
 */

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length > 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};

/**
 * Check if this route matches `path`, if so
 * populate `.params`.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

Layer.prototype.match = function match(path$$1) {
  var match;

  if (path$$1 != null) {
    // fast path non-ending match for / (any path matches)
    if (this.regexp.fast_slash) {
      this.params = {};
      this.path = '';
      return true;
    }

    // fast path for * (everything matched in a param)
    if (this.regexp.fast_star) {
      this.params = { '0': decode_param(path$$1) };
      this.path = path$$1;
      return true;
    }

    // match the path
    match = this.regexp.exec(path$$1);
  }

  if (!match) {
    this.params = undefined;
    this.path = undefined;
    return false;
  }

  // store values
  this.params = {};
  this.path = match[0];

  var keys = this.keys;
  var params = this.params;

  for (var i = 1; i < match.length; i++) {
    var key = keys[i - 1];
    var prop = key.name;
    var val = decode_param(match[i]);

    if (val !== undefined || !hasOwnProperty$1.call(params, prop)) {
      params[prop] = val;
    }
  }

  return true;
};

/**
 * Decode param value.
 *
 * @param {string} val
 * @return {string}
 * @private
 */

function decode_param(val) {
  if (typeof val !== 'string' || val.length === 0) {
    return val;
  }

  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = 'Failed to decode param \'' + val + '\'';
      err.status = err.statusCode = 400;
    }

    throw err;
  }
}

/**
 * Module dependencies.
 * @private
 */



/**
 * Module exports.
 * @public
 */

var methods = getCurrentNodeMethods() || getBasicNodeMethods();

/**
 * Get the current Node.js methods.
 * @private
 */

function getCurrentNodeMethods() {
  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}

/**
 * Get the "basic" Node.js methods, a snapshot from Node.js 0.10.
 * @private
 */

function getBasicNodeMethods() {
  return ['get', 'post', 'put', 'head', 'delete', 'options', 'trace', 'copy', 'lock', 'mkcol', 'move', 'purge', 'propfind', 'proppatch', 'unlock', 'report', 'mkactivity', 'checkout', 'merge', 'm-search', 'notify', 'subscribe', 'unsubscribe', 'patch', 'search', 'connect'];
}

/**
 * Module dependencies.
 * @private
 */

var debug$c = src$4('express:router:route');




/**
 * Module variables.
 * @private
 */

var slice$1 = Array.prototype.slice;
var toString$1 = Object.prototype.toString;

/**
 * Module exports.
 * @public
 */

var route = Route;

/**
 * Initialize `Route` with the given `path`,
 *
 * @param {String} path
 * @public
 */

function Route(path$$1) {
  this.path = path$$1;
  this.stack = [];

  debug$c('new %o', path$$1);

  // route handlers for various http methods
  this.methods = {};
}

/**
 * Determine if the route handles a given method.
 * @private
 */

Route.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }

  var name = method.toLowerCase();

  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  return Boolean(this.methods[name]);
};

/**
 * @return {Array} supported HTTP methods
 * @private
 */

Route.prototype._options = function _options() {
  var methods$$1 = Object.keys(this.methods);

  // append automatic head
  if (this.methods.get && !this.methods.head) {
    methods$$1.push('head');
  }

  for (var i = 0; i < methods$$1.length; i++) {
    // make upper case
    methods$$1[i] = methods$$1[i].toUpperCase();
  }

  return methods$$1;
};

/**
 * dispatch req, res into this route
 * @private
 */

Route.prototype.dispatch = function dispatch(req, res, done) {
  var idx = 0;
  var stack = this.stack;
  if (stack.length === 0) {
    return done();
  }

  var method = req.method.toLowerCase();
  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  req.route = this;

  next();

  function next(err) {
    // signal to exit route
    if (err && err === 'route') {
      return done();
    }

    // signal to exit router
    if (err && err === 'router') {
      return done(err);
    }

    var layer$$1 = stack[idx++];
    if (!layer$$1) {
      return done(err);
    }

    if (layer$$1.method && layer$$1.method !== method) {
      return next(err);
    }

    if (err) {
      layer$$1.handle_error(err, req, res, next);
    } else {
      layer$$1.handle_request(req, res, next);
    }
  }
};

/**
 * Add a handler for all HTTP verbs to this route.
 *
 * Behaves just like middleware and can respond or call `next`
 * to continue processing.
 *
 * You can use multiple `.all` call to add multiple handlers.
 *
 *   function check_something(req, res, next){
 *     next();
 *   };
 *
 *   function validate_user(req, res, next){
 *     next();
 *   };
 *
 *   route
 *   .all(validate_user)
 *   .all(check_something)
 *   .get(function(req, res, next){
 *     res.send('hello world');
 *   });
 *
 * @param {function} handler
 * @return {Route} for chaining
 * @api public
 */

Route.prototype.all = function all() {
  var handles = arrayFlatten_1(slice$1.call(arguments));

  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    if (typeof handle !== 'function') {
      var type = toString$1.call(handle);
      var msg = 'Route.all() requires a callback function but got a ' + type;
      throw new TypeError(msg);
    }

    var layer$$1 = layer('/', {}, handle);
    layer$$1.method = undefined;

    this.methods._all = true;
    this.stack.push(layer$$1);
  }

  return this;
};

methods.forEach(function (method) {
  Route.prototype[method] = function () {
    var handles = arrayFlatten_1(slice$1.call(arguments));

    for (var i = 0; i < handles.length; i++) {
      var handle = handles[i];

      if (typeof handle !== 'function') {
        var type = toString$1.call(handle);
        var msg = 'Route.' + method + '() requires a callback function but got a ' + type;
        throw new Error(msg);
      }

      debug$c('%s %o', method, this.path);

      var layer$$1 = layer('/', {}, handle);
      layer$$1.method = method;

      this.methods[method] = true;
      this.stack.push(layer$$1);
    }

    return this;
  };
});

var utilsMerge = createCommonjsModule(function (module, exports) {
/**
 * Merge object b with object a.
 *
 *     var a = { foo: 'bar' }
 *       , b = { bar: 'baz' };
 *
 *     merge(a, b);
 *     // => { foo: 'bar', bar: 'baz' }
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object}
 * @api public
 */

exports = module.exports = function (a, b) {
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
};
});

var setprototypeof$2 = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf$2 : mixinProperties$2);

function setProtoOf$2(obj, proto) {
	obj.__proto__ = proto;
	return obj;
}

function mixinProperties$2(obj, proto) {
	for (var prop in proto) {
		if (!obj.hasOwnProperty(prop)) {
			obj[prop] = proto[prop];
		}
	}
	return obj;
}

var router = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 * @private
 */





var debug = src$4('express:router');
var deprecate = depd_1('express');




/**
 * Module variables.
 * @private
 */

var objectRegExp = /^\[object (\S+)\]$/;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} options
 * @return {Router} which is an callable function
 * @public
 */

var proto = module.exports = function (options) {
  var opts = options || {};

  function router(req, res, next) {
    router.handle(req, res, next);
  }

  // mixin Router class functions
  setprototypeof$2(router, proto);

  router.params = {};
  router._params = [];
  router.caseSensitive = opts.caseSensitive;
  router.mergeParams = opts.mergeParams;
  router.strict = opts.strict;
  router.stack = [];

  return router;
};

/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

proto.param = function param(name, fn) {
  // param logic
  if (typeof name === 'function') {
    deprecate('router.param(fn): Refactor to use path params');
    this._params.push(name);
    return;
  }

  // apply param functions
  var params = this._params;
  var len = params.length;
  var ret;

  if (name[0] === ':') {
    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');
    name = name.substr(1);
  }

  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  // ensure we end up with a
  // middleware function
  if ('function' !== typeof fn) {
    throw new Error('invalid param() call for ' + name + ', got ' + fn);
  }

  (this.params[name] = this.params[name] || []).push(fn);
  return this;
};

/**
 * Dispatch a req, res into the router.
 * @private
 */

proto.handle = function handle(req, res, out) {
  var self = this;

  debug('dispatching %s %s', req.method, req.url);

  var idx = 0;
  var protohost = getProtohost(req.url) || '';
  var removed = '';
  var slashAdded = false;
  var paramcalled = {};

  // store options for OPTIONS request
  // only used if OPTIONS request
  var options = [];

  // middleware and routes
  var stack = self.stack;

  // manage inter-router variables
  var parentParams = req.params;
  var parentUrl = req.baseUrl || '';
  var done = restore(out, req, 'baseUrl', 'next', 'params');

  // setup next layer
  req.next = next;

  // for options requests, respond with a default if nothing else responds
  if (req.method === 'OPTIONS') {
    done = wrap(done, function (old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res, options, old);
    });
  }

  // setup basic req values
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  function next(err) {
    var layerError = err === 'route' ? null : err;

    // remove added slash
    if (slashAdded) {
      req.url = req.url.substr(1);
      slashAdded = false;
    }

    // restore altered req.url
    if (removed.length !== 0) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = '';
    }

    // signal to exit router
    if (layerError === 'router') {
      setImmediate(done, null);
      return;
    }

    // no more matching layers
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }

    // get pathname of request
    var path$$1 = getPathname(req);

    if (path$$1 == null) {
      return done(layerError);
    }

    // find next matching layer
    var layer$$1;
    var match;
    var route$$1;

    while (match !== true && idx < stack.length) {
      layer$$1 = stack[idx++];
      match = matchLayer(layer$$1, path$$1);
      route$$1 = layer$$1.route;

      if (typeof match !== 'boolean') {
        // hold on to layerError
        layerError = layerError || match;
      }

      if (match !== true) {
        continue;
      }

      if (!route$$1) {
        // process non-route handlers normally
        continue;
      }

      if (layerError) {
        // routes do not match with a pending error
        match = false;
        continue;
      }

      var method = req.method;
      var has_method = route$$1._handles_method(method);

      // build up automatic options response
      if (!has_method && method === 'OPTIONS') {
        appendMethods(options, route$$1._options());
      }

      // don't even bother matching route
      if (!has_method && method !== 'HEAD') {
        match = false;
        continue;
      }
    }

    // no match
    if (match !== true) {
      return done(layerError);
    }

    // store route for dispatch on change
    if (route$$1) {
      req.route = route$$1;
    }

    // Capture one-time layer values
    req.params = self.mergeParams ? mergeParams(layer$$1.params, parentParams) : layer$$1.params;
    var layerPath = layer$$1.path;

    // this should be done for the layer
    self.process_params(layer$$1, paramcalled, req, res, function (err) {
      if (err) {
        return next(layerError || err);
      }

      if (route$$1) {
        return layer$$1.handle_request(req, res, next);
      }

      trim_prefix(layer$$1, layerError, layerPath, path$$1);
    });
  }

  function trim_prefix(layer$$1, layerError, layerPath, path$$1) {
    if (layerPath.length !== 0) {
      // Validate path breaks on a path separator
      var c = path$$1[layerPath.length];
      if (c && c !== '/' && c !== '.') return next(layerError);

      // Trim off the part of the url that matches the route
      // middleware (.use stuff) needs to have the path stripped
      debug('trim prefix (%s) from url %s', layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // Ensure leading slash
      if (!protohost && req.url[0] !== '/') {
        req.url = '/' + req.url;
        slashAdded = true;
      }

      // Setup base URL (no trailing slash)
      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);
    }

    debug('%s %s : %s', layer$$1.name, layerPath, req.originalUrl);

    if (layerError) {
      layer$$1.handle_error(layerError, req, res, next);
    } else {
      layer$$1.handle_request(req, res, next);
    }
  }
};

/**
 * Process any parameters for the layer.
 * @private
 */

proto.process_params = function process_params(layer$$1, called, req, res, done) {
  var params = this.params;

  // captured parameters from the layer, keys and values
  var keys = layer$$1.keys;

  // fast track
  if (!keys || keys.length === 0) {
    return done();
  }

  var i = 0;
  var name;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;

  // process params in order
  // param callbacks can be async
  function param(err) {
    if (err) {
      return done(err);
    }

    if (i >= keys.length) {
      return done();
    }

    paramIndex = 0;
    key = keys[i++];
    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    if (paramVal === undefined || !paramCallbacks) {
      return param();
    }

    // param previously called with same value or error occurred
    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== 'route')) {
      // restore value
      req.params[name] = paramCalled.value;

      // next param
      return param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  // single param callbacks
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];

    // store updated value
    paramCalled.value = req.params[key.name];

    if (err) {
      // store error
      paramCalled.error = err;
      param(err);
      return;
    }

    if (!fn) return param();

    try {
      fn(req, res, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }

  param();
};

/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @public
 */

proto.use = function use(fn) {
  var offset = 0;
  var path$$1 = '/';

  // default path to '/'
  // disambiguate router.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path$$1 = fn;
    }
  }

  var callbacks = arrayFlatten_1(slice.call(arguments, offset));

  if (callbacks.length === 0) {
    throw new TypeError('Router.use() requires a middleware function');
  }

  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];

    if (typeof fn !== 'function') {
      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn));
    }

    // add the middleware
    debug('use %o %s', path$$1, fn.name || '<anonymous>');

    var layer$$1 = new layer(path$$1, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);

    layer$$1.route = undefined;

    this.stack.push(layer$$1);
  }

  return this;
};

/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @public
 */

proto.route = function route$$1(path$$1) {
  var route$$1 = new route(path$$1);

  var layer$$1 = new layer(path$$1, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route$$1.dispatch.bind(route$$1));

  layer$$1.route = route$$1;

  this.stack.push(layer$$1);
  return route$$1;
};

// create Router#VERB functions
methods.concat('all').forEach(function (method) {
  proto[method] = function (path$$1) {
    var route$$1 = this.route(path$$1);
    route$$1[method].apply(route$$1, slice.call(arguments, 1));
    return this;
  };
});

// append methods to a list of methods
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}

// get pathname of request
function getPathname(req) {
  try {
    return parseurl_1(req).pathname;
  } catch (err) {
    return undefined;
  }
}

// Get get protocol + host for a URL
function getProtohost(url$$1) {
  if (typeof url$$1 !== 'string' || url$$1.length === 0 || url$$1[0] === '/') {
    return undefined;
  }

  var searchIndex = url$$1.indexOf('?');
  var pathLength = searchIndex !== -1 ? searchIndex : url$$1.length;
  var fqdnIndex = url$$1.substr(0, pathLength).indexOf('://');

  return fqdnIndex !== -1 ? url$$1.substr(0, url$$1.indexOf('/', 3 + fqdnIndex)) : undefined;
}

// get type for error message
function gettype(obj) {
  var type = typeof obj;

  if (type !== 'object') {
    return type;
  }

  // inspect [[Class]] for objects
  return toString.call(obj).replace(objectRegExp, '$1');
}

/**
 * Match path to a layer.
 *
 * @param {Layer} layer
 * @param {string} path
 * @private
 */

function matchLayer(layer$$1, path$$1) {
  try {
    return layer$$1.match(path$$1);
  } catch (err) {
    return err;
  }
}

// merge params with parent params
function mergeParams(params, parent) {
  if (typeof parent !== 'object' || !parent) {
    return params;
  }

  // make copy of parent for base
  var obj = utilsMerge({}, parent);

  // simple non-numeric merging
  if (!(0 in params) || !(0 in parent)) {
    return utilsMerge(obj, params);
  }

  var i = 0;
  var o = 0;

  // determine numeric gaps
  while (i in params) {
    i++;
  }

  while (o in parent) {
    o++;
  }

  // offset numeric indices in params before merge
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];

    // create holes for the merge when necessary
    if (i < o) {
      delete params[i];
    }
  }

  return utilsMerge(obj, params);
}

// restore obj props after function
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);

  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }

  return function () {
    // restore vals
    for (var i = 0; i < props.length; i++) {
      obj[props[i]] = vals[i];
    }

    return fn.apply(this, arguments);
  };
}

// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
  try {
    var body = options.join(',');
    res.set('Allow', body);
    res.send(body);
  } catch (err) {
    next(err);
  }
}

// wrap a function
function wrap(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);

    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }

    fn.apply(this, args);
  };
}
});

/**
 * Module dependencies.
 * @private
 */



/**
 * Initialization middleware, exposing the
 * request and response to each other, as well
 * as defaulting the X-Powered-By header field.
 *
 * @param {Function} app
 * @return {Function}
 * @api private
 */

var init_1 = function (app) {
  return function expressInit(req, res, next) {
    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');
    req.res = res;
    res.req = req;
    req.next = next;

    setprototypeof$2(req, app.request);
    setprototypeof$2(res, app.response);

    res.locals = res.locals || Object.create(null);

    next();
  };
};

var init = {
	init: init_1
};

/**
 * Module dependencies.
 */





/**
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var query = function query(options) {
  var opts = utilsMerge({}, options);
  var queryparse = lib$1.parse;

  if (typeof options === 'function') {
    queryparse = options;
    opts = undefined;
  }

  if (opts !== undefined && opts.allowPrototypes === undefined) {
    // back-compat for qs module
    opts.allowPrototypes = true;
  }

  return function query(req, res, next) {
    if (!req.query) {
      var val = parseurl_1(req).query;
      req.query = queryparse(val, opts);
    }

    next();
  };
};

/**
 * Module dependencies.
 * @private
 */

var debug$d = src$4('express:view');
var path$1 = path;


/**
 * Module variables.
 * @private
 */

var dirname = path$1.dirname;
var basename = path$1.basename;
var extname = path$1.extname;
var join = path$1.join;
var resolve = path$1.resolve;

/**
 * Module exports.
 * @public
 */

var view = View;

/**
 * Initialize a new `View` with the given `name`.
 *
 * Options:
 *
 *   - `defaultEngine` the default template engine name
 *   - `engines` template engine require() cache
 *   - `root` root path for view lookup
 *
 * @param {string} name
 * @param {object} options
 * @public
 */

function View(name, options) {
  var opts = options || {};

  this.defaultEngine = opts.defaultEngine;
  this.ext = extname(name);
  this.name = name;
  this.root = opts.root;

  if (!this.ext && !this.defaultEngine) {
    throw new Error('No default engine was specified and no extension was provided.');
  }

  var fileName = name;

  if (!this.ext) {
    // get extension from default engine name
    this.ext = this.defaultEngine[0] !== '.' ? '.' + this.defaultEngine : this.defaultEngine;

    fileName += this.ext;
  }

  if (!opts.engines[this.ext]) {
    // load engine
    var mod = this.ext.substr(1);
    debug$d('require "%s"', mod);

    // default engine export
    var fn = commonjsRequire(mod).__express;

    if (typeof fn !== 'function') {
      throw new Error('Module "' + mod + '" does not provide a view engine.');
    }

    opts.engines[this.ext] = fn;
  }

  // store loaded engine
  this.engine = opts.engines[this.ext];

  // lookup path
  this.path = this.lookup(fileName);
}

/**
 * Lookup view by the given `name`
 *
 * @param {string} name
 * @private
 */

View.prototype.lookup = function lookup(name) {
  var path$$1;
  var roots = [].concat(this.root);

  debug$d('lookup "%s"', name);

  for (var i = 0; i < roots.length && !path$$1; i++) {
    var root = roots[i];

    // resolve the path
    var loc = resolve(root, name);
    var dir = dirname(loc);
    var file = basename(loc);

    // resolve the file
    path$$1 = this.resolve(dir, file);
  }

  return path$$1;
};

/**
 * Render with the given options.
 *
 * @param {object} options
 * @param {function} callback
 * @private
 */

View.prototype.render = function render(options, callback) {
  debug$d('render "%s"', this.path);
  this.engine(this.path, options, callback);
};

/**
 * Resolve the file within the given directory.
 *
 * @param {string} dir
 * @param {string} file
 * @private
 */

View.prototype.resolve = function resolve(dir, file) {
  var ext = this.ext;

  // <path>.<ext>
  var path$$1 = join(dir, file);
  var stat = tryStat(path$$1);

  if (stat && stat.isFile()) {
    return path$$1;
  }

  // <path>/index.<ext>
  path$$1 = join(dir, basename(file, ext), 'index' + ext);
  stat = tryStat(path$$1);

  if (stat && stat.isFile()) {
    return path$$1;
  }
};

/**
 * Return a stat, maybe.
 *
 * @param {string} path
 * @return {fs.Stats}
 * @private
 */

function tryStat(path$$1) {
  debug$d('stat "%s"', path$$1);

  try {
    return fs.statSync(path$$1);
  } catch (e) {
    return undefined;
  }
}

/**
 * Module exports.
 */

var contentDisposition_1 = contentDisposition;
var parse_1$5 = parse$9;

/**
 * Module dependencies.
 */

var basename$1 = path.basename;

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g; // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;

/**
 * RegExp to match non-latin1 characters.
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 */

var QESC_REGEXP$1 = /\\([\u0000-\u007f])/g;

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 */

var QUOTE_REGEXP$1 = /([\\"])/g;

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 */

var PARAM_REGEXP$1 = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g; // eslint-disable-line no-control-regex
var TEXT_REGEXP$1 = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP$1 = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/; // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @param {string} [options.type=attachment]
 * @param {string|boolean} [options.fallback=true]
 * @return {string}
 * @api public
 */

function contentDisposition(filename, options) {
  var opts = options || {};

  // get type
  var type = opts.type || 'attachment';

  // get parameters
  var params = createparams(filename, opts.fallback);

  // format into string
  return format$3(new ContentDisposition(type, params));
}

/**
 * Create parameters object from filename and fallback.
 *
 * @param {string} [filename]
 * @param {string|boolean} [fallback=true]
 * @return {object}
 * @api private
 */

function createparams(filename, fallback) {
  if (filename === undefined) {
    return;
  }

  var params = {};

  if (typeof filename !== 'string') {
    throw new TypeError('filename must be a string');
  }

  // fallback defaults to true
  if (fallback === undefined) {
    fallback = true;
  }

  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {
    throw new TypeError('fallback must be a string or boolean');
  }

  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError('fallback must be ISO-8859-1 string');
  }

  // restrict to file base name
  var name = basename$1(filename);

  // determine if name is suitable for quoted string
  var isQuotedString = TEXT_REGEXP$1.test(name);

  // generate fallback name
  var fallbackName = typeof fallback !== 'string' ? fallback && getlatin1(name) : basename$1(fallback);
  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name;

  // set extended filename parameter
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
    params['filename*'] = name;
  }

  // set filename parameter
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name;
  }

  return params;
}

/**
 * Format object to Content-Disposition header.
 *
 * @param {object} obj
 * @param {string} obj.type
 * @param {object} [obj.parameters]
 * @return {string}
 * @api private
 */

function format$3(obj) {
  var parameters = obj.parameters;
  var type = obj.type;

  if (!type || typeof type !== 'string' || !TOKEN_REGEXP$1.test(type)) {
    throw new TypeError('invalid type');
  }

  // start with normalized type
  var string = String(type).toLowerCase();

  // append parameters
  if (parameters && typeof parameters === 'object') {
    var param;
    var params = Object.keys(parameters).sort();

    for (var i = 0; i < params.length; i++) {
      param = params[i];

      var val = param.substr(-1) === '*' ? ustring(parameters[param]) : qstring$2(parameters[param]);

      string += '; ' + param + '=' + val;
    }
  }

  return string;
}

/**
 * Decode a RFC 6987 field value (gracefully).
 *
 * @param {string} str
 * @return {string}
 * @api private
 */

function decodefield(str) {
  var match = EXT_VALUE_REGEXP.exec(str);

  if (!match) {
    throw new TypeError('invalid extended field value');
  }

  var charset = match[1].toLowerCase();
  var encoded = match[2];
  var value;

  // to binary string
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);

  switch (charset) {
    case 'iso-8859-1':
      value = getlatin1(binary);
      break;
    case 'utf-8':
      value = new Buffer(binary, 'binary').toString('utf8');
      break;
    default:
      throw new TypeError('unsupported charset in extended field');
  }

  return value;
}

/**
 * Get ISO-8859-1 version of string.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function getlatin1(val) {
  // simple Unicode -> ISO-8859-1 transformation
  return String(val).replace(NON_LATIN1_REGEXP, '?');
}

/**
 * Parse Content-Disposition header string.
 *
 * @param {string} string
 * @return {object}
 * @api private
 */

function parse$9(string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required');
  }

  var match = DISPOSITION_TYPE_REGEXP.exec(string);

  if (!match) {
    throw new TypeError('invalid type format');
  }

  // normalize type
  var index = match[0].length;
  var type = match[1].toLowerCase();

  var key;
  var names = [];
  var params = {};
  var value;

  // calculate index to start at
  index = PARAM_REGEXP$1.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index;

  // match parameters
  while (match = PARAM_REGEXP$1.exec(string)) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format');
    }

    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter');
    }

    names.push(key);

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      key = key.slice(0, -1);
      value = decodefield(value);

      // overwrite existing value
      params[key] = value;
      continue;
    }

    if (typeof params[key] === 'string') {
      continue;
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value.substr(1, value.length - 2).replace(QESC_REGEXP$1, '$1');
    }

    params[key] = value;
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format');
  }

  return new ContentDisposition(type, params);
}

/**
 * Percent decode a single character.
 *
 * @param {string} str
 * @param {string} hex
 * @return {string}
 * @api private
 */

function pdecode(str, hex) {
  return String.fromCharCode(parseInt(hex, 16));
}

/**
 * Percent encode a single character.
 *
 * @param {string} char
 * @return {string}
 * @api private
 */

function pencode(char) {
  var hex = String(char).charCodeAt(0).toString(16).toUpperCase();
  return hex.length === 1 ? '%0' + hex : '%' + hex;
}

/**
 * Quote a string for HTTP.
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function qstring$2(val) {
  var str = String(val);

  return '"' + str.replace(QUOTE_REGEXP$1, '\\$1') + '"';
}

/**
 * Encode a Unicode string for HTTP (RFC 5987).
 *
 * @param {string} val
 * @return {string}
 * @api private
 */

function ustring(val) {
  var str = String(val);

  // percent encode as UTF-8
  var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);

  return 'UTF-8\'\'' + encoded;
}

/**
 * Class for parsed Content-Disposition header for v8 optimization
 */

function ContentDisposition(type, parameters) {
  this.type = type;
  this.parameters = parameters;
}
contentDisposition_1.parse = parse_1$5;

var debug$e = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$5 = debug$e.coerce;
var debug_2$5 = debug$e.disable;
var debug_3$5 = debug$e.enable;
var debug_4$5 = debug$e.enabled;
var debug_5$5 = debug$e.humanize;
var debug_6$5 = debug$e.names;
var debug_7$5 = debug$e.skips;
var debug_8$5 = debug$e.formatters;

var browser$5 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$e;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$5 = browser$5.log;
var browser_2$5 = browser$5.formatArgs;
var browser_3$5 = browser$5.save;
var browser_4$5 = browser$5.load;
var browser_5$5 = browser$5.useColors;
var browser_6$5 = browser$5.storage;
var browser_7$5 = browser$5.colors;

var node$5 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$e;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$5 = node$5.init;
var node_2$5 = node$5.log;
var node_3$5 = node$5.formatArgs;
var node_4$5 = node$5.save;
var node_5$5 = node$5.load;
var node_6$5 = node$5.useColors;
var node_7$5 = node$5.colors;
var node_8$5 = node$5.inspectOpts;

var src$5 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$5;
} else {
  module.exports = node$5;
}
});

/**
 * Module dependencies.
 * @private
 */

var ReadStream = fs.ReadStream;


/**
 * Module exports.
 * @public
 */

var destroy_1 = destroy;

/**
 * Destroy a stream.
 *
 * @param {object} stream
 * @public
 */

function destroy(stream) {
  if (stream instanceof ReadStream) {
    return destroyReadStream(stream);
  }

  if (!(stream instanceof require$$1)) {
    return stream;
  }

  if (typeof stream.destroy === 'function') {
    stream.destroy();
  }

  return stream;
}

/**
 * Destroy a ReadStream.
 *
 * @param {object} stream
 * @private
 */

function destroyReadStream(stream) {
  stream.destroy();

  if (typeof stream.close === 'function') {
    // node.js core bug work-around
    stream.on('open', onOpenClose);
  }

  return stream;
}

/**
 * On open handler to close stream.
 * @private
 */

function onOpenClose() {
  if (typeof this.fd === 'number') {
    // actually close down the fd
    this.close();
  }
}

/**
 * Module exports.
 * @public
 */

var etag_1 = etag;

/**
 * Module dependencies.
 * @private
 */


var Stats = fs.Stats;

/**
 * Module variables.
 * @private
 */

var toString$2 = Object.prototype.toString;

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag(entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }

  // compute hash of entity
  var hash = crypto.createHash('sha1').update(entity, 'utf8').digest('base64').substring(0, 27);

  // compute length of entity
  var len = typeof entity === 'string' ? Buffer.byteLength(entity, 'utf8') : entity.length;

  return '"' + len.toString(16) + '-' + hash + '"';
}

/**
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
 * @public
 */

function etag(entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required');
  }

  // support fs.Stats object
  var isStats = isstats(entity);
  var weak = options && typeof options.weak === 'boolean' ? options.weak : isStats;

  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats');
  }

  // generate entity tag
  var tag = isStats ? stattag(entity) : entitytag(entity);

  return weak ? 'W/' + tag : tag;
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats(obj) {
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
    return true;
  }

  // quack quack
  return obj && typeof obj === 'object' && 'ctime' in obj && toString$2.call(obj.ctime) === '[object Date]' && 'mtime' in obj && toString$2.call(obj.mtime) === '[object Date]' && 'ino' in obj && typeof obj.ino === 'number' && 'size' in obj && typeof obj.size === 'number';
}

/**
 * Generate a tag for a stat.
 *
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag(stat) {
  var mtime = stat.mtime.getTime().toString(16);
  var size = stat.size.toString(16);

  return '"' + size + '-' + mtime + '"';
}

/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * RegExp to check for no-cache token in Cache-Control.
 * @private
 */

var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;

/**
 * Module exports.
 * @public
 */

var fresh_1 = fresh$1;

/**
 * Check freshness of the response using request and response headers.
 *
 * @param {Object} reqHeaders
 * @param {Object} resHeaders
 * @return {Boolean}
 * @public
 */

function fresh$1(reqHeaders, resHeaders) {
  // fields
  var modifiedSince = reqHeaders['if-modified-since'];
  var noneMatch = reqHeaders['if-none-match'];

  // unconditional request
  if (!modifiedSince && !noneMatch) {
    return false;
  }

  // Always return stale when Cache-Control: no-cache
  // to support end-to-end reload requests
  // https://tools.ietf.org/html/rfc2616#section-14.9.4
  var cacheControl = reqHeaders['cache-control'];
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false;
  }

  // if-none-match
  if (noneMatch && noneMatch !== '*') {
    var etag = resHeaders['etag'];

    if (!etag) {
      return false;
    }

    var etagStale = true;
    var matches = parseTokenList(noneMatch);
    for (var i = 0; i < matches.length; i++) {
      var match = matches[i];
      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {
        etagStale = false;
        break;
      }
    }

    if (etagStale) {
      return false;
    }
  }

  // if-modified-since
  if (modifiedSince) {
    var lastModified = resHeaders['last-modified'];
    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince));

    if (modifiedStale) {
      return false;
    }
  }

  return true;
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate(date) {
  var timestamp = date && Date.parse(date);

  // istanbul ignore next: guard against date.js Date.parse patching
  return typeof timestamp === 'number' ? timestamp : NaN;
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList(str) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 0x2c:
        /* , */
        list.push(str.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }

  // final token
  list.push(str.substring(start, end));

  return list;
}

var types = {
	"application/andrew-inset": ["ez"],
	"application/applixware": ["aw"],
	"application/atom+xml": ["atom"],
	"application/atomcat+xml": ["atomcat"],
	"application/atomsvc+xml": ["atomsvc"],
	"application/bdoc": ["bdoc"],
	"application/ccxml+xml": ["ccxml"],
	"application/cdmi-capability": ["cdmia"],
	"application/cdmi-container": ["cdmic"],
	"application/cdmi-domain": ["cdmid"],
	"application/cdmi-object": ["cdmio"],
	"application/cdmi-queue": ["cdmiq"],
	"application/cu-seeme": ["cu"],
	"application/dash+xml": ["mpd"],
	"application/davmount+xml": ["davmount"],
	"application/docbook+xml": ["dbk"],
	"application/dssc+der": ["dssc"],
	"application/dssc+xml": ["xdssc"],
	"application/ecmascript": ["ecma"],
	"application/emma+xml": ["emma"],
	"application/epub+zip": ["epub"],
	"application/exi": ["exi"],
	"application/font-tdpfr": ["pfr"],
	"application/font-woff": ["woff"],
	"application/font-woff2": ["woff2"],
	"application/geo+json": ["geojson"],
	"application/gml+xml": ["gml"],
	"application/gpx+xml": ["gpx"],
	"application/gxf": ["gxf"],
	"application/gzip": ["gz"],
	"application/hyperstudio": ["stk"],
	"application/inkml+xml": ["ink", "inkml"],
	"application/ipfix": ["ipfix"],
	"application/java-archive": ["jar", "war", "ear"],
	"application/java-serialized-object": ["ser"],
	"application/java-vm": ["class"],
	"application/javascript": ["js", "mjs"],
	"application/json": ["json", "map"],
	"application/json5": ["json5"],
	"application/jsonml+json": ["jsonml"],
	"application/ld+json": ["jsonld"],
	"application/lost+xml": ["lostxml"],
	"application/mac-binhex40": ["hqx"],
	"application/mac-compactpro": ["cpt"],
	"application/mads+xml": ["mads"],
	"application/manifest+json": ["webmanifest"],
	"application/marc": ["mrc"],
	"application/marcxml+xml": ["mrcx"],
	"application/mathematica": ["ma", "nb", "mb"],
	"application/mathml+xml": ["mathml"],
	"application/mbox": ["mbox"],
	"application/mediaservercontrol+xml": ["mscml"],
	"application/metalink+xml": ["metalink"],
	"application/metalink4+xml": ["meta4"],
	"application/mets+xml": ["mets"],
	"application/mods+xml": ["mods"],
	"application/mp21": ["m21", "mp21"],
	"application/mp4": ["mp4s", "m4p"],
	"application/msword": ["doc", "dot"],
	"application/mxf": ["mxf"],
	"application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
	"application/oda": ["oda"],
	"application/oebps-package+xml": ["opf"],
	"application/ogg": ["ogx"],
	"application/omdoc+xml": ["omdoc"],
	"application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
	"application/oxps": ["oxps"],
	"application/patch-ops-error+xml": ["xer"],
	"application/pdf": ["pdf"],
	"application/pgp-encrypted": ["pgp"],
	"application/pgp-signature": ["asc", "sig"],
	"application/pics-rules": ["prf"],
	"application/pkcs10": ["p10"],
	"application/pkcs7-mime": ["p7m", "p7c"],
	"application/pkcs7-signature": ["p7s"],
	"application/pkcs8": ["p8"],
	"application/pkix-attr-cert": ["ac"],
	"application/pkix-cert": ["cer"],
	"application/pkix-crl": ["crl"],
	"application/pkix-pkipath": ["pkipath"],
	"application/pkixcmp": ["pki"],
	"application/pls+xml": ["pls"],
	"application/postscript": ["ai", "eps", "ps"],
	"application/prs.cww": ["cww"],
	"application/pskc+xml": ["pskcxml"],
	"application/rdf+xml": ["rdf"],
	"application/reginfo+xml": ["rif"],
	"application/relax-ng-compact-syntax": ["rnc"],
	"application/resource-lists+xml": ["rl"],
	"application/resource-lists-diff+xml": ["rld"],
	"application/rls-services+xml": ["rs"],
	"application/rpki-ghostbusters": ["gbr"],
	"application/rpki-manifest": ["mft"],
	"application/rpki-roa": ["roa"],
	"application/rsd+xml": ["rsd"],
	"application/rss+xml": ["rss"],
	"application/rtf": ["rtf"],
	"application/sbml+xml": ["sbml"],
	"application/scvp-cv-request": ["scq"],
	"application/scvp-cv-response": ["scs"],
	"application/scvp-vp-request": ["spq"],
	"application/scvp-vp-response": ["spp"],
	"application/sdp": ["sdp"],
	"application/set-payment-initiation": ["setpay"],
	"application/set-registration-initiation": ["setreg"],
	"application/shf+xml": ["shf"],
	"application/smil+xml": ["smi", "smil"],
	"application/sparql-query": ["rq"],
	"application/sparql-results+xml": ["srx"],
	"application/srgs": ["gram"],
	"application/srgs+xml": ["grxml"],
	"application/sru+xml": ["sru"],
	"application/ssdl+xml": ["ssdl"],
	"application/ssml+xml": ["ssml"],
	"application/tei+xml": ["tei", "teicorpus"],
	"application/thraud+xml": ["tfi"],
	"application/timestamped-data": ["tsd"],
	"application/vnd.3gpp.pic-bw-large": ["plb"],
	"application/vnd.3gpp.pic-bw-small": ["psb"],
	"application/vnd.3gpp.pic-bw-var": ["pvb"],
	"application/vnd.3gpp2.tcap": ["tcap"],
	"application/vnd.3m.post-it-notes": ["pwn"],
	"application/vnd.accpac.simply.aso": ["aso"],
	"application/vnd.accpac.simply.imp": ["imp"],
	"application/vnd.acucobol": ["acu"],
	"application/vnd.acucorp": ["atc", "acutc"],
	"application/vnd.adobe.air-application-installer-package+zip": ["air"],
	"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
	"application/vnd.adobe.fxp": ["fxp", "fxpl"],
	"application/vnd.adobe.xdp+xml": ["xdp"],
	"application/vnd.adobe.xfdf": ["xfdf"],
	"application/vnd.ahead.space": ["ahead"],
	"application/vnd.airzip.filesecure.azf": ["azf"],
	"application/vnd.airzip.filesecure.azs": ["azs"],
	"application/vnd.amazon.ebook": ["azw"],
	"application/vnd.americandynamics.acc": ["acc"],
	"application/vnd.amiga.ami": ["ami"],
	"application/vnd.android.package-archive": ["apk"],
	"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
	"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
	"application/vnd.antix.game-component": ["atx"],
	"application/vnd.apple.installer+xml": ["mpkg"],
	"application/vnd.apple.mpegurl": ["m3u8"],
	"application/vnd.apple.pkpass": ["pkpass"],
	"application/vnd.aristanetworks.swi": ["swi"],
	"application/vnd.astraea-software.iota": ["iota"],
	"application/vnd.audiograph": ["aep"],
	"application/vnd.blueice.multipass": ["mpm"],
	"application/vnd.bmi": ["bmi"],
	"application/vnd.businessobjects": ["rep"],
	"application/vnd.chemdraw+xml": ["cdxml"],
	"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
	"application/vnd.cinderella": ["cdy"],
	"application/vnd.claymore": ["cla"],
	"application/vnd.cloanto.rp9": ["rp9"],
	"application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
	"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
	"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
	"application/vnd.commonspace": ["csp"],
	"application/vnd.contact.cmsg": ["cdbcmsg"],
	"application/vnd.cosmocaller": ["cmc"],
	"application/vnd.crick.clicker": ["clkx"],
	"application/vnd.crick.clicker.keyboard": ["clkk"],
	"application/vnd.crick.clicker.palette": ["clkp"],
	"application/vnd.crick.clicker.template": ["clkt"],
	"application/vnd.crick.clicker.wordbank": ["clkw"],
	"application/vnd.criticaltools.wbs+xml": ["wbs"],
	"application/vnd.ctc-posml": ["pml"],
	"application/vnd.cups-ppd": ["ppd"],
	"application/vnd.curl.car": ["car"],
	"application/vnd.curl.pcurl": ["pcurl"],
	"application/vnd.dart": ["dart"],
	"application/vnd.data-vision.rdz": ["rdz"],
	"application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
	"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
	"application/vnd.dece.unspecified": ["uvx", "uvvx"],
	"application/vnd.dece.zip": ["uvz", "uvvz"],
	"application/vnd.denovo.fcselayout-link": ["fe_launch"],
	"application/vnd.dna": ["dna"],
	"application/vnd.dolby.mlp": ["mlp"],
	"application/vnd.dpgraph": ["dpg"],
	"application/vnd.dreamfactory": ["dfac"],
	"application/vnd.ds-keypoint": ["kpxx"],
	"application/vnd.dvb.ait": ["ait"],
	"application/vnd.dvb.service": ["svc"],
	"application/vnd.dynageo": ["geo"],
	"application/vnd.ecowin.chart": ["mag"],
	"application/vnd.enliven": ["nml"],
	"application/vnd.epson.esf": ["esf"],
	"application/vnd.epson.msf": ["msf"],
	"application/vnd.epson.quickanime": ["qam"],
	"application/vnd.epson.salt": ["slt"],
	"application/vnd.epson.ssf": ["ssf"],
	"application/vnd.eszigno3+xml": ["es3", "et3"],
	"application/vnd.ezpix-album": ["ez2"],
	"application/vnd.ezpix-package": ["ez3"],
	"application/vnd.fdf": ["fdf"],
	"application/vnd.fdsn.mseed": ["mseed"],
	"application/vnd.fdsn.seed": ["seed", "dataless"],
	"application/vnd.flographit": ["gph"],
	"application/vnd.fluxtime.clip": ["ftc"],
	"application/vnd.framemaker": ["fm", "frame", "maker", "book"],
	"application/vnd.frogans.fnc": ["fnc"],
	"application/vnd.frogans.ltf": ["ltf"],
	"application/vnd.fsc.weblaunch": ["fsc"],
	"application/vnd.fujitsu.oasys": ["oas"],
	"application/vnd.fujitsu.oasys2": ["oa2"],
	"application/vnd.fujitsu.oasys3": ["oa3"],
	"application/vnd.fujitsu.oasysgp": ["fg5"],
	"application/vnd.fujitsu.oasysprs": ["bh2"],
	"application/vnd.fujixerox.ddd": ["ddd"],
	"application/vnd.fujixerox.docuworks": ["xdw"],
	"application/vnd.fujixerox.docuworks.binder": ["xbd"],
	"application/vnd.fuzzysheet": ["fzs"],
	"application/vnd.genomatix.tuxedo": ["txd"],
	"application/vnd.geogebra.file": ["ggb"],
	"application/vnd.geogebra.tool": ["ggt"],
	"application/vnd.geometry-explorer": ["gex", "gre"],
	"application/vnd.geonext": ["gxt"],
	"application/vnd.geoplan": ["g2w"],
	"application/vnd.geospace": ["g3w"],
	"application/vnd.gmx": ["gmx"],
	"application/vnd.google-apps.document": ["gdoc"],
	"application/vnd.google-apps.presentation": ["gslides"],
	"application/vnd.google-apps.spreadsheet": ["gsheet"],
	"application/vnd.google-earth.kml+xml": ["kml"],
	"application/vnd.google-earth.kmz": ["kmz"],
	"application/vnd.grafeq": ["gqf", "gqs"],
	"application/vnd.groove-account": ["gac"],
	"application/vnd.groove-help": ["ghf"],
	"application/vnd.groove-identity-message": ["gim"],
	"application/vnd.groove-injector": ["grv"],
	"application/vnd.groove-tool-message": ["gtm"],
	"application/vnd.groove-tool-template": ["tpl"],
	"application/vnd.groove-vcard": ["vcg"],
	"application/vnd.hal+xml": ["hal"],
	"application/vnd.handheld-entertainment+xml": ["zmm"],
	"application/vnd.hbci": ["hbci"],
	"application/vnd.hhe.lesson-player": ["les"],
	"application/vnd.hp-hpgl": ["hpgl"],
	"application/vnd.hp-hpid": ["hpid"],
	"application/vnd.hp-hps": ["hps"],
	"application/vnd.hp-jlyt": ["jlt"],
	"application/vnd.hp-pcl": ["pcl"],
	"application/vnd.hp-pclxl": ["pclxl"],
	"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
	"application/vnd.ibm.minipay": ["mpy"],
	"application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
	"application/vnd.ibm.rights-management": ["irm"],
	"application/vnd.ibm.secure-container": ["sc"],
	"application/vnd.iccprofile": ["icc", "icm"],
	"application/vnd.igloader": ["igl"],
	"application/vnd.immervision-ivp": ["ivp"],
	"application/vnd.immervision-ivu": ["ivu"],
	"application/vnd.insors.igm": ["igm"],
	"application/vnd.intercon.formnet": ["xpw", "xpx"],
	"application/vnd.intergeo": ["i2g"],
	"application/vnd.intu.qbo": ["qbo"],
	"application/vnd.intu.qfx": ["qfx"],
	"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
	"application/vnd.irepository.package+xml": ["irp"],
	"application/vnd.is-xpr": ["xpr"],
	"application/vnd.isac.fcs": ["fcs"],
	"application/vnd.jam": ["jam"],
	"application/vnd.jcp.javame.midlet-rms": ["rms"],
	"application/vnd.jisp": ["jisp"],
	"application/vnd.joost.joda-archive": ["joda"],
	"application/vnd.kahootz": ["ktz", "ktr"],
	"application/vnd.kde.karbon": ["karbon"],
	"application/vnd.kde.kchart": ["chrt"],
	"application/vnd.kde.kformula": ["kfo"],
	"application/vnd.kde.kivio": ["flw"],
	"application/vnd.kde.kontour": ["kon"],
	"application/vnd.kde.kpresenter": ["kpr", "kpt"],
	"application/vnd.kde.kspread": ["ksp"],
	"application/vnd.kde.kword": ["kwd", "kwt"],
	"application/vnd.kenameaapp": ["htke"],
	"application/vnd.kidspiration": ["kia"],
	"application/vnd.kinar": ["kne", "knp"],
	"application/vnd.koan": ["skp", "skd", "skt", "skm"],
	"application/vnd.kodak-descriptor": ["sse"],
	"application/vnd.las.las+xml": ["lasxml"],
	"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
	"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
	"application/vnd.lotus-1-2-3": ["123"],
	"application/vnd.lotus-approach": ["apr"],
	"application/vnd.lotus-freelance": ["pre"],
	"application/vnd.lotus-notes": ["nsf"],
	"application/vnd.lotus-organizer": ["org"],
	"application/vnd.lotus-screencam": ["scm"],
	"application/vnd.lotus-wordpro": ["lwp"],
	"application/vnd.macports.portpkg": ["portpkg"],
	"application/vnd.mcd": ["mcd"],
	"application/vnd.medcalcdata": ["mc1"],
	"application/vnd.mediastation.cdkey": ["cdkey"],
	"application/vnd.mfer": ["mwf"],
	"application/vnd.mfmp": ["mfm"],
	"application/vnd.micrografx.flo": ["flo"],
	"application/vnd.micrografx.igx": ["igx"],
	"application/vnd.mif": ["mif"],
	"application/vnd.mobius.daf": ["daf"],
	"application/vnd.mobius.dis": ["dis"],
	"application/vnd.mobius.mbk": ["mbk"],
	"application/vnd.mobius.mqy": ["mqy"],
	"application/vnd.mobius.msl": ["msl"],
	"application/vnd.mobius.plc": ["plc"],
	"application/vnd.mobius.txf": ["txf"],
	"application/vnd.mophun.application": ["mpn"],
	"application/vnd.mophun.certificate": ["mpc"],
	"application/vnd.mozilla.xul+xml": ["xul"],
	"application/vnd.ms-artgalry": ["cil"],
	"application/vnd.ms-cab-compressed": ["cab"],
	"application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
	"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
	"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
	"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
	"application/vnd.ms-fontobject": ["eot"],
	"application/vnd.ms-htmlhelp": ["chm"],
	"application/vnd.ms-ims": ["ims"],
	"application/vnd.ms-lrm": ["lrm"],
	"application/vnd.ms-officetheme": ["thmx"],
	"application/vnd.ms-outlook": ["msg"],
	"application/vnd.ms-pki.seccat": ["cat"],
	"application/vnd.ms-pki.stl": ["stl"],
	"application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
	"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
	"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
	"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
	"application/vnd.ms-project": ["mpp", "mpt"],
	"application/vnd.ms-word.document.macroenabled.12": ["docm"],
	"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
	"application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
	"application/vnd.ms-wpl": ["wpl"],
	"application/vnd.ms-xpsdocument": ["xps"],
	"application/vnd.mseq": ["mseq"],
	"application/vnd.musician": ["mus"],
	"application/vnd.muvee.style": ["msty"],
	"application/vnd.mynfc": ["taglet"],
	"application/vnd.neurolanguage.nlu": ["nlu"],
	"application/vnd.nitf": ["ntf", "nitf"],
	"application/vnd.noblenet-directory": ["nnd"],
	"application/vnd.noblenet-sealer": ["nns"],
	"application/vnd.noblenet-web": ["nnw"],
	"application/vnd.nokia.n-gage.data": ["ngdat"],
	"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
	"application/vnd.nokia.radio-preset": ["rpst"],
	"application/vnd.nokia.radio-presets": ["rpss"],
	"application/vnd.novadigm.edm": ["edm"],
	"application/vnd.novadigm.edx": ["edx"],
	"application/vnd.novadigm.ext": ["ext"],
	"application/vnd.oasis.opendocument.chart": ["odc"],
	"application/vnd.oasis.opendocument.chart-template": ["otc"],
	"application/vnd.oasis.opendocument.database": ["odb"],
	"application/vnd.oasis.opendocument.formula": ["odf"],
	"application/vnd.oasis.opendocument.formula-template": ["odft"],
	"application/vnd.oasis.opendocument.graphics": ["odg"],
	"application/vnd.oasis.opendocument.graphics-template": ["otg"],
	"application/vnd.oasis.opendocument.image": ["odi"],
	"application/vnd.oasis.opendocument.image-template": ["oti"],
	"application/vnd.oasis.opendocument.presentation": ["odp"],
	"application/vnd.oasis.opendocument.presentation-template": ["otp"],
	"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
	"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
	"application/vnd.oasis.opendocument.text": ["odt"],
	"application/vnd.oasis.opendocument.text-master": ["odm"],
	"application/vnd.oasis.opendocument.text-template": ["ott"],
	"application/vnd.oasis.opendocument.text-web": ["oth"],
	"application/vnd.olpc-sugar": ["xo"],
	"application/vnd.oma.dd2+xml": ["dd2"],
	"application/vnd.openofficeorg.extension": ["oxt"],
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
	"application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
	"application/vnd.osgeo.mapguide.package": ["mgp"],
	"application/vnd.osgi.dp": ["dp"],
	"application/vnd.osgi.subsystem": ["esa"],
	"application/vnd.palm": ["pdb", "pqa", "oprc"],
	"application/vnd.pawaafile": ["paw"],
	"application/vnd.pg.format": ["str"],
	"application/vnd.pg.osasli": ["ei6"],
	"application/vnd.picsel": ["efif"],
	"application/vnd.pmi.widget": ["wg"],
	"application/vnd.pocketlearn": ["plf"],
	"application/vnd.powerbuilder6": ["pbd"],
	"application/vnd.previewsystems.box": ["box"],
	"application/vnd.proteus.magazine": ["mgz"],
	"application/vnd.publishare-delta-tree": ["qps"],
	"application/vnd.pvi.ptid1": ["ptid"],
	"application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
	"application/vnd.realvnc.bed": ["bed"],
	"application/vnd.recordare.musicxml": ["mxl"],
	"application/vnd.recordare.musicxml+xml": ["musicxml"],
	"application/vnd.rig.cryptonote": ["cryptonote"],
	"application/vnd.rim.cod": ["cod"],
	"application/vnd.rn-realmedia": ["rm"],
	"application/vnd.rn-realmedia-vbr": ["rmvb"],
	"application/vnd.route66.link66+xml": ["link66"],
	"application/vnd.sailingtracker.track": ["st"],
	"application/vnd.seemail": ["see"],
	"application/vnd.sema": ["sema"],
	"application/vnd.semd": ["semd"],
	"application/vnd.semf": ["semf"],
	"application/vnd.shana.informed.formdata": ["ifm"],
	"application/vnd.shana.informed.formtemplate": ["itp"],
	"application/vnd.shana.informed.interchange": ["iif"],
	"application/vnd.shana.informed.package": ["ipk"],
	"application/vnd.simtech-mindmapper": ["twd", "twds"],
	"application/vnd.smaf": ["mmf"],
	"application/vnd.smart.teacher": ["teacher"],
	"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
	"application/vnd.spotfire.dxp": ["dxp"],
	"application/vnd.spotfire.sfs": ["sfs"],
	"application/vnd.stardivision.calc": ["sdc"],
	"application/vnd.stardivision.draw": ["sda"],
	"application/vnd.stardivision.impress": ["sdd"],
	"application/vnd.stardivision.math": ["smf"],
	"application/vnd.stardivision.writer": ["sdw", "vor"],
	"application/vnd.stardivision.writer-global": ["sgl"],
	"application/vnd.stepmania.package": ["smzip"],
	"application/vnd.stepmania.stepchart": ["sm"],
	"application/vnd.sun.wadl+xml": ["wadl"],
	"application/vnd.sun.xml.calc": ["sxc"],
	"application/vnd.sun.xml.calc.template": ["stc"],
	"application/vnd.sun.xml.draw": ["sxd"],
	"application/vnd.sun.xml.draw.template": ["std"],
	"application/vnd.sun.xml.impress": ["sxi"],
	"application/vnd.sun.xml.impress.template": ["sti"],
	"application/vnd.sun.xml.math": ["sxm"],
	"application/vnd.sun.xml.writer": ["sxw"],
	"application/vnd.sun.xml.writer.global": ["sxg"],
	"application/vnd.sun.xml.writer.template": ["stw"],
	"application/vnd.sus-calendar": ["sus", "susp"],
	"application/vnd.svd": ["svd"],
	"application/vnd.symbian.install": ["sis", "sisx"],
	"application/vnd.syncml+xml": ["xsm"],
	"application/vnd.syncml.dm+wbxml": ["bdm"],
	"application/vnd.syncml.dm+xml": ["xdm"],
	"application/vnd.tao.intent-module-archive": ["tao"],
	"application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
	"application/vnd.tmobile-livetv": ["tmo"],
	"application/vnd.trid.tpt": ["tpt"],
	"application/vnd.triscape.mxs": ["mxs"],
	"application/vnd.trueapp": ["tra"],
	"application/vnd.ufdl": ["ufd", "ufdl"],
	"application/vnd.uiq.theme": ["utz"],
	"application/vnd.umajin": ["umj"],
	"application/vnd.unity": ["unityweb"],
	"application/vnd.uoml+xml": ["uoml"],
	"application/vnd.vcx": ["vcx"],
	"application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
	"application/vnd.visionary": ["vis"],
	"application/vnd.vsf": ["vsf"],
	"application/vnd.wap.wbxml": ["wbxml"],
	"application/vnd.wap.wmlc": ["wmlc"],
	"application/vnd.wap.wmlscriptc": ["wmlsc"],
	"application/vnd.webturbo": ["wtb"],
	"application/vnd.wolfram.player": ["nbp"],
	"application/vnd.wordperfect": ["wpd"],
	"application/vnd.wqd": ["wqd"],
	"application/vnd.wt.stf": ["stf"],
	"application/vnd.xara": ["xar"],
	"application/vnd.xfdl": ["xfdl"],
	"application/vnd.yamaha.hv-dic": ["hvd"],
	"application/vnd.yamaha.hv-script": ["hvs"],
	"application/vnd.yamaha.hv-voice": ["hvp"],
	"application/vnd.yamaha.openscoreformat": ["osf"],
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
	"application/vnd.yamaha.smaf-audio": ["saf"],
	"application/vnd.yamaha.smaf-phrase": ["spf"],
	"application/vnd.yellowriver-custom-menu": ["cmp"],
	"application/vnd.zul": ["zir", "zirz"],
	"application/vnd.zzazz.deck+xml": ["zaz"],
	"application/voicexml+xml": ["vxml"],
	"application/widget": ["wgt"],
	"application/winhlp": ["hlp"],
	"application/wsdl+xml": ["wsdl"],
	"application/wspolicy+xml": ["wspolicy"],
	"application/x-7z-compressed": ["7z"],
	"application/x-abiword": ["abw"],
	"application/x-ace-compressed": ["ace"],
	"application/x-apple-diskimage": ["dmg"],
	"application/x-arj": ["arj"],
	"application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
	"application/x-authorware-map": ["aam"],
	"application/x-authorware-seg": ["aas"],
	"application/x-bcpio": ["bcpio"],
	"application/x-bdoc": ["bdoc"],
	"application/x-bittorrent": ["torrent"],
	"application/x-blorb": ["blb", "blorb"],
	"application/x-bzip": ["bz"],
	"application/x-bzip2": ["bz2", "boz"],
	"application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
	"application/x-cdlink": ["vcd"],
	"application/x-cfs-compressed": ["cfs"],
	"application/x-chat": ["chat"],
	"application/x-chess-pgn": ["pgn"],
	"application/x-chrome-extension": ["crx"],
	"application/x-cocoa": ["cco"],
	"application/x-conference": ["nsc"],
	"application/x-cpio": ["cpio"],
	"application/x-csh": ["csh"],
	"application/x-debian-package": ["deb", "udeb"],
	"application/x-dgc-compressed": ["dgc"],
	"application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
	"application/x-doom": ["wad"],
	"application/x-dtbncx+xml": ["ncx"],
	"application/x-dtbook+xml": ["dtb"],
	"application/x-dtbresource+xml": ["res"],
	"application/x-dvi": ["dvi"],
	"application/x-envoy": ["evy"],
	"application/x-eva": ["eva"],
	"application/x-font-bdf": ["bdf"],
	"application/x-font-ghostscript": ["gsf"],
	"application/x-font-linux-psf": ["psf"],
	"application/x-font-otf": ["otf"],
	"application/x-font-pcf": ["pcf"],
	"application/x-font-snf": ["snf"],
	"application/x-font-ttf": ["ttf", "ttc"],
	"application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
	"application/x-freearc": ["arc"],
	"application/x-futuresplash": ["spl"],
	"application/x-gca-compressed": ["gca"],
	"application/x-glulx": ["ulx"],
	"application/x-gnumeric": ["gnumeric"],
	"application/x-gramps-xml": ["gramps"],
	"application/x-gtar": ["gtar"],
	"application/x-hdf": ["hdf"],
	"application/x-httpd-php": ["php"],
	"application/x-install-instructions": ["install"],
	"application/x-iso9660-image": ["iso"],
	"application/x-java-archive-diff": ["jardiff"],
	"application/x-java-jnlp-file": ["jnlp"],
	"application/x-latex": ["latex"],
	"application/x-lua-bytecode": ["luac"],
	"application/x-lzh-compressed": ["lzh", "lha"],
	"application/x-makeself": ["run"],
	"application/x-mie": ["mie"],
	"application/x-mobipocket-ebook": ["prc", "mobi"],
	"application/x-ms-application": ["application"],
	"application/x-ms-shortcut": ["lnk"],
	"application/x-ms-wmd": ["wmd"],
	"application/x-ms-wmz": ["wmz"],
	"application/x-ms-xbap": ["xbap"],
	"application/x-msaccess": ["mdb"],
	"application/x-msbinder": ["obd"],
	"application/x-mscardfile": ["crd"],
	"application/x-msclip": ["clp"],
	"application/x-msdos-program": ["exe"],
	"application/x-msdownload": ["exe", "dll", "com", "bat", "msi"],
	"application/x-msmediaview": ["mvb", "m13", "m14"],
	"application/x-msmetafile": ["wmf", "wmz", "emf", "emz"],
	"application/x-msmoney": ["mny"],
	"application/x-mspublisher": ["pub"],
	"application/x-msschedule": ["scd"],
	"application/x-msterminal": ["trm"],
	"application/x-mswrite": ["wri"],
	"application/x-netcdf": ["nc", "cdf"],
	"application/x-ns-proxy-autoconfig": ["pac"],
	"application/x-nzb": ["nzb"],
	"application/x-perl": ["pl", "pm"],
	"application/x-pilot": ["prc", "pdb"],
	"application/x-pkcs12": ["p12", "pfx"],
	"application/x-pkcs7-certificates": ["p7b", "spc"],
	"application/x-pkcs7-certreqresp": ["p7r"],
	"application/x-rar-compressed": ["rar"],
	"application/x-redhat-package-manager": ["rpm"],
	"application/x-research-info-systems": ["ris"],
	"application/x-sea": ["sea"],
	"application/x-sh": ["sh"],
	"application/x-shar": ["shar"],
	"application/x-shockwave-flash": ["swf"],
	"application/x-silverlight-app": ["xap"],
	"application/x-sql": ["sql"],
	"application/x-stuffit": ["sit"],
	"application/x-stuffitx": ["sitx"],
	"application/x-subrip": ["srt"],
	"application/x-sv4cpio": ["sv4cpio"],
	"application/x-sv4crc": ["sv4crc"],
	"application/x-t3vm-image": ["t3"],
	"application/x-tads": ["gam"],
	"application/x-tar": ["tar"],
	"application/x-tcl": ["tcl", "tk"],
	"application/x-tex": ["tex"],
	"application/x-tex-tfm": ["tfm"],
	"application/x-texinfo": ["texinfo", "texi"],
	"application/x-tgif": ["obj"],
	"application/x-ustar": ["ustar"],
	"application/x-virtualbox-hdd": ["hdd"],
	"application/x-virtualbox-ova": ["ova"],
	"application/x-virtualbox-ovf": ["ovf"],
	"application/x-virtualbox-vbox": ["vbox"],
	"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
	"application/x-virtualbox-vdi": ["vdi"],
	"application/x-virtualbox-vhd": ["vhd"],
	"application/x-virtualbox-vmdk": ["vmdk"],
	"application/x-wais-source": ["src"],
	"application/x-web-app-manifest+json": ["webapp"],
	"application/x-x509-ca-cert": ["der", "crt", "pem"],
	"application/x-xfig": ["fig"],
	"application/x-xliff+xml": ["xlf"],
	"application/x-xpinstall": ["xpi"],
	"application/x-xz": ["xz"],
	"application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
	"application/xaml+xml": ["xaml"],
	"application/xcap-diff+xml": ["xdf"],
	"application/xenc+xml": ["xenc"],
	"application/xhtml+xml": ["xhtml", "xht"],
	"application/xml": ["xml", "xsl", "xsd", "rng"],
	"application/xml-dtd": ["dtd"],
	"application/xop+xml": ["xop"],
	"application/xproc+xml": ["xpl"],
	"application/xslt+xml": ["xslt"],
	"application/xspf+xml": ["xspf"],
	"application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
	"application/yang": ["yang"],
	"application/yin+xml": ["yin"],
	"application/zip": ["zip"],
	"audio/3gpp": ["3gpp"],
	"audio/adpcm": ["adp"],
	"audio/basic": ["au", "snd"],
	"audio/midi": ["mid", "midi", "kar", "rmi"],
	"audio/mp3": ["mp3"],
	"audio/mp4": ["m4a", "mp4a"],
	"audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
	"audio/ogg": ["oga", "ogg", "spx"],
	"audio/s3m": ["s3m"],
	"audio/silk": ["sil"],
	"audio/vnd.dece.audio": ["uva", "uvva"],
	"audio/vnd.digital-winds": ["eol"],
	"audio/vnd.dra": ["dra"],
	"audio/vnd.dts": ["dts"],
	"audio/vnd.dts.hd": ["dtshd"],
	"audio/vnd.lucent.voice": ["lvp"],
	"audio/vnd.ms-playready.media.pya": ["pya"],
	"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
	"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
	"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
	"audio/vnd.rip": ["rip"],
	"audio/wav": ["wav"],
	"audio/wave": ["wav"],
	"audio/webm": ["weba"],
	"audio/x-aac": ["aac"],
	"audio/x-aiff": ["aif", "aiff", "aifc"],
	"audio/x-caf": ["caf"],
	"audio/x-flac": ["flac"],
	"audio/x-m4a": ["m4a"],
	"audio/x-matroska": ["mka"],
	"audio/x-mpegurl": ["m3u"],
	"audio/x-ms-wax": ["wax"],
	"audio/x-ms-wma": ["wma"],
	"audio/x-pn-realaudio": ["ram", "ra"],
	"audio/x-pn-realaudio-plugin": ["rmp"],
	"audio/x-realaudio": ["ra"],
	"audio/x-wav": ["wav"],
	"audio/xm": ["xm"],
	"chemical/x-cdx": ["cdx"],
	"chemical/x-cif": ["cif"],
	"chemical/x-cmdf": ["cmdf"],
	"chemical/x-cml": ["cml"],
	"chemical/x-csml": ["csml"],
	"chemical/x-xyz": ["xyz"],
	"font/otf": ["otf"],
	"image/apng": ["apng"],
	"image/bmp": ["bmp"],
	"image/cgm": ["cgm"],
	"image/g3fax": ["g3"],
	"image/gif": ["gif"],
	"image/ief": ["ief"],
	"image/jpeg": ["jpeg", "jpg", "jpe"],
	"image/ktx": ["ktx"],
	"image/png": ["png"],
	"image/prs.btif": ["btif"],
	"image/sgi": ["sgi"],
	"image/svg+xml": ["svg", "svgz"],
	"image/tiff": ["tiff", "tif"],
	"image/vnd.adobe.photoshop": ["psd"],
	"image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
	"image/vnd.djvu": ["djvu", "djv"],
	"image/vnd.dvb.subtitle": ["sub"],
	"image/vnd.dwg": ["dwg"],
	"image/vnd.dxf": ["dxf"],
	"image/vnd.fastbidsheet": ["fbs"],
	"image/vnd.fpx": ["fpx"],
	"image/vnd.fst": ["fst"],
	"image/vnd.fujixerox.edmics-mmr": ["mmr"],
	"image/vnd.fujixerox.edmics-rlc": ["rlc"],
	"image/vnd.ms-modi": ["mdi"],
	"image/vnd.ms-photo": ["wdp"],
	"image/vnd.net-fpx": ["npx"],
	"image/vnd.wap.wbmp": ["wbmp"],
	"image/vnd.xiff": ["xif"],
	"image/webp": ["webp"],
	"image/x-3ds": ["3ds"],
	"image/x-cmu-raster": ["ras"],
	"image/x-cmx": ["cmx"],
	"image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
	"image/x-icon": ["ico"],
	"image/x-jng": ["jng"],
	"image/x-mrsid-image": ["sid"],
	"image/x-ms-bmp": ["bmp"],
	"image/x-pcx": ["pcx"],
	"image/x-pict": ["pic", "pct"],
	"image/x-portable-anymap": ["pnm"],
	"image/x-portable-bitmap": ["pbm"],
	"image/x-portable-graymap": ["pgm"],
	"image/x-portable-pixmap": ["ppm"],
	"image/x-rgb": ["rgb"],
	"image/x-tga": ["tga"],
	"image/x-xbitmap": ["xbm"],
	"image/x-xpixmap": ["xpm"],
	"image/x-xwindowdump": ["xwd"],
	"message/rfc822": ["eml", "mime"],
	"model/gltf+json": ["gltf"],
	"model/gltf-binary": ["glb"],
	"model/iges": ["igs", "iges"],
	"model/mesh": ["msh", "mesh", "silo"],
	"model/vnd.collada+xml": ["dae"],
	"model/vnd.dwf": ["dwf"],
	"model/vnd.gdl": ["gdl"],
	"model/vnd.gtw": ["gtw"],
	"model/vnd.mts": ["mts"],
	"model/vnd.vtu": ["vtu"],
	"model/vrml": ["wrl", "vrml"],
	"model/x3d+binary": ["x3db", "x3dbz"],
	"model/x3d+vrml": ["x3dv", "x3dvz"],
	"model/x3d+xml": ["x3d", "x3dz"],
	"text/cache-manifest": ["appcache", "manifest"],
	"text/calendar": ["ics", "ifb"],
	"text/coffeescript": ["coffee", "litcoffee"],
	"text/css": ["css"],
	"text/csv": ["csv"],
	"text/hjson": ["hjson"],
	"text/html": ["html", "htm", "shtml"],
	"text/jade": ["jade"],
	"text/jsx": ["jsx"],
	"text/less": ["less"],
	"text/markdown": ["markdown", "md"],
	"text/mathml": ["mml"],
	"text/n3": ["n3"],
	"text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
	"text/prs.lines.tag": ["dsc"],
	"text/richtext": ["rtx"],
	"text/rtf": ["rtf"],
	"text/sgml": ["sgml", "sgm"],
	"text/slim": ["slim", "slm"],
	"text/stylus": ["stylus", "styl"],
	"text/tab-separated-values": ["tsv"],
	"text/troff": ["t", "tr", "roff", "man", "me", "ms"],
	"text/turtle": ["ttl"],
	"text/uri-list": ["uri", "uris", "urls"],
	"text/vcard": ["vcard"],
	"text/vnd.curl": ["curl"],
	"text/vnd.curl.dcurl": ["dcurl"],
	"text/vnd.curl.mcurl": ["mcurl"],
	"text/vnd.curl.scurl": ["scurl"],
	"text/vnd.dvb.subtitle": ["sub"],
	"text/vnd.fly": ["fly"],
	"text/vnd.fmi.flexstor": ["flx"],
	"text/vnd.graphviz": ["gv"],
	"text/vnd.in3d.3dml": ["3dml"],
	"text/vnd.in3d.spot": ["spot"],
	"text/vnd.sun.j2me.app-descriptor": ["jad"],
	"text/vnd.wap.wml": ["wml"],
	"text/vnd.wap.wmlscript": ["wmls"],
	"text/vtt": ["vtt"],
	"text/x-asm": ["s", "asm"],
	"text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
	"text/x-component": ["htc"],
	"text/x-fortran": ["f", "for", "f77", "f90"],
	"text/x-handlebars-template": ["hbs"],
	"text/x-java-source": ["java"],
	"text/x-lua": ["lua"],
	"text/x-markdown": ["mkd"],
	"text/x-nfo": ["nfo"],
	"text/x-opml": ["opml"],
	"text/x-org": ["org"],
	"text/x-pascal": ["p", "pas"],
	"text/x-processing": ["pde"],
	"text/x-sass": ["sass"],
	"text/x-scss": ["scss"],
	"text/x-setext": ["etx"],
	"text/x-sfv": ["sfv"],
	"text/x-suse-ymp": ["ymp"],
	"text/x-uuencode": ["uu"],
	"text/x-vcalendar": ["vcs"],
	"text/x-vcard": ["vcf"],
	"text/xml": ["xml"],
	"text/yaml": ["yaml", "yml"],
	"video/3gpp": ["3gp", "3gpp"],
	"video/3gpp2": ["3g2"],
	"video/h261": ["h261"],
	"video/h263": ["h263"],
	"video/h264": ["h264"],
	"video/jpeg": ["jpgv"],
	"video/jpm": ["jpm", "jpgm"],
	"video/mj2": ["mj2", "mjp2"],
	"video/mp2t": ["ts"],
	"video/mp4": ["mp4", "mp4v", "mpg4"],
	"video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
	"video/ogg": ["ogv"],
	"video/quicktime": ["qt", "mov"],
	"video/vnd.dece.hd": ["uvh", "uvvh"],
	"video/vnd.dece.mobile": ["uvm", "uvvm"],
	"video/vnd.dece.pd": ["uvp", "uvvp"],
	"video/vnd.dece.sd": ["uvs", "uvvs"],
	"video/vnd.dece.video": ["uvv", "uvvv"],
	"video/vnd.dvb.file": ["dvb"],
	"video/vnd.fvt": ["fvt"],
	"video/vnd.mpegurl": ["mxu", "m4u"],
	"video/vnd.ms-playready.media.pyv": ["pyv"],
	"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
	"video/vnd.vivo": ["viv"],
	"video/webm": ["webm"],
	"video/x-f4v": ["f4v"],
	"video/x-fli": ["fli"],
	"video/x-flv": ["flv"],
	"video/x-m4v": ["m4v"],
	"video/x-matroska": ["mkv", "mk3d", "mks"],
	"video/x-mng": ["mng"],
	"video/x-ms-asf": ["asf", "asx"],
	"video/x-ms-vob": ["vob"],
	"video/x-ms-wm": ["wm"],
	"video/x-ms-wmv": ["wmv"],
	"video/x-ms-wmx": ["wmx"],
	"video/x-ms-wvx": ["wvx"],
	"video/x-msvideo": ["avi"],
	"video/x-sgi-movie": ["movie"],
	"video/x-smv": ["smv"],
	"x-conference/x-cooltalk": ["ice"]
};

var types$1 = /*#__PURE__*/Object.freeze({
	default: types
});

var require$$0$3 = ( types$1 && types ) || types$1;

function Mime() {
  // Map of extension -> mime type
  this.types = Object.create(null);

  // Map of mime type -> extension
  this.extensions = Object.create(null);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */
Mime.prototype.define = function (map) {
  for (var type in map) {
    var exts = map[type];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ''), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + ' to ' + type);
      }

      this.types[exts[i]] = type;
    }

    // Default extension is the first one we encounter
    if (!this.extensions[type]) {
      this.extensions[type] = exts[0];
    }
  }
};

/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */
Mime.prototype.load = function (file) {
  this._loading = file;
  // Read file and split into lines
  var map = {},
      content = fs.readFileSync(file, 'ascii'),
      lines = content.split(/[\r\n]+/);

  lines.forEach(function (line) {
    // Clean up whitespace/comments, and split into fields
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, '').split(/\s+/);
    map[fields.shift()] = fields;
  });

  this.define(map);

  this._loading = null;
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.lookup = function (path$$1, fallback) {
  var ext = path$$1.replace(/^.*[\.\/\\]/, '').toLowerCase();

  return this.types[ext] || fallback || this.default_type;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.extension = function (mimeType) {
  var type = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type];
};

// Default instance
var mime = new Mime();

// Define built-in types
mime.define(require$$0$3);

// Default type
mime.default_type = mime.lookup('bin');

//
// Additional API specific to the default instance
//

mime.Mime = Mime;

/**
 * Lookup a charset based on mime type.
 */
mime.charsets = {
  lookup: function (mimeType, fallback) {
    // Assume text types are utf8
    return (/^text\/|^application\/(javascript|json)/.test(mimeType) ? 'UTF-8' : fallback
    );
  }
};

var mime_1 = mime;

/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var rangeParser_1 = rangeParser;

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser(size, str, options) {
  var index = str.indexOf('=');

  if (index === -1) {
    return -2;
  }

  // split the range string
  var arr = str.slice(index + 1).split(',');
  var ranges = [];

  // add ranges type
  ranges.type = str.slice(0, index);

  // parse all ranges
  for (var i = 0; i < arr.length; i++) {
    var range = arr[i].split('-');
    var start = parseInt(range[0], 10);
    var end = parseInt(range[1], 10);

    // -nnn
    if (isNaN(start)) {
      start = size - end;
      end = size - 1;
      // nnn-
    } else if (isNaN(end)) {
      end = size - 1;
    }

    // limit last-byte-pos to current length
    if (end > size - 1) {
      end = size - 1;
    }

    // invalid or unsatisifiable
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue;
    }

    // add range
    ranges.push({
      start: start,
      end: end
    });
  }

  if (ranges.length < 1) {
    // unsatisifiable
    return -1;
  }

  return options && options.combine ? combineRanges(ranges) : ranges;
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);

  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i];
    var current = ordered[j];

    if (range.start > current.end + 1) {
      // next range
      ordered[++j] = range;
    } else if (range.end > current.end) {
      // extend range
      current.end = range.end;
      current.index = Math.min(current.index, range.index);
    }
  }

  // trim ordered array
  ordered.length = j + 1;

  // generate combined range
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);

  // copy ranges type
  combined.type = ranges.type;

  return combined;
}

/**
 * Map function to add index value to ranges.
 * @private
 */

function mapWithIndex(range, index) {
  return {
    start: range.start,
    end: range.end,
    index: index
  };
}

/**
 * Map function to remove index value from ranges.
 * @private
 */

function mapWithoutIndex(range) {
  return {
    start: range.start,
    end: range.end
  };
}

/**
 * Sort function to sort ranges by index.
 * @private
 */

function sortByRangeIndex(a, b) {
  return a.index - b.index;
}

/**
 * Sort function to sort ranges by start position.
 * @private
 */

function sortByRangeStart(a, b) {
  return a.start - b.start;
}

var codes$6 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

var codes$7 = /*#__PURE__*/Object.freeze({
	default: codes$6
});

var codes$8 = ( codes$7 && codes$6 ) || codes$7;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module exports.
 * @public
 */

var statuses$2 = status$2;

// array of status codes
status$2.codes = populateStatusesMap$2(status$2, codes$8);

// status codes for redirects
status$2.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true

  // status codes for empty bodies
};status$2.empty = {
  204: true,
  205: true,
  304: true

  // status codes for when you should retry the request
};status$2.retry = {
  502: true,
  503: true,
  504: true

  /**
   * Populate the statuses map for given codes.
   * @private
   */

};function populateStatusesMap$2(statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode(code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr;
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status$2(code) {
  if (typeof code === 'number') {
    if (!status$2[code]) throw new Error('invalid status code: ' + code);
    return code;
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string');
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status$2[n]) throw new Error('invalid status code: ' + n);
    return n;
  }

  n = status$2[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}

/**
 * Module dependencies.
 * @private
 */


var debug$f = src$5('send');
var deprecate$1 = depd_1('send');










var path$2 = path;




/**
 * Path function references.
 * @private
 */

var extname$1 = path$2.extname;
var join$1 = path$2.join;
var normalize$1 = path$2.normalize;
var resolve$1 = path$2.resolve;
var sep = path$2.sep;

/**
 * Regular expression for identifying a bytes Range header.
 * @private
 */

var BYTES_RANGE_REGEXP = /^ *bytes=/;

/**
 * Maximum value allowed for the max age.
 * @private
 */

var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000; // 1 year

/**
 * Regular expression to match a path with a directory up component.
 * @private
 */

var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;

/**
 * Module exports.
 * @public
 */

var send_1 = send$1;
var mime_1$1 = mime_1;

/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {object} req
 * @param {string} path
 * @param {object} [options]
 * @return {SendStream}
 * @public
 */

function send$1(req, path$$1, options) {
  return new SendStream(req, path$$1, options);
}

/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {object} [options]
 * @private
 */

function SendStream(req, path$$1, options) {
  require$$1.call(this);

  var opts = options || {};

  this.options = opts;
  this.path = path$$1;
  this.req = req;

  this._acceptRanges = opts.acceptRanges !== undefined ? Boolean(opts.acceptRanges) : true;

  this._cacheControl = opts.cacheControl !== undefined ? Boolean(opts.cacheControl) : true;

  this._etag = opts.etag !== undefined ? Boolean(opts.etag) : true;

  this._dotfiles = opts.dotfiles !== undefined ? opts.dotfiles : 'ignore';

  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  }

  this._hidden = Boolean(opts.hidden);

  if (opts.hidden !== undefined) {
    deprecate$1('hidden: use dotfiles: \'' + (this._hidden ? 'allow' : 'ignore') + '\' instead');
  }

  // legacy support
  if (opts.dotfiles === undefined) {
    this._dotfiles = undefined;
  }

  this._extensions = opts.extensions !== undefined ? normalizeList(opts.extensions, 'extensions option') : [];

  this._immutable = opts.immutable !== undefined ? Boolean(opts.immutable) : false;

  this._index = opts.index !== undefined ? normalizeList(opts.index, 'index option') : ['index.html'];

  this._lastModified = opts.lastModified !== undefined ? Boolean(opts.lastModified) : true;

  this._maxage = opts.maxAge || opts.maxage;
  this._maxage = typeof this._maxage === 'string' ? ms(this._maxage) : Number(this._maxage);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;

  this._root = opts.root ? resolve$1(opts.root) : null;

  if (!this._root && opts.from) {
    this.from(opts.from);
  }
}

/**
 * Inherits from `Stream`.
 */

util.inherits(SendStream, require$$1);

/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.etag = deprecate$1.function(function etag(val) {
  this._etag = Boolean(val);
  debug$f('etag %s', this._etag);
  return this;
}, 'send.etag: pass etag as option');

/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.hidden = deprecate$1.function(function hidden(val) {
  this._hidden = Boolean(val);
  this._dotfiles = undefined;
  debug$f('hidden %s', this._hidden);
  return this;
}, 'send.hidden: use dotfiles option');

/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.index = deprecate$1.function(function index(paths) {
  var index = !paths ? [] : normalizeList(paths, 'paths argument');
  debug$f('index %o', paths);
  this._index = index;
  return this;
}, 'send.index: pass index as option');

/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.root = function root(path$$1) {
  this._root = resolve$1(String(path$$1));
  debug$f('root %s', this._root);
  return this;
};

SendStream.prototype.from = deprecate$1.function(SendStream.prototype.root, 'send.from: pass root as option');

SendStream.prototype.root = deprecate$1.function(SendStream.prototype.root, 'send.root: pass root as option');

/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */

SendStream.prototype.maxage = deprecate$1.function(function maxage(maxAge) {
  this._maxage = typeof maxAge === 'string' ? ms(maxAge) : Number(maxAge);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  debug$f('max-age %d', this._maxage);
  return this;
}, 'send.maxage: pass maxAge as option');

/**
 * Emit error with `status`.
 *
 * @param {number} status
 * @param {Error} [err]
 * @private
 */

SendStream.prototype.error = function error(status, err) {
  // emit if listeners instead of responding
  if (hasListeners(this, 'error')) {
    return this.emit('error', httpErrors(status, err, {
      expose: false
    }));
  }

  var res = this.res;
  var msg = statuses$2[status] || String(status);
  var doc = createHtmlDocument$1('Error', escapeHtml_1(msg));

  // clear existing headers
  clearHeaders(res);

  // add error headers
  if (err && err.headers) {
    setHeaders$1(res, err.headers);
  }

  // send basic response
  res.statusCode = status;
  res.setHeader('Content-Type', 'text/html; charset=UTF-8');
  res.setHeader('Content-Length', Buffer.byteLength(doc));
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.end(doc);
};

/**
 * Check if the pathname ends with "/".
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
  return this.path[this.path.length - 1] === '/';
};

/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isConditionalGET = function isConditionalGET() {
  return this.req.headers['if-match'] || this.req.headers['if-unmodified-since'] || this.req.headers['if-none-match'] || this.req.headers['if-modified-since'];
};

/**
 * Check if the request preconditions failed.
 *
 * @return {boolean}
 * @private
 */

SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
  var req = this.req;
  var res = this.res;

  // if-match
  var match = req.headers['if-match'];
  if (match) {
    var etag = res.getHeader('ETag');
    return !etag || match !== '*' && parseTokenList$1(match).every(function (match) {
      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag;
    });
  }

  // if-unmodified-since
  var unmodifiedSince = parseHttpDate$1(req.headers['if-unmodified-since']);
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate$1(res.getHeader('Last-Modified'));
    return isNaN(lastModified) || lastModified > unmodifiedSince;
  }

  return false;
};

/**
 * Strip content-* header fields.
 *
 * @private
 */

SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
  var res = this.res;
  var headers = getHeaderNames(res);

  for (var i = 0; i < headers.length; i++) {
    var header = headers[i];
    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {
      res.removeHeader(header);
    }
  }
};

/**
 * Respond with 304 not modified.
 *
 * @api private
 */

SendStream.prototype.notModified = function notModified() {
  var res = this.res;
  debug$f('not modified');
  this.removeContentHeaderFields();
  res.statusCode = 304;
  res.end();
};

/**
 * Raise error that headers already sent.
 *
 * @api private
 */

SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
  var err = new Error('Can\'t set headers after they are sent.');
  debug$f('headers already sent');
  this.error(500, err);
};

/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isCachable = function isCachable() {
  var statusCode = this.res.statusCode;
  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};

/**
 * Handle stat() error.
 *
 * @param {Error} error
 * @private
 */

SendStream.prototype.onStatError = function onStatError(error) {
  switch (error.code) {
    case 'ENAMETOOLONG':
    case 'ENOENT':
    case 'ENOTDIR':
      this.error(404, error);
      break;
    default:
      this.error(500, error);
      break;
  }
};

/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isFresh = function isFresh() {
  return fresh_1(this.req.headers, {
    'etag': this.res.getHeader('ETag'),
    'last-modified': this.res.getHeader('Last-Modified')
  });
};

/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */

SendStream.prototype.isRangeFresh = function isRangeFresh() {
  var ifRange = this.req.headers['if-range'];

  if (!ifRange) {
    return true;
  }

  // if-range as etag
  if (ifRange.indexOf('"') !== -1) {
    var etag = this.res.getHeader('ETag');
    return Boolean(etag && ifRange.indexOf(etag) !== -1);
  }

  // if-range as modified date
  var lastModified = this.res.getHeader('Last-Modified');
  return parseHttpDate$1(lastModified) <= parseHttpDate$1(ifRange);
};

/**
 * Redirect to path.
 *
 * @param {string} path
 * @private
 */

SendStream.prototype.redirect = function redirect(path$$1) {
  var res = this.res;

  if (hasListeners(this, 'directory')) {
    this.emit('directory', res, path$$1);
    return;
  }

  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }

  var loc = encodeurl(collapseLeadingSlashes(this.path + '/'));
  var doc = createHtmlDocument$1('Redirecting', 'Redirecting to <a href="' + escapeHtml_1(loc) + '">' + escapeHtml_1(loc) + '</a>');

  // redirect
  res.statusCode = 301;
  res.setHeader('Content-Type', 'text/html; charset=UTF-8');
  res.setHeader('Content-Length', Buffer.byteLength(doc));
  res.setHeader('Content-Security-Policy', "default-src 'self'");
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('Location', loc);
  res.end(doc);
};

/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */

SendStream.prototype.pipe = function pipe(res) {
  // root path
  var root = this._root;

  // references
  this.res = res;

  // decode the path
  var path$$1 = decode$1(this.path);
  if (path$$1 === -1) {
    this.error(400);
    return res;
  }

  // null byte(s)
  if (~path$$1.indexOf('\0')) {
    this.error(400);
    return res;
  }

  var parts;
  if (root !== null) {
    // normalize
    if (path$$1) {
      path$$1 = normalize$1('.' + sep + path$$1);
    }

    // malicious path
    if (UP_PATH_REGEXP.test(path$$1)) {
      debug$f('malicious path "%s"', path$$1);
      this.error(403);
      return res;
    }

    // explode path parts
    parts = path$$1.split(sep);

    // join / normalize from optional root dir
    path$$1 = normalize$1(join$1(root, path$$1));
    root = normalize$1(root + sep);
  } else {
    // ".." is malicious without "root"
    if (UP_PATH_REGEXP.test(path$$1)) {
      debug$f('malicious path "%s"', path$$1);
      this.error(403);
      return res;
    }

    // explode path parts
    parts = normalize$1(path$$1).split(sep);

    // resolve the path
    path$$1 = resolve$1(path$$1);
  }

  // dotfile handling
  if (containsDotFile(parts)) {
    var access = this._dotfiles;

    // legacy support
    if (access === undefined) {
      access = parts[parts.length - 1][0] === '.' ? this._hidden ? 'allow' : 'ignore' : 'allow';
    }

    debug$f('%s dotfile "%s"', access, path$$1);
    switch (access) {
      case 'allow':
        break;
      case 'deny':
        this.error(403);
        return res;
      case 'ignore':
      default:
        this.error(404);
        return res;
    }
  }

  // index file support
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path$$1);
    return res;
  }

  this.sendFile(path$$1);
  return res;
};

/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */

SendStream.prototype.send = function send(path$$1, stat) {
  var len = stat.size;
  var options = this.options;
  var opts = {};
  var res = this.res;
  var req = this.req;
  var ranges = req.headers.range;
  var offset = options.start || 0;

  if (headersSent$1(res)) {
    // impossible to send now
    this.headersAlreadySent();
    return;
  }

  debug$f('pipe "%s"', path$$1);

  // set header fields
  this.setHeader(path$$1, stat);

  // set content-type
  this.type(path$$1);

  // conditional GET support
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }

    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }

  // adjust len to start/end options
  len = Math.max(0, len - offset);
  if (options.end !== undefined) {
    var bytes = options.end - offset + 1;
    if (len > bytes) len = bytes;
  }

  // Range support
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    // parse
    ranges = rangeParser_1(len, ranges, {
      combine: true
    });

    // If-Range support
    if (!this.isRangeFresh()) {
      debug$f('range stale');
      ranges = -2;
    }

    // unsatisfiable
    if (ranges === -1) {
      debug$f('range unsatisfiable');

      // Content-Range
      res.setHeader('Content-Range', contentRange('bytes', len));

      // 416 Requested Range Not Satisfiable
      return this.error(416, {
        headers: { 'Content-Range': res.getHeader('Content-Range') }
      });
    }

    // valid (syntactically invalid/multiple ranges are treated as a regular response)
    if (ranges !== -2 && ranges.length === 1) {
      debug$f('range %j', ranges);

      // Content-Range
      res.statusCode = 206;
      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]));

      // adjust for requested range
      offset += ranges[0].start;
      len = ranges[0].end - ranges[0].start + 1;
    }
  }

  // clone options
  for (var prop in options) {
    opts[prop] = options[prop];
  }

  // set read options
  opts.start = offset;
  opts.end = Math.max(offset, offset + len - 1);

  // content-length
  res.setHeader('Content-Length', len);

  // HEAD support
  if (req.method === 'HEAD') {
    res.end();
    return;
  }

  this.stream(path$$1, opts);
};

/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendFile = function sendFile(path$$1) {
  var i = 0;
  var self = this;

  debug$f('stat "%s"', path$$1);
  fs.stat(path$$1, function onstat(err, stat) {
    if (err && err.code === 'ENOENT' && !extname$1(path$$1) && path$$1[path$$1.length - 1] !== sep) {
      // not found, check extensions
      return next(err);
    }
    if (err) return self.onStatError(err);
    if (stat.isDirectory()) return self.redirect(path$$1);
    self.emit('file', path$$1, stat);
    self.send(path$$1, stat);
  });

  function next(err) {
    if (self._extensions.length <= i) {
      return err ? self.onStatError(err) : self.error(404);
    }

    var p = path$$1 + '.' + self._extensions[i++];

    debug$f('stat "%s"', p);
    fs.stat(p, function (err, stat) {
      if (err) return next(err);
      if (stat.isDirectory()) return next();
      self.emit('file', p, stat);
      self.send(p, stat);
    });
  }
};

/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */
SendStream.prototype.sendIndex = function sendIndex(path$$1) {
  var i = -1;
  var self = this;

  function next(err) {
    if (++i >= self._index.length) {
      if (err) return self.onStatError(err);
      return self.error(404);
    }

    var p = join$1(path$$1, self._index[i]);

    debug$f('stat "%s"', p);
    fs.stat(p, function (err, stat) {
      if (err) return next(err);
      if (stat.isDirectory()) return next();
      self.emit('file', p, stat);
      self.send(p, stat);
    });
  }

  next();
};

/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */

SendStream.prototype.stream = function stream(path$$1, options) {
  // TODO: this is all lame, refactor meeee
  var finished = false;
  var self = this;
  var res = this.res;

  // pipe
  var stream = fs.createReadStream(path$$1, options);
  this.emit('stream', stream);
  stream.pipe(res);

  // response finished, done with the fd
  onFinished_1(res, function onfinished() {
    finished = true;
    destroy_1(stream);
  });

  // error handling code-smell
  stream.on('error', function onerror(err) {
    // request already finished
    if (finished) return;

    // clean up stream
    finished = true;
    destroy_1(stream);

    // error
    self.onStatError(err);
  });

  // end
  stream.on('end', function onend() {
    self.emit('end');
  });
};

/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */

SendStream.prototype.type = function type(path$$1) {
  var res = this.res;

  if (res.getHeader('Content-Type')) return;

  var type = mime_1.lookup(path$$1);

  if (!type) {
    debug$f('no content-type');
    return;
  }

  var charset = mime_1.charsets.lookup(type);

  debug$f('content-type %s', type);
  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''));
};

/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */

SendStream.prototype.setHeader = function setHeader(path$$1, stat) {
  var res = this.res;

  this.emit('headers', res, path$$1, stat);

  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {
    debug$f('accept ranges');
    res.setHeader('Accept-Ranges', 'bytes');
  }

  if (this._cacheControl && !res.getHeader('Cache-Control')) {
    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000);

    if (this._immutable) {
      cacheControl += ', immutable';
    }

    debug$f('cache-control %s', cacheControl);
    res.setHeader('Cache-Control', cacheControl);
  }

  if (this._lastModified && !res.getHeader('Last-Modified')) {
    var modified = stat.mtime.toUTCString();
    debug$f('modified %s', modified);
    res.setHeader('Last-Modified', modified);
  }

  if (this._etag && !res.getHeader('ETag')) {
    var val = etag_1(stat);
    debug$f('etag %s', val);
    res.setHeader('ETag', val);
  }
};

/**
 * Clear all headers from a response.
 *
 * @param {object} res
 * @private
 */

function clearHeaders(res) {
  var headers = getHeaderNames(res);

  for (var i = 0; i < headers.length; i++) {
    res.removeHeader(headers[i]);
  }
}

/**
 * Collapse all leading slashes into a single slash
 *
 * @param {string} str
 * @private
 */
function collapseLeadingSlashes(str) {
  for (var i = 0; i < str.length; i++) {
    if (str[i] !== '/') {
      break;
    }
  }

  return i > 1 ? '/' + str.substr(i) : str;
}

/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */

function containsDotFile(parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part.length > 1 && part[0] === '.') {
      return true;
    }
  }

  return false;
}

/**
 * Create a Content-Range header.
 *
 * @param {string} type
 * @param {number} size
 * @param {array} [range]
 */

function contentRange(type, size, range) {
  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size;
}

/**
 * Create a minimal HTML document.
 *
 * @param {string} title
 * @param {string} body
 * @private
 */

function createHtmlDocument$1(title, body) {
  return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>' + title + '</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n' + '<html>\n';
}

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */

function decode$1(path$$1) {
  try {
    return decodeURIComponent(path$$1);
  } catch (err) {
    return -1;
  }
}

/**
 * Get the header names on a respnse.
 *
 * @param {object} res
 * @returns {array[string]}
 * @private
 */

function getHeaderNames(res) {
  return typeof res.getHeaderNames !== 'function' ? Object.keys(res._headers || {}) : res.getHeaderNames();
}

/**
 * Determine if emitter has listeners of a given type.
 *
 * The way to do this check is done three different ways in Node.js >= 0.8
 * so this consolidates them into a minimal set using instance methods.
 *
 * @param {EventEmitter} emitter
 * @param {string} type
 * @returns {boolean}
 * @private
 */

function hasListeners(emitter, type) {
  var count = typeof emitter.listenerCount !== 'function' ? emitter.listeners(type).length : emitter.listenerCount(type);

  return count > 0;
}

/**
 * Determine if the response headers have been sent.
 *
 * @param {object} res
 * @returns {boolean}
 * @private
 */

function headersSent$1(res) {
  return typeof res.headersSent !== 'boolean' ? Boolean(res._header) : res.headersSent;
}

/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @param {string} name
 * @private
 */

function normalizeList(val, name) {
  var list = [].concat(val || []);

  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== 'string') {
      throw new TypeError(name + ' must be array of strings or false');
    }
  }

  return list;
}

/**
 * Parse an HTTP Date into a number.
 *
 * @param {string} date
 * @private
 */

function parseHttpDate$1(date) {
  var timestamp = date && Date.parse(date);

  return typeof timestamp === 'number' ? timestamp : NaN;
}

/**
 * Parse a HTTP token list.
 *
 * @param {string} str
 * @private
 */

function parseTokenList$1(str) {
  var end = 0;
  var list = [];
  var start = 0;

  // gather tokens
  for (var i = 0, len = str.length; i < len; i++) {
    switch (str.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 0x2c:
        /* , */
        list.push(str.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }

  // final token
  list.push(str.substring(start, end));

  return list;
}

/**
 * Set an object of headers on a response.
 *
 * @param {object} res
 * @param {object} headers
 * @private
 */

function setHeaders$1(res, headers) {
  var keys = Object.keys(headers);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res.setHeader(key, headers[key]);
  }
}
send_1.mime = mime_1$1;

/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var forwarded_1 = forwarded;

/**
 * Get all addresses in the request, using the `X-Forwarded-For` header.
 *
 * @param {object} req
 * @return {array}
 * @public
 */

function forwarded(req) {
  if (!req) {
    throw new TypeError('argument req is required');
  }

  // simple header parsing
  var proxyAddrs = parse$a(req.headers['x-forwarded-for'] || '');
  var socketAddr = req.connection.remoteAddress;
  var addrs = [socketAddr].concat(proxyAddrs);

  // return all addresses
  return addrs;
}

/**
 * Parse the X-Forwarded-For header.
 *
 * @param {string} header
 * @private
 */

function parse$a(header) {
  var end = header.length;
  var list = [];
  var start = header.length;

  // gather addresses, backwards
  for (var i = header.length - 1; i >= 0; i--) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i;
        }
        break;
      case 0x2c:
        /* , */
        if (start !== end) {
          list.push(header.substring(start, end));
        }
        start = end = i;
        break;
      default:
        start = i;
        break;
    }
  }

  // final address
  if (start !== end) {
    list.push(header.substring(start, end));
  }

  return list;
}

var ipaddr = createCommonjsModule(function (module) {
(function () {
  var expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root, zoneIndex;

  ipaddr = {};

  root = this;

  if (module !== null && module.exports) {
    module.exports = ipaddr;
  } else {
    root['ipaddr'] = ipaddr;
  }

  matchCIDR = function (first, second, partSize, cidrBits) {
    var part, shift;
    if (first.length !== second.length) {
      throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
    }
    part = 0;
    while (cidrBits > 0) {
      shift = partSize - cidrBits;
      if (shift < 0) {
        shift = 0;
      }
      if (first[part] >> shift !== second[part] >> shift) {
        return false;
      }
      cidrBits -= partSize;
      part += 1;
    }
    return true;
  };

  ipaddr.subnetMatch = function (address, rangeList, defaultName) {
    var k, len, rangeName, rangeSubnets, subnet;
    if (defaultName == null) {
      defaultName = 'unicast';
    }
    for (rangeName in rangeList) {
      rangeSubnets = rangeList[rangeName];
      if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
        rangeSubnets = [rangeSubnets];
      }
      for (k = 0, len = rangeSubnets.length; k < len; k++) {
        subnet = rangeSubnets[k];
        if (address.kind() === subnet[0].kind()) {
          if (address.match.apply(address, subnet)) {
            return rangeName;
          }
        }
      }
    }
    return defaultName;
  };

  ipaddr.IPv4 = function () {
    function IPv4(octets) {
      var k, len, octet;
      if (octets.length !== 4) {
        throw new Error("ipaddr: ipv4 octet count should be 4");
      }
      for (k = 0, len = octets.length; k < len; k++) {
        octet = octets[k];
        if (!(0 <= octet && octet <= 255)) {
          throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
        }
      }
      this.octets = octets;
    }

    IPv4.prototype.kind = function () {
      return 'ipv4';
    };

    IPv4.prototype.toString = function () {
      return this.octets.join(".");
    };

    IPv4.prototype.toNormalizedString = function () {
      return this.toString();
    };

    IPv4.prototype.toByteArray = function () {
      return this.octets.slice(0);
    };

    IPv4.prototype.match = function (other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv4') {
        throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
      }
      return matchCIDR(this.octets, other.octets, 8, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
    };

    IPv4.prototype.range = function () {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = function () {
      return ipaddr.IPv6.parse("::ffff:" + this.toString());
    };

    IPv4.prototype.prefixLengthFromSubnetMask = function () {
      var cidr, i, k, octet, stop, zeros, zerotable;
      zerotable = {
        0: 8,
        128: 7,
        192: 6,
        224: 5,
        240: 4,
        248: 3,
        252: 2,
        254: 1,
        255: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 3; k >= 0; i = k += -1) {
        octet = this.octets[i];
        if (octet in zerotable) {
          zeros = zerotable[octet];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 8) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 32 - cidr;
    };

    return IPv4;
  }();

  ipv4Part = "(0?\\d+|0x[a-f0-9]+)";

  ipv4Regexes = {
    fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", 'i'),
    longValue: new RegExp("^" + ipv4Part + "$", 'i')
  };

  ipaddr.IPv4.parser = function (string) {
    var match, parseIntAuto, part, shift, value;
    parseIntAuto = function (string) {
      if (string[0] === "0" && string[1] !== "x") {
        return parseInt(string, 8);
      } else {
        return parseInt(string);
      }
    };
    if (match = string.match(ipv4Regexes.fourOctet)) {
      return function () {
        var k, len, ref, results;
        ref = match.slice(1, 6);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(parseIntAuto(part));
        }
        return results;
      }();
    } else if (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[1]);
      if (value > 0xffffffff || value < 0) {
        throw new Error("ipaddr: address outside defined range");
      }
      return function () {
        var k, results;
        results = [];
        for (shift = k = 0; k <= 24; shift = k += 8) {
          results.push(value >> shift & 0xff);
        }
        return results;
      }().reverse();
    } else {
      return null;
    }
  };

  ipaddr.IPv6 = function () {
    function IPv6(parts, zoneId) {
      var i, k, l, len, part, ref;
      if (parts.length === 16) {
        this.parts = [];
        for (i = k = 0; k <= 14; i = k += 2) {
          this.parts.push(parts[i] << 8 | parts[i + 1]);
        }
      } else if (parts.length === 8) {
        this.parts = parts;
      } else {
        throw new Error("ipaddr: ipv6 part count should be 8 or 16");
      }
      ref = this.parts;
      for (l = 0, len = ref.length; l < len; l++) {
        part = ref[l];
        if (!(0 <= part && part <= 0xffff)) {
          throw new Error("ipaddr: ipv6 part should fit in 16 bits");
        }
      }
      if (zoneId) {
        this.zoneId = zoneId;
      }
    }

    IPv6.prototype.kind = function () {
      return 'ipv6';
    };

    IPv6.prototype.toString = function () {
      return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, '::');
    };

    IPv6.prototype.toByteArray = function () {
      var bytes, k, len, part, ref;
      bytes = [];
      ref = this.parts;
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        bytes.push(part >> 8);
        bytes.push(part & 0xff);
      }
      return bytes;
    };

    IPv6.prototype.toNormalizedString = function () {
      var addr, part, suffix;
      addr = function () {
        var k, len, ref, results;
        ref = this.parts;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          part = ref[k];
          results.push(part.toString(16));
        }
        return results;
      }.call(this).join(":");
      suffix = '';
      if (this.zoneId) {
        suffix = '%' + this.zoneId;
      }
      return addr + suffix;
    };

    IPv6.prototype.match = function (other, cidrRange) {
      var ref;
      if (cidrRange === void 0) {
        ref = other, other = ref[0], cidrRange = ref[1];
      }
      if (other.kind() !== 'ipv6') {
        throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
      }
      return matchCIDR(this.parts, other.parts, 16, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],
      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],
      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],
      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],
      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],
      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],
      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],
      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],
      reserved: [[new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]
    };

    IPv6.prototype.range = function () {
      return ipaddr.subnetMatch(this, this.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = function () {
      return this.range() === 'ipv4Mapped';
    };

    IPv6.prototype.toIPv4Address = function () {
      var high, low, ref;
      if (!this.isIPv4MappedAddress()) {
        throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
      }
      ref = this.parts.slice(-2), high = ref[0], low = ref[1];
      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);
    };

    IPv6.prototype.prefixLengthFromSubnetMask = function () {
      var cidr, i, k, part, stop, zeros, zerotable;
      zerotable = {
        0: 16,
        32768: 15,
        49152: 14,
        57344: 13,
        61440: 12,
        63488: 11,
        64512: 10,
        65024: 9,
        65280: 8,
        65408: 7,
        65472: 6,
        65504: 5,
        65520: 4,
        65528: 3,
        65532: 2,
        65534: 1,
        65535: 0
      };
      cidr = 0;
      stop = false;
      for (i = k = 7; k >= 0; i = k += -1) {
        part = this.parts[i];
        if (part in zerotable) {
          zeros = zerotable[part];
          if (stop && zeros !== 0) {
            return null;
          }
          if (zeros !== 16) {
            stop = true;
          }
          cidr += zeros;
        } else {
          return null;
        }
      }
      return 128 - cidr;
    };

    return IPv6;
  }();

  ipv6Part = "(?:[0-9a-f]+::?)+";

  zoneIndex = "%[0-9a-z]{1,}";

  ipv6Regexes = {
    zoneIndex: new RegExp(zoneIndex, 'i'),
    "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", 'i'),
    transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), 'i')
  };

  expandIPv6 = function (string, parts) {
    var colonCount, lastColon, part, replacement, replacementCount, zoneId;
    if (string.indexOf('::') !== string.lastIndexOf('::')) {
      return null;
    }
    zoneId = (string.match(ipv6Regexes['zoneIndex']) || [])[0];
    if (zoneId) {
      zoneId = zoneId.substring(1);
      string = string.replace(/%.+$/, '');
    }
    colonCount = 0;
    lastColon = -1;
    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {
      colonCount++;
    }
    if (string.substr(0, 2) === '::') {
      colonCount--;
    }
    if (string.substr(-2, 2) === '::') {
      colonCount--;
    }
    if (colonCount > parts) {
      return null;
    }
    replacementCount = parts - colonCount;
    replacement = ':';
    while (replacementCount--) {
      replacement += '0:';
    }
    string = string.replace('::', replacement);
    if (string[0] === ':') {
      string = string.slice(1);
    }
    if (string[string.length - 1] === ':') {
      string = string.slice(0, -1);
    }
    parts = function () {
      var k, len, ref, results;
      ref = string.split(":");
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        part = ref[k];
        results.push(parseInt(part, 16));
      }
      return results;
    }();
    return {
      parts: parts,
      zoneId: zoneId
    };
  };

  ipaddr.IPv6.parser = function (string) {
    var addr, k, len, match, octet, octets, zoneId;
    if (ipv6Regexes['native'].test(string)) {
      return expandIPv6(string, 8);
    } else if (match = string.match(ipv6Regexes['transitional'])) {
      zoneId = match[6] || '';
      addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
      if (addr.parts) {
        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            return null;
          }
        }
        addr.parts.push(octets[0] << 8 | octets[1]);
        addr.parts.push(octets[2] << 8 | octets[3]);
        return {
          parts: addr.parts,
          zoneId: addr.zoneId
        };
      }
    }
    return null;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = function (string) {
    return this.parser(string) !== null;
  };

  ipaddr.IPv4.isValid = function (string) {
    try {
      new this(this.parser(string));
      return true;
    } catch (error1) {
      return false;
    }
  };

  ipaddr.IPv4.isValidFourPartDecimal = function (string) {
    if (ipaddr.IPv4.isValid(string) && string.match(/^\d+(\.\d+){3}$/)) {
      return true;
    } else {
      return false;
    }
  };

  ipaddr.IPv6.isValid = function (string) {
    var addr;
    if (typeof string === "string" && string.indexOf(":") === -1) {
      return false;
    }
    try {
      addr = this.parser(string);
      new this(addr.parts, addr.zoneId);
      return true;
    } catch (error1) {
      return false;
    }
  };

  ipaddr.IPv4.parse = function (string) {
    var parts;
    parts = this.parser(string);
    if (parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(parts);
  };

  ipaddr.IPv6.parse = function (string) {
    var addr;
    addr = this.parser(string);
    if (addr.parts === null) {
      throw new Error("ipaddr: string is not formatted like ip address");
    }
    return new this(addr.parts, addr.zoneId);
  };

  ipaddr.IPv4.parseCIDR = function (string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 32) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
  };

  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {
    var filledOctetCount, j, octets;
    prefix = parseInt(prefix);
    if (prefix < 0 || prefix > 32) {
      throw new Error('ipaddr: invalid IPv4 prefix length');
    }
    octets = [0, 0, 0, 0];
    j = 0;
    filledOctetCount = Math.floor(prefix / 8);
    while (j < filledOctetCount) {
      octets[j] = 255;
      j++;
    }
    if (filledOctetCount < 4) {
      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
    }
    return new this(octets);
  };

  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {
    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
        i++;
      }
      return new this(octets);
    } catch (error1) {
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv4.networkAddressFromCIDR = function (string) {
    var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
    try {
      cidr = this.parseCIDR(string);
      ipInterfaceOctets = cidr[0].toByteArray();
      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
      octets = [];
      i = 0;
      while (i < 4) {
        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
        i++;
      }
      return new this(octets);
    } catch (error1) {
      throw new Error('ipaddr: the address does not have IPv4 CIDR format');
    }
  };

  ipaddr.IPv6.parseCIDR = function (string) {
    var maskLength, match;
    if (match = string.match(/^(.+)\/(\d+)$/)) {
      maskLength = parseInt(match[2]);
      if (maskLength >= 0 && maskLength <= 128) {
        return [this.parse(match[1]), maskLength];
      }
    }
    throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
  };

  ipaddr.isValid = function (string) {
    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = function (string) {
    if (ipaddr.IPv6.isValid(string)) {
      return ipaddr.IPv6.parse(string);
    } else if (ipaddr.IPv4.isValid(string)) {
      return ipaddr.IPv4.parse(string);
    } else {
      throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
    }
  };

  ipaddr.parseCIDR = function (string) {
    try {
      return ipaddr.IPv6.parseCIDR(string);
    } catch (error1) {
      try {
        return ipaddr.IPv4.parseCIDR(string);
      } catch (error1) {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
      }
    }
  };

  ipaddr.fromByteArray = function (bytes) {
    var length;
    length = bytes.length;
    if (length === 4) {
      return new ipaddr.IPv4(bytes);
    } else if (length === 16) {
      return new ipaddr.IPv6(bytes);
    } else {
      throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
    }
  };

  ipaddr.process = function (string) {
    var addr;
    addr = this.parse(string);
    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {
      return addr.toIPv4Address();
    } else {
      return addr;
    }
  };
}).call(commonjsGlobal);
});

/**
 * Module exports.
 * @public
 */

var proxyAddr = proxyaddr;
var all = alladdrs;
var compile_1 = compile;

/**
 * Module dependencies.
 * @private
 */




/**
 * Variables.
 * @private
 */

var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;

/**
 * Pre-defined IP ranges.
 * @private
 */

var IP_RANGES = {
  linklocal: ['169.254.0.0/16', 'fe80::/10'],
  loopback: ['127.0.0.1/8', '::1/128'],
  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']

  /**
   * Get all addresses in the request, optionally stopping
   * at the first untrusted.
   *
   * @param {Object} request
   * @param {Function|Array|String} [trust]
   * @public
   */

};function alladdrs(req, trust) {
  // get addresses
  var addrs = forwarded_1(req);

  if (!trust) {
    // Return all addresses
    return addrs;
  }

  if (typeof trust !== 'function') {
    trust = compile(trust);
  }

  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;

    addrs.length = i + 1;
  }

  return addrs;
}

/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @private
 */

function compile(val) {
  if (!val) {
    throw new TypeError('argument is required');
  }

  var trust;

  if (typeof val === 'string') {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError('unsupported trust argument');
  }

  for (var i = 0; i < trust.length; i++) {
    val = trust[i];

    if (!IP_RANGES.hasOwnProperty(val)) {
      continue;
    }

    // Splice in pre-defined range
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }

  return compileTrust(compileRangeSubnets(trust));
}

/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @private
 */

function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);

  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }

  return rangeSubnets;
}

/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @private
 */

function compileTrust(rangeSubnets) {
  // Return optimized function based on length
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}

/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @private
 */

function parseipNotation(note) {
  var pos = note.lastIndexOf('/');
  var str = pos !== -1 ? note.substring(0, pos) : note;

  if (!isip(str)) {
    throw new TypeError('invalid IP address: ' + str);
  }

  var ip = parseip(str);

  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {
    // Store as IPv4
    ip = ip.toIPv4Address();
  }

  var max = ip.kind() === 'ipv6' ? 128 : 32;

  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;

  if (range === null) {
    range = max;
  } else if (DIGIT_REGEXP.test(range)) {
    range = parseInt(range, 10);
  } else if (ip.kind() === 'ipv4' && isip(range)) {
    range = parseNetmask(range);
  } else {
    range = null;
  }

  if (range <= 0 || range > max) {
    throw new TypeError('invalid range on address: ' + note);
  }

  return [ip, range];
}

/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} netmask
 * @private
 */

function parseNetmask(netmask) {
  var ip = parseip(netmask);
  var kind = ip.kind();

  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;
}

/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @public
 */

function proxyaddr(req, trust) {
  if (!req) {
    throw new TypeError('req argument is required');
  }

  if (!trust) {
    throw new TypeError('trust argument is required');
  }

  var addrs = alladdrs(req, trust);
  var addr = addrs[addrs.length - 1];

  return addr;
}

/**
 * Static trust function to trust nothing.
 *
 * @private
 */

function trustNone() {
  return false;
}

/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @private
 */

function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var ipconv;
    var kind = ip.kind();

    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip;

      if (kind !== subnetkind) {
        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {
          // Incompatible IP addresses
          continue;
        }

        if (!ipconv) {
          // Convert IP to match subnet IP kind
          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }

        trusted = ipconv;
      }

      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }

    return false;
  };
}

/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @private
 */

function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === 'ipv4';
  var subnetrange = subnet[1];

  return function trust(addr) {
    if (!isip(addr)) return false;

    var ip = parseip(addr);
    var kind = ip.kind();

    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
        // Incompatible IP addresses
        return false;
      }

      // Convert IP to match subnet IP kind
      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
    }

    return ip.match(subnetip, subnetrange);
  };
}
proxyAddr.all = all;
proxyAddr.compile = compile_1;

var utils$1 = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @api private
 */

var Buffer = safeBuffer.Buffer;


var deprecate = depd_1('express');

var mime = send_1.mime;





/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.etag = createETagGenerator({ weak: false });

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */

exports.wetag = createETagGenerator({ weak: true });

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */

exports.isAbsolute = function (path$$1) {
  if ('/' === path$$1[0]) return true;
  if (':' === path$$1[1] && ('\\' === path$$1[2] || '/' === path$$1[2])) return true; // Windows device path
  if ('\\\\' === path$$1.substring(0, 2)) return true; // Microsoft Azure absolute path
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */

exports.flatten = deprecate.function(arrayFlatten_1, 'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */

exports.normalizeType = function (type) {
  return ~type.indexOf('/') ? acceptParams(type) : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */

exports.normalizeTypes = function (types) {
  var ret = [];

  for (var i = 0; i < types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */

exports.contentDisposition = deprecate.function(contentDisposition_1, 'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function acceptParams(str, index) {
  var parts = str.split(/ *; */);
  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };

  for (var i = 1; i < parts.length; ++i) {
    var pms = parts[i].split(/ *= */);
    if ('q' === pms[0]) {
      ret.quality = parseFloat(pms[1]);
    } else {
      ret.params[pms[0]] = pms[1];
    }
  }

  return ret;
}

/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileETag = function (val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = exports.wetag;
      break;
    case false:
      break;
    case 'strong':
      fn = exports.etag;
      break;
    case 'weak':
      fn = exports.wetag;
      break;
    default:
      throw new TypeError('unknown value for etag function: ' + val);
  }

  return fn;
};

/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */

exports.compileQueryParser = function compileQueryParser(val) {
  var fn;

  if (typeof val === 'function') {
    return val;
  }

  switch (val) {
    case true:
      fn = querystring.parse;
      break;
    case false:
      fn = newObject;
      break;
    case 'extended':
      fn = parseExtendedQueryString;
      break;
    case 'simple':
      fn = querystring.parse;
      break;
    default:
      throw new TypeError('unknown value for query parser function: ' + val);
  }

  return fn;
};

/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */

exports.compileTrust = function (val) {
  if (typeof val === 'function') return val;

  if (val === true) {
    // Support plain true/false
    return function () {
      return true;
    };
  }

  if (typeof val === 'number') {
    // Support trusting hop count
    return function (a, i) {
      return i < val;
    };
  }

  if (typeof val === 'string') {
    // Support comma-separated values
    val = val.split(/ *, */);
  }

  return proxyAddr.compile(val || []);
};

/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */

exports.setCharset = function setCharset(type, charset) {
  if (!type || !charset) {
    return type;
  }

  // parse type
  var parsed = contentType.parse(type);

  // set charset
  parsed.parameters.charset = charset;

  // format type
  return contentType.format(parsed);
};

/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 *
 * @param {object} options
 * @return {function}
 * @private
 */

function createETagGenerator(options) {
  return function generateETag(body, encoding) {
    var buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body;

    return etag_1(buf, options);
  };
}

/**
 * Parse an extended query string with qs.
 *
 * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return lib$1.parse(str, {
    allowPrototypes: true
  });
}

/**
 * Return new empty object.
 *
 * @return {Object}
 * @api private
 */

function newObject() {
  return {};
}
});
var utils_1$1 = utils$1.etag;
var utils_2$1 = utils$1.wetag;
var utils_3$1 = utils$1.isAbsolute;
var utils_4$1 = utils$1.flatten;
var utils_5$1 = utils$1.normalizeType;
var utils_6$1 = utils$1.normalizeTypes;
var utils_7$1 = utils$1.contentDisposition;
var utils_8$1 = utils$1.compileETag;
var utils_9 = utils$1.compileQueryParser;
var utils_10 = utils$1.compileTrust;
var utils_11 = utils$1.setCharset;

var application = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @private
 */






var debug = src$4('express:application');


var compileETag = utils$1.compileETag;
var compileQueryParser = utils$1.compileQueryParser;
var compileTrust = utils$1.compileTrust;
var deprecate = depd_1('express');


var resolve = path.resolve;

var slice = Array.prototype.slice;

/**
 * Application prototype.
 */

var app = exports = module.exports = {};

/**
 * Variable for trust proxy inheritance back-compat
 * @private
 */

var trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';

/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @private
 */

app.init = function init$$1() {
  this.cache = {};
  this.engines = {};
  this.settings = {};

  this.defaultConfiguration();
};

/**
 * Initialize application configuration.
 * @private
 */

app.defaultConfiguration = function defaultConfiguration() {
  var env = process.env.NODE_ENV || 'development';

  // default settings
  this.enable('x-powered-by');
  this.set('etag', 'weak');
  this.set('env', env);
  this.set('query parser', 'extended');
  this.set('subdomain offset', 2);
  this.set('trust proxy', false);

  // trust proxy inherit back-compat
  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
    configurable: true,
    value: true
  });

  debug('booting in %s mode', env);

  this.on('mount', function onmount(parent) {
    // inherit trust proxy
    if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings['trust proxy fn'] === 'function') {
      delete this.settings['trust proxy'];
      delete this.settings['trust proxy fn'];
    }

    // inherit protos
    setprototypeof$2(this.request, parent.request);
    setprototypeof$2(this.response, parent.response);
    setprototypeof$2(this.engines, parent.engines);
    setprototypeof$2(this.settings, parent.settings);
  });

  // setup locals
  this.locals = Object.create(null);

  // top-most app is mounted at /
  this.mountpath = '/';

  // default locals
  this.locals.settings = this.settings;

  // default configuration
  this.set('view', view);
  this.set('views', resolve('views'));
  this.set('jsonp callback name', 'callback');

  if (env === 'production') {
    this.enable('view cache');
  }

  Object.defineProperty(this, 'router', {
    get: function () {
      throw new Error('\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');
    }
  });
};

/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @private
 */
app.lazyrouter = function lazyrouter() {
  if (!this._router) {
    this._router = new router({
      caseSensitive: this.enabled('case sensitive routing'),
      strict: this.enabled('strict routing')
    });

    this._router.use(query(this.get('query parser fn')));
    this._router.use(init.init(this));
  }
};

/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @private
 */

app.handle = function handle(req, res, callback) {
  var router$$1 = this._router;

  // final handler
  var done = callback || finalhandler_1(req, res, {
    env: this.get('env'),
    onerror: logerror.bind(this)
  });

  // no routes
  if (!router$$1) {
    debug('no routes defined on app');
    done();
    return;
  }

  router$$1.handle(req, res, done);
};

/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @public
 */

app.use = function use(fn) {
  var offset = 0;
  var path$$1 = '/';

  // default path to '/'
  // disambiguate app.use([fn])
  if (typeof fn !== 'function') {
    var arg = fn;

    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }

    // first arg is the path
    if (typeof arg !== 'function') {
      offset = 1;
      path$$1 = fn;
    }
  }

  var fns = arrayFlatten_1(slice.call(arguments, offset));

  if (fns.length === 0) {
    throw new TypeError('app.use() requires a middleware function');
  }

  // setup router
  this.lazyrouter();
  var router$$1 = this._router;

  fns.forEach(function (fn) {
    // non-express app
    if (!fn || !fn.handle || !fn.set) {
      return router$$1.use(path$$1, fn);
    }

    debug('.use app under %s', path$$1);
    fn.mountpath = path$$1;
    fn.parent = this;

    // restore .app property on req and res
    router$$1.use(path$$1, function mounted_app(req, res, next) {
      var orig = req.app;
      fn.handle(req, res, function (err) {
        setprototypeof$2(req, orig.request);
        setprototypeof$2(res, orig.response);
        next(err);
      });
    });

    // mounted an app
    fn.emit('mount', this);
  }, this);

  return this;
};

/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @public
 */

app.route = function route(path$$1) {
  this.lazyrouter();
  return this._router.route(path$$1);
};

/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.ejs" file Express will invoke the following internally:
 *
 *     app.engine('ejs', require('ejs').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you dont need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/tj/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.engine = function engine(ext, fn) {
  if (typeof fn !== 'function') {
    throw new Error('callback function required');
  }

  // get file extension
  var extension = ext[0] !== '.' ? '.' + ext : ext;

  // store engine
  this.engines[extension] = fn;

  return this;
};

/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @public
 */

app.param = function param(name, fn) {
  this.lazyrouter();

  if (Array.isArray(name)) {
    for (var i = 0; i < name.length; i++) {
      this.param(name[i], fn);
    }

    return this;
  }

  this._router.param(name, fn);

  return this;
};

/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.set('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @public
 */

app.set = function set(setting, val) {
  if (arguments.length === 1) {
    // app.get(setting)
    return this.settings[setting];
  }

  debug('set "%s" to %o', setting, val);

  // set value
  this.settings[setting] = val;

  // trigger matched settings
  switch (setting) {
    case 'etag':
      this.set('etag fn', compileETag(val));
      break;
    case 'query parser':
      this.set('query parser fn', compileQueryParser(val));
      break;
    case 'trust proxy':
      this.set('trust proxy fn', compileTrust(val));

      // trust proxy inherit back-compat
      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
        configurable: true,
        value: false
      });

      break;
  }

  return this;
};

/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @private
 */

app.path = function path$$1() {
  return this.parent ? this.parent.path() + this.mountpath : '';
};

/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.enabled = function enabled(setting) {
  return Boolean(this.set(setting));
};

/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @public
 */

app.disabled = function disabled(setting) {
  return !this.set(setting);
};

/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.enable = function enable(setting) {
  return this.set(setting, true);
};

/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @public
 */

app.disable = function disable(setting) {
  return this.set(setting, false);
};

/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */

methods.forEach(function (method) {
  app[method] = function (path$$1) {
    if (method === 'get' && arguments.length === 1) {
      // app.get(setting)
      return this.set(path$$1);
    }

    this.lazyrouter();

    var route = this._router.route(path$$1);
    route[method].apply(route, slice.call(arguments, 1));
    return this;
  };
});

/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @public
 */

app.all = function all(path$$1) {
  this.lazyrouter();

  var route = this._router.route(path$$1);
  var args = slice.call(arguments, 1);

  for (var i = 0; i < methods.length; i++) {
    route[methods[i]].apply(route, args);
  }

  return this;
};

// del -> delete alias

app.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');

/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {Object|Function} options or fn
 * @param {Function} callback
 * @public
 */

app.render = function render(name, options, callback) {
  var cache = this.cache;
  var done = callback;
  var engines = this.engines;
  var opts = options;
  var renderOptions = {};
  var view$$1;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge app.locals
  utilsMerge(renderOptions, this.locals);

  // merge options._locals
  if (opts._locals) {
    utilsMerge(renderOptions, opts._locals);
  }

  // merge options
  utilsMerge(renderOptions, opts);

  // set .cache unless explicitly provided
  if (renderOptions.cache == null) {
    renderOptions.cache = this.enabled('view cache');
  }

  // primed cache
  if (renderOptions.cache) {
    view$$1 = cache[name];
  }

  // view
  if (!view$$1) {
    var View = this.get('view');

    view$$1 = new View(name, {
      defaultEngine: this.get('view engine'),
      root: this.get('views'),
      engines: engines
    });

    if (!view$$1.path) {
      var dirs = Array.isArray(view$$1.root) && view$$1.root.length > 1 ? 'directories "' + view$$1.root.slice(0, -1).join('", "') + '" or "' + view$$1.root[view$$1.root.length - 1] + '"' : 'directory "' + view$$1.root + '"';
      var err = new Error('Failed to lookup view "' + name + '" in views ' + dirs);
      err.view = view$$1;
      return done(err);
    }

    // prime the cache
    if (renderOptions.cache) {
      cache[name] = view$$1;
    }
  }

  // render
  tryRender(view$$1, renderOptions, done);
};

/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @public
 */

app.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};

/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */

function logerror(err) {
  /* istanbul ignore next */
  if (this.get('env') !== 'test') console.error(err.stack || err.toString());
}

/**
 * Try rendering a view.
 * @private
 */

function tryRender(view$$1, options, callback) {
  try {
    view$$1.render(options, callback);
  } catch (err) {
    callback(err);
  }
}
});

/**
 * Module dependencies.
 * @private
 */


var deprecate$2 = depd_1('express');
var isIP = require$$2.isIP;







/**
 * Request prototype.
 * @public
 */

var req = Object.create(http.IncomingMessage.prototype);

/**
 * Module exports.
 * @public
 */

var request = req;

/**
 * Return request header.
 *
 * The `Referrer` header field is special-cased,
 * both `Referrer` and `Referer` are interchangeable.
 *
 * Examples:
 *
 *     req.get('Content-Type');
 *     // => "text/plain"
 *
 *     req.get('content-type');
 *     // => "text/plain"
 *
 *     req.get('Something');
 *     // => undefined
 *
 * Aliased as `req.header()`.
 *
 * @param {String} name
 * @return {String}
 * @public
 */

req.get = req.header = function header(name) {
  if (!name) {
    throw new TypeError('name argument is required to req.get');
  }

  if (typeof name !== 'string') {
    throw new TypeError('name must be a string to req.get');
  }

  var lc = name.toLowerCase();

  switch (lc) {
    case 'referer':
    case 'referrer':
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[lc];
  }
};

/**
 * To do: update docs.
 *
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single MIME type string
 * such as "application/json", an extension name
 * such as "json", a comma-delimited list such as "json, html, text/plain",
 * an argument list such as `"json", "html", "text/plain"`,
 * or an array `["json", "html", "text/plain"]`. When a list
 * or array is given, the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     req.accepts('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('html');
 *     // => "html"
 *     req.accepts('text/html');
 *     // => "text/html"
 *     req.accepts('json, text');
 *     // => "json"
 *     req.accepts('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     req.accepts('image/png');
 *     req.accepts('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     req.accepts(['html', 'json']);
 *     req.accepts('html', 'json');
 *     req.accepts('html, json');
 *     // => "json"
 *
 * @param {String|Array} type(s)
 * @return {String|Array|Boolean}
 * @public
 */

req.accepts = function () {
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};

/**
 * Check if the given `encoding`s are accepted.
 *
 * @param {String} ...encoding
 * @return {String|Array}
 * @public
 */

req.acceptsEncodings = function () {
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};

req.acceptsEncoding = deprecate$2.function(req.acceptsEncodings, 'req.acceptsEncoding: Use acceptsEncodings instead');

/**
 * Check if the given `charset`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...charset
 * @return {String|Array}
 * @public
 */

req.acceptsCharsets = function () {
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};

req.acceptsCharset = deprecate$2.function(req.acceptsCharsets, 'req.acceptsCharset: Use acceptsCharsets instead');

/**
 * Check if the given `lang`s are acceptable,
 * otherwise you should respond with 406 "Not Acceptable".
 *
 * @param {String} ...lang
 * @return {String|Array}
 * @public
 */

req.acceptsLanguages = function () {
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};

req.acceptsLanguage = deprecate$2.function(req.acceptsLanguages, 'req.acceptsLanguage: Use acceptsLanguages instead');

/**
 * Parse Range header field, capping to the given `size`.
 *
 * Unspecified ranges such as "0-" require knowledge of your resource length. In
 * the case of a byte range this is of course the total number of bytes. If the
 * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,
 * and `-2` when syntactically invalid.
 *
 * When ranges are returned, the array has a "type" property which is the type of
 * range that is required (most commonly, "bytes"). Each array element is an object
 * with a "start" and "end" property for the portion of the range.
 *
 * The "combine" option can be set to `true` and overlapping & adjacent ranges
 * will be combined into a single range.
 *
 * NOTE: remember that ranges are inclusive, so for example "Range: users=0-3"
 * should respond with 4 users when available, not 3.
 *
 * @param {number} size
 * @param {object} [options]
 * @param {boolean} [options.combine=false]
 * @return {number|array}
 * @public
 */

req.range = function range(size, options) {
  var range = this.get('Range');
  if (!range) return;
  return rangeParser_1(size, range, options);
};

/**
 * Return the value of param `name` when present or `defaultValue`.
 *
 *  - Checks route placeholders, ex: _/user/:id_
 *  - Checks body params, ex: id=12, {"id":12}
 *  - Checks query string params, ex: ?id=12
 *
 * To utilize request bodies, `req.body`
 * should be an object. This can be done by using
 * the `bodyParser()` middleware.
 *
 * @param {String} name
 * @param {Mixed} [defaultValue]
 * @return {String}
 * @public
 */

req.param = function param(name, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};

  var args = arguments.length === 1 ? 'name' : 'name, default';
  deprecate$2('req.param(' + args + '): Use req.params, req.body, or req.query instead');

  if (null != params[name] && params.hasOwnProperty(name)) return params[name];
  if (null != body[name]) return body[name];
  if (null != query[name]) return query[name];

  return defaultValue;
};

/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains the give mime `type`.
 *
 * Examples:
 *
 *      // With Content-Type: text/html; charset=utf-8
 *      req.is('html');
 *      req.is('text/html');
 *      req.is('text/*');
 *      // => true
 *
 *      // When Content-Type is application/json
 *      req.is('json');
 *      req.is('application/json');
 *      req.is('application/*');
 *      // => true
 *
 *      req.is('html');
 *      // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @public
 */

req.is = function is(types) {
  var arr = types;

  // support flattened arguments
  if (!Array.isArray(types)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }

  return typeIs(this, arr);
};

/**
 * Return the protocol string "http" or "https"
 * when requested with TLS. When the "trust proxy"
 * setting trusts the socket address, the
 * "X-Forwarded-Proto" header field will be trusted
 * and used if present.
 *
 * If you're running behind a reverse proxy that
 * supplies https for you this may be enabled.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'protocol', function protocol() {
  var proto = this.connection.encrypted ? 'https' : 'http';
  var trust = this.app.get('trust proxy fn');

  if (!trust(this.connection.remoteAddress, 0)) {
    return proto;
  }

  // Note: X-Forwarded-Proto is normally only ever a
  //       single value, but this is to be safe.
  var header = this.get('X-Forwarded-Proto') || proto;
  var index = header.indexOf(',');

  return index !== -1 ? header.substring(0, index).trim() : header.trim();
});

/**
 * Short-hand for:
 *
 *    req.protocol === 'https'
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'secure', function secure() {
  return this.protocol === 'https';
});

/**
 * Return the remote address from the trusted proxy.
 *
 * The is the remote address on the socket unless
 * "trust proxy" is set.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'ip', function ip() {
  var trust = this.app.get('trust proxy fn');
  return proxyAddr(this, trust);
});

/**
 * When "trust proxy" is set, trusted proxy addresses + client.
 *
 * For example if the value were "client, proxy1, proxy2"
 * you would receive the array `["client", "proxy1", "proxy2"]`
 * where "proxy2" is the furthest down-stream and "proxy1" and
 * "proxy2" were trusted.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'ips', function ips() {
  var trust = this.app.get('trust proxy fn');
  var addrs = proxyAddr.all(this, trust);

  // reverse the order (to farthest -> closest)
  // and remove socket address
  addrs.reverse().pop();

  return addrs;
});

/**
 * Return subdomains as an array.
 *
 * Subdomains are the dot-separated parts of the host before the main domain of
 * the app. By default, the domain of the app is assumed to be the last two
 * parts of the host. This can be changed by setting "subdomain offset".
 *
 * For example, if the domain is "tobi.ferrets.example.com":
 * If "subdomain offset" is not set, req.subdomains is `["ferrets", "tobi"]`.
 * If "subdomain offset" is 3, req.subdomains is `["tobi"]`.
 *
 * @return {Array}
 * @public
 */

defineGetter(req, 'subdomains', function subdomains() {
  var hostname = this.hostname;

  if (!hostname) return [];

  var offset = this.app.get('subdomain offset');
  var subdomains = !isIP(hostname) ? hostname.split('.').reverse() : [hostname];

  return subdomains.slice(offset);
});

/**
 * Short-hand for `url.parse(req.url).pathname`.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'path', function path$$1() {
  return parseurl_1(this).pathname;
});

/**
 * Parse the "Host" header field to a hostname.
 *
 * When the "trust proxy" setting trusts the socket
 * address, the "X-Forwarded-Host" header field will
 * be trusted.
 *
 * @return {String}
 * @public
 */

defineGetter(req, 'hostname', function hostname() {
  var trust = this.app.get('trust proxy fn');
  var host = this.get('X-Forwarded-Host');

  if (!host || !trust(this.connection.remoteAddress, 0)) {
    host = this.get('Host');
  }

  if (!host) return;

  // IPv6 literal support
  var offset = host[0] === '[' ? host.indexOf(']') + 1 : 0;
  var index = host.indexOf(':', offset);

  return index !== -1 ? host.substring(0, index) : host;
});

// TODO: change req.host to return host in next major

defineGetter(req, 'host', deprecate$2.function(function host() {
  return this.hostname;
}, 'req.host: Use req.hostname instead'));

/**
 * Check if the request is fresh, aka
 * Last-Modified and/or the ETag
 * still match.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'fresh', function () {
  var method = this.method;
  var res = this.res;
  var status = res.statusCode;

  // GET or HEAD for weak freshness validation only
  if ('GET' !== method && 'HEAD' !== method) return false;

  // 2xx or 304 as per rfc2616 14.26
  if (status >= 200 && status < 300 || 304 === status) {
    return fresh_1(this.headers, {
      'etag': res.get('ETag'),
      'last-modified': res.get('Last-Modified')
    });
  }

  return false;
});

/**
 * Check if the request is stale, aka
 * "Last-Modified" and / or the "ETag" for the
 * resource has changed.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'stale', function stale() {
  return !this.fresh;
});

/**
 * Check if the request was an _XMLHttpRequest_.
 *
 * @return {Boolean}
 * @public
 */

defineGetter(req, 'xhr', function xhr() {
  var val = this.get('X-Requested-With') || '';
  return val.toLowerCase() === 'xmlhttprequest';
});

/**
 * Helper function for creating a getter on an object.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} getter
 * @private
 */
function defineGetter(obj, name, getter) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}

var codes$9 = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"306": "(Unused)",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Unordered Collection",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

var codes$a = /*#__PURE__*/Object.freeze({
	default: codes$9
});

var codes$b = ( codes$a && codes$9 ) || codes$a;

/**
 * Module dependencies.
 * @private
 */



/**
 * Module exports.
 * @public
 */

var statuses$3 = status$3;

// array of status codes
status$3.codes = populateStatusesMap$3(status$3, codes$b);

// status codes for redirects
status$3.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true

  // status codes for empty bodies
};status$3.empty = {
  204: true,
  205: true,
  304: true

  // status codes for when you should retry the request
};status$3.retry = {
  502: true,
  503: true,
  504: true

  /**
   * Populate the statuses map for given codes.
   * @private
   */

};function populateStatusesMap$3(statuses, codes) {
  var arr = [];

  Object.keys(codes).forEach(function forEachCode(code) {
    var message = codes[code];
    var status = Number(code);

    // Populate properties
    statuses[status] = message;
    statuses[message] = status;
    statuses[message.toLowerCase()] = status;

    // Add to array
    arr.push(status);
  });

  return arr;
}

/**
 * Get the status code.
 *
 * Given a number, this will throw if it is not a known status
 * code, otherwise the code will be returned. Given a string,
 * the string will be parsed for a number and return the code
 * if valid, otherwise will lookup the code assuming this is
 * the status message.
 *
 * @param {string|number} code
 * @returns {number}
 * @public
 */

function status$3(code) {
  if (typeof code === 'number') {
    if (!status$3[code]) throw new Error('invalid status code: ' + code);
    return code;
  }

  if (typeof code !== 'string') {
    throw new TypeError('code must be a number or string');
  }

  // '403'
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status$3[n]) throw new Error('invalid status code: ' + n);
    return n;
  }

  n = status$3[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}

/**
 * Module dependencies.
 * @private
 */

var Buffer$9 = safeBuffer.Buffer;

var deprecate$3 = depd_1('express');



var isAbsolute = utils$1.isAbsolute;




var sign$1 = cookieSignature.sign;
var normalizeType$1 = utils$1.normalizeType;
var normalizeTypes = utils$1.normalizeTypes;
var setCharset = utils$1.setCharset;


var extname$2 = path.extname;
var mime$1 = send_1.mime;
var resolve$2 = path.resolve;


/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype);

/**
 * Module exports.
 * @public
 */

var response = res;

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function (links) {
  var link = this.get('Link') || '';
  if (link) link += ', ';
  return this.set('Link', link + Object.keys(links).map(function (rel) {
    return '<' + links[rel] + '>; rel="' + rel + '"';
  }).join(', '));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('<p>some html</p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {
      deprecate$3('res.send(body, status): Use res.status(status).send(body) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate$3('res.send(status, body): Use res.status(status).send(body) instead');
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === 'number' && arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get('Content-Type')) {
      this.type('txt');
    }

    deprecate$3('res.send(status): Use res.sendStatus(status) instead');
    this.statusCode = chunk;
    chunk = statuses$3[chunk];
  }

  switch (typeof chunk) {
    // string defaulting to html
    case 'string':
      if (!this.get('Content-Type')) {
        this.type('html');
      }
      break;
    case 'boolean':
    case 'number':
    case 'object':
      if (chunk === null) {
        chunk = '';
      } else if (Buffer$9.isBuffer(chunk)) {
        if (!this.get('Content-Type')) {
          this.type('bin');
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === 'string') {
    encoding = 'utf8';
    type = this.get('Content-Type');

    // reflect this in content-type
    if (typeof type === 'string') {
      this.set('Content-Type', setCharset(type, 'utf-8'));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get('etag fn');
  var generateETag = !this.get('ETag') && typeof etagFn === 'function';

  // populate Content-Length
  var len;
  if (chunk !== undefined) {
    if (Buffer$9.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length;
    } else if (!generateETag && chunk.length < 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer$9.byteLength(chunk, encoding);
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer$9.from(chunk, encoding);
      encoding = undefined;
      len = chunk.length;
    }

    this.set('Content-Length', len);
  }

  // populate ETag
  var etag;
  if (generateETag && len !== undefined) {
    if (etag = etagFn(chunk, encoding)) {
      this.set('ETag', etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader('Content-Type');
    this.removeHeader('Content-Length');
    this.removeHeader('Transfer-Encoding');
    chunk = '';
  }

  if (req.method === 'HEAD') {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate$3('res.json(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate$3('res.json(status, obj): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape');
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify$1(val, replacer, spaces, escape);

  // content-type
  if (!this.get('Content-Type')) {
    this.set('Content-Type', 'application/json');
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === 'number') {
      deprecate$3('res.jsonp(obj, status): Use res.status(status).json(obj) instead');
      this.statusCode = arguments[1];
    } else {
      deprecate$3('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get('json escape');
  var replacer = app.get('json replacer');
  var spaces = app.get('json spaces');
  var body = stringify$1(val, replacer, spaces, escape);
  var callback = this.req.query[app.get('jsonp callback name')];

  // content-type
  if (!this.get('Content-Type')) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'application/json');
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === 'string' && callback.length !== 0) {
    this.set('X-Content-Type-Options', 'nosniff');
    this.set('Content-Type', 'text/javascript');

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, '');

    // replace chars not allowed in JavaScript that are in JSON
    body = body.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');

    // the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"
    // the typeof check is just to reduce client error noise
    body = '/**/ typeof ' + callback + ' === \'function\' && ' + callback + '(' + body + ');';
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses$3[statusCode] || String(statusCode);

  this.statusCode = statusCode;
  this.type('txt');

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path$$1, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path$$1) {
    throw new TypeError('path argument is required to res.sendFile');
  }

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  if (!opts.root && !isAbsolute(path$$1)) {
    throw new TypeError('path must be absolute or specify root to res.sendFile');
  }

  // create file stream
  var pathname = encodeURI(path$$1);
  var file = send_1(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path$$1, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send_1(req, path$$1, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err && err.code === 'EISDIR') return next();

    // next() all but write errors
    if (err && err.code !== 'ECONNABORT' && err.syscall !== 'write') {
      next(err);
    }
  });
};

res.sendfile = deprecate$3.function(res.sendfile, 'res.sendfile: Use res.sendFile instead');

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download(path$$1, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null;

  // support function as second or third arg
  if (typeof filename === 'function') {
    done = filename;
    name = null;
    opts = null;
  } else if (typeof options === 'function') {
    done = options;
    opts = null;
  }

  // set Content-Disposition when file is sent
  var headers = {
    'Content-Disposition': contentDisposition_1(name || path$$1)
  };

  // merge user-provided headers
  if (opts && opts.headers) {
    var keys = Object.keys(opts.headers);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key.toLowerCase() !== 'content-disposition') {
        headers[key] = opts.headers[key];
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts);
  opts.headers = headers;

  // Resolve the full path for sendFile
  var fullPath = resolve$2(path$$1);

  // send file
  return this.sendFile(fullPath, opts, done);
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType = res.type = function contentType(type) {
  var ct = type.indexOf('/') === -1 ? mime$1.lookup(type) : type;

  return this.set('Content-Type', ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      'appliation/json': function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('<p>hey</p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function (obj) {
  var req = this.req;
  var next = req.next;

  var fn = obj.default;
  if (fn) delete obj.default;
  var keys = Object.keys(obj);

  var key = keys.length > 0 ? req.accepts(keys) : false;

  this.vary("Accept");

  if (key) {
    this.set('Content-Type', normalizeType$1(key).value);
    obj[key](req, this, next);
  } else if (fn) {
    fn();
  } else {
    var err = new Error('Not Acceptable');
    err.status = err.statusCode = 406;
    err.types = normalizeTypes(keys).map(function (o) {
      return o.value;
    });
    next(err);
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname$2(filename));
  }

  this.set('Content-Disposition', contentDisposition_1(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);
 *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
 *    res.append('Warning', '199 Miscellaneous warning');
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set = res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val) ? val.map(String) : String(val);

    // add charset to content-type
    if (field.toLowerCase() === 'content-type') {
      if (Array.isArray(value)) {
        throw new TypeError('Content-Type cannot be set to an Array');
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime$1.charsets.lookup(value.split(';')[0]);
        if (charset) value += '; charset=' + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function (field) {
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  var opts = utilsMerge({ expires: new Date(1), path: '/' }, options);

  return this.cookie(name, '', opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // save as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = utilsMerge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }

  var val = typeof value === 'object' ? 'j:' + JSON.stringify(value) : String(value);

  if (signed) {
    val = 's:' + sign$1(val, secret);
  }

  if ('maxAge' in opts) {
    opts.expires = new Date(Date.now() + opts.maxAge);
    opts.maxAge /= 1000;
  }

  if (opts.path == null) {
    opts.path = '/';
  }

  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url$$1) {
  var loc = url$$1;

  // "back" is an alias for the referrer
  if (url$$1 === 'back') {
    loc = this.req.get('Referrer') || '/';
  }

  // set location
  return this.set('Location', encodeurl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @public
 */

res.redirect = function redirect(url$$1) {
  var address = url$$1;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === 'number') {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate$3('res.redirect(url, status): Use res.redirect(status, url) instead');
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get('Location');

  // Support text/{plain,html} by default
  this.format({
    text: function () {
      body = statuses$3[status] + '. Redirecting to ' + address;
    },

    html: function () {
      var u = escapeHtml_1(address);
      body = '<p>' + statuses$3[status] + '. Redirecting to <a href="' + u + '">' + u + '</a></p>';
    },

    default: function () {
      body = '';
    }
  });

  // Respond
  this.statusCode = status;
  this.set('Content-Length', Buffer$9.byteLength(body));

  if (this.req.method === 'HEAD') {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function (field) {
  // checks for back-compat
  if (!field || Array.isArray(field) && !field.length) {
    deprecate$3('res.vary(): Provide a field name');
    return this;
  }

  vary_1(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === 'function') {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error('Request aborted');
    err.code = 'ECONNABORTED';
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error('EISDIR, read');
    err.code = 'EISDIR';
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err && err.code === 'ECONNRESET') return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on('directory', ondirectory);
  file.on('end', onend);
  file.on('error', onerror);
  file.on('file', onfile);
  file.on('stream', onstream);
  onFinished_1(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on('headers', function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replaces
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify$1(value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces ? JSON.stringify(value, replacer, spaces) : JSON.stringify(value);

  if (escape) {
    json = json.replace(/[<>&]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return '\\u003c';
        case 0x3e:
          return '\\u003e';
        case 0x26:
          return '\\u0026';
        default:
          return c;
      }
    });
  }

  return json;
}

/**
 * Module dependencies.
 * @private
 */




var resolve$3 = path.resolve;



/**
 * Module exports.
 * @public
 */

var serveStatic_1 = serveStatic;
var mime$2 = send_1.mime;

/**
 * @param {string} root
 * @param {object} [options]
 * @return {function}
 * @public
 */

function serveStatic(root, options) {
  if (!root) {
    throw new TypeError('root path required');
  }

  if (typeof root !== 'string') {
    throw new TypeError('root path must be a string');
  }

  // copy options object
  var opts = Object.create(options || null);

  // fall-though
  var fallthrough = opts.fallthrough !== false;

  // default redirect
  var redirect = opts.redirect !== false;

  // headers listener
  var setHeaders = opts.setHeaders;

  if (setHeaders && typeof setHeaders !== 'function') {
    throw new TypeError('option setHeaders must be function');
  }

  // setup options for send
  opts.maxage = opts.maxage || opts.maxAge || 0;
  opts.root = resolve$3(root);

  // construct directory listener
  var onDirectory = redirect ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();

  return function serveStatic(req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      if (fallthrough) {
        return next();
      }

      // method not allowed
      res.statusCode = 405;
      res.setHeader('Allow', 'GET, HEAD');
      res.setHeader('Content-Length', '0');
      res.end();
      return;
    }

    var forwardError = !fallthrough;
    var originalUrl = parseurl_1.original(req);
    var path$$1 = parseurl_1(req).pathname;

    // make sure redirect occurs at mount
    if (path$$1 === '/' && originalUrl.pathname.substr(-1) !== '/') {
      path$$1 = '';
    }

    // create send stream
    var stream = send_1(req, path$$1, opts);

    // add directory handler
    stream.on('directory', onDirectory);

    // add headers listener
    if (setHeaders) {
      stream.on('headers', setHeaders);
    }

    // add file listener for fallthrough
    if (fallthrough) {
      stream.on('file', function onFile() {
        // once file is determined, always forward error
        forwardError = true;
      });
    }

    // forward errors
    stream.on('error', function error(err) {
      if (forwardError || !(err.statusCode < 500)) {
        next(err);
        return;
      }

      next();
    });

    // pipe
    stream.pipe(res);
  };
}

/**
 * Collapse all leading slashes into a single slash
 * @private
 */
function collapseLeadingSlashes$1(str) {
  for (var i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) !== 0x2f /* / */) {
        break;
      }
  }

  return i > 1 ? '/' + str.substr(i) : str;
}

/**
* Create a minimal HTML document.
*
* @param {string} title
* @param {string} body
* @private
*/

function createHtmlDocument$2(title, body) {
  return '<!DOCTYPE html>\n' + '<html lang="en">\n' + '<head>\n' + '<meta charset="utf-8">\n' + '<title>' + title + '</title>\n' + '</head>\n' + '<body>\n' + '<pre>' + body + '</pre>\n' + '</body>\n';
}

/**
 * Create a directory listener that just 404s.
 * @private
 */

function createNotFoundDirectoryListener() {
  return function notFound() {
    this.error(404);
  };
}

/**
 * Create a directory listener that performs a redirect.
 * @private
 */

function createRedirectDirectoryListener() {
  return function redirect(res) {
    if (this.hasTrailingSlash()) {
      this.error(404);
      return;
    }

    // get original URL
    var originalUrl = parseurl_1.original(this.req);

    // append trailing slash
    originalUrl.path = null;
    originalUrl.pathname = collapseLeadingSlashes$1(originalUrl.pathname + '/');

    // reformat the URL
    var loc = encodeurl(url.format(originalUrl));
    var doc = createHtmlDocument$2('Redirecting', 'Redirecting to <a href="' + escapeHtml_1(loc) + '">' + escapeHtml_1(loc) + '</a>');

    // send redirect response
    res.statusCode = 301;
    res.setHeader('Content-Type', 'text/html; charset=UTF-8');
    res.setHeader('Content-Length', Buffer.byteLength(doc));
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('Location', loc);
    res.end(doc);
  };
}
serveStatic_1.mime = mime$2;

var express = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 */


var EventEmitter = require$$0.EventEmitter;







/**
 * Expose `createApplication()`.
 */

exports = module.exports = createApplication;

/**
 * Create an express application.
 *
 * @return {Function}
 * @api public
 */

function createApplication() {
  var app = function (req, res, next) {
    app.handle(req, res, next);
  };

  mergeDescriptors(app, EventEmitter.prototype, false);
  mergeDescriptors(app, application, false);

  // expose the prototype that will get set on requests
  app.request = Object.create(request, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  });

  // expose the prototype that will get set on responses
  app.response = Object.create(response, {
    app: { configurable: true, enumerable: true, writable: true, value: app }
  });

  app.init();
  return app;
}

/**
 * Expose the prototypes.
 */

exports.application = application;
exports.request = request;
exports.response = response;

/**
 * Expose constructors.
 */

exports.Route = route;
exports.Router = router;

/**
 * Expose middleware
 */

exports.json = bodyParser_1.json;
exports.query = query;
exports.static = serveStatic_1;
exports.urlencoded = bodyParser_1.urlencoded

/**
 * Replace removed middleware with an appropriate error message.
 */

;['bodyParser', 'compress', 'cookieSession', 'session', 'logger', 'cookieParser', 'favicon', 'responseTime', 'errorHandler', 'timeout', 'methodOverride', 'vhost', 'csrf', 'directory', 'limit', 'multipart', 'staticCache'].forEach(function (name) {
  Object.defineProperty(exports, name, {
    get: function () {
      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');
    },
    configurable: true
  });
});
});
var express_1 = express.application;
var express_2 = express.request;
var express_3 = express.response;
var express_4 = express.Route;
var express_5 = express.Router;
var express_6 = express.json;
var express_7 = express.query;
var express_8 = express.urlencoded;

var express$1 = express;

var create_buffer = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});



var createBuffer = _buffer.Buffer.from && _buffer.Buffer.alloc && _buffer.Buffer.allocUnsafe && _buffer.Buffer.allocUnsafeSlow ? _buffer.Buffer.from

// support for Node < 5.10
: function (val) {
  return new _buffer.Buffer(val);
};

exports.default = createBuffer;
});

unwrapExports(create_buffer);

var define_crc = createCommonjsModule(function (module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (model, calc) {
  var fn = function fn(buf, previous) {
    return calc(buf, previous) >>> 0;
  };
  fn.signed = calc;
  fn.unsigned = fn;
  fn.model = model;

  return fn;
};
});

unwrapExports(define_crc);

var crc1 = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = (0, _define_crc2.default)('crc1', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = ~~previous;
  var accum = 0;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    accum += byte;
  }

  crc += accum % 256;
  return crc % 256;
});
});

unwrapExports(crc1);

var crc8 = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=crc-8 --generate=c`
var TABLE = [0x00, 0x07, 0x0e, 0x09, 0x1c, 0x1b, 0x12, 0x15, 0x38, 0x3f, 0x36, 0x31, 0x24, 0x23, 0x2a, 0x2d, 0x70, 0x77, 0x7e, 0x79, 0x6c, 0x6b, 0x62, 0x65, 0x48, 0x4f, 0x46, 0x41, 0x54, 0x53, 0x5a, 0x5d, 0xe0, 0xe7, 0xee, 0xe9, 0xfc, 0xfb, 0xf2, 0xf5, 0xd8, 0xdf, 0xd6, 0xd1, 0xc4, 0xc3, 0xca, 0xcd, 0x90, 0x97, 0x9e, 0x99, 0x8c, 0x8b, 0x82, 0x85, 0xa8, 0xaf, 0xa6, 0xa1, 0xb4, 0xb3, 0xba, 0xbd, 0xc7, 0xc0, 0xc9, 0xce, 0xdb, 0xdc, 0xd5, 0xd2, 0xff, 0xf8, 0xf1, 0xf6, 0xe3, 0xe4, 0xed, 0xea, 0xb7, 0xb0, 0xb9, 0xbe, 0xab, 0xac, 0xa5, 0xa2, 0x8f, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9d, 0x9a, 0x27, 0x20, 0x29, 0x2e, 0x3b, 0x3c, 0x35, 0x32, 0x1f, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0d, 0x0a, 0x57, 0x50, 0x59, 0x5e, 0x4b, 0x4c, 0x45, 0x42, 0x6f, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7d, 0x7a, 0x89, 0x8e, 0x87, 0x80, 0x95, 0x92, 0x9b, 0x9c, 0xb1, 0xb6, 0xbf, 0xb8, 0xad, 0xaa, 0xa3, 0xa4, 0xf9, 0xfe, 0xf7, 0xf0, 0xe5, 0xe2, 0xeb, 0xec, 0xc1, 0xc6, 0xcf, 0xc8, 0xdd, 0xda, 0xd3, 0xd4, 0x69, 0x6e, 0x67, 0x60, 0x75, 0x72, 0x7b, 0x7c, 0x51, 0x56, 0x5f, 0x58, 0x4d, 0x4a, 0x43, 0x44, 0x19, 0x1e, 0x17, 0x10, 0x05, 0x02, 0x0b, 0x0c, 0x21, 0x26, 0x2f, 0x28, 0x3d, 0x3a, 0x33, 0x34, 0x4e, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5c, 0x5b, 0x76, 0x71, 0x78, 0x7f, 0x6a, 0x6d, 0x64, 0x63, 0x3e, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2c, 0x2b, 0x06, 0x01, 0x08, 0x0f, 0x1a, 0x1d, 0x14, 0x13, 0xae, 0xa9, 0xa0, 0xa7, 0xb2, 0xb5, 0xbc, 0xbb, 0x96, 0x91, 0x98, 0x9f, 0x8a, 0x8d, 0x84, 0x83, 0xde, 0xd9, 0xd0, 0xd7, 0xc2, 0xc5, 0xcc, 0xcb, 0xe6, 0xe1, 0xe8, 0xef, 0xfa, 0xfd, 0xf4, 0xf3];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('crc-8', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = ~~previous;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
  }

  return crc;
});
});

unwrapExports(crc8);

var crc8_1wire = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=dallas-1-wire --generate=c`
var TABLE = [0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83, 0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41, 0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e, 0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc, 0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0, 0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62, 0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d, 0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff, 0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5, 0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07, 0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58, 0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a, 0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6, 0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24, 0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b, 0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9, 0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f, 0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd, 0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92, 0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50, 0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c, 0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee, 0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1, 0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73, 0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49, 0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b, 0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4, 0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16, 0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a, 0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8, 0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7, 0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('dallas-1-wire', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = ~~previous;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = TABLE[(crc ^ byte) & 0xff] & 0xff;
  }

  return crc;
});
});

unwrapExports(crc8_1wire);

var crc16 = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16 --generate=c`
var TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('crc-16', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = ~~previous;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
  }

  return crc;
});
});

unwrapExports(crc16);

var crc16_ccitt = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=ccitt --generate=c`
var TABLE = [0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('ccitt', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = (TABLE[(crc >> 8 ^ byte) & 0xff] ^ crc << 8) & 0xffff;
  }

  return crc;
});
});

unwrapExports(crc16_ccitt);

var crc16_modbus = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=crc-16-modbus --generate=c`
var TABLE = [0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241, 0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440, 0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40, 0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841, 0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40, 0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41, 0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641, 0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040, 0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240, 0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441, 0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41, 0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840, 0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41, 0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40, 0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640, 0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041, 0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240, 0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441, 0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41, 0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840, 0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41, 0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40, 0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640, 0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041, 0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241, 0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440, 0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40, 0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841, 0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40, 0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41, 0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641, 0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('crc-16-modbus', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = typeof previous !== 'undefined' ? ~~previous : 0xffff;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
  }

  return crc;
});
});

unwrapExports(crc16_modbus);

var crc16_xmodem = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

module.exports = (0, _define_crc2.default)('xmodem', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = typeof previous !== 'undefined' ? ~~previous : 0x0;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    var code = crc >>> 8 & 0xFF;

    code ^= byte & 0xFF;
    code ^= code >>> 4;
    crc = crc << 8 & 0xFFFF;
    crc ^= code;
    code = code << 5 & 0xFFFF;
    crc ^= code;
    code = code << 7 & 0xFFFF;
    crc ^= code;
  }

  return crc;
});
});

unwrapExports(crc16_xmodem);

var crc16_kermit = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=kermit --generate=c`
var TABLE = [0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf, 0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7, 0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e, 0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876, 0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd, 0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5, 0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c, 0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974, 0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb, 0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3, 0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a, 0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72, 0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9, 0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1, 0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738, 0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70, 0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7, 0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff, 0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036, 0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e, 0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5, 0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd, 0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134, 0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c, 0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3, 0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb, 0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232, 0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a, 0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1, 0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9, 0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330, 0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('kermit', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = typeof previous !== 'undefined' ? ~~previous : 0x0000;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = (TABLE[(crc ^ byte) & 0xff] ^ crc >> 8) & 0xffff;
  }

  return crc;
});
});

unwrapExports(crc16_kermit);

var crc24 = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-drive --model=crc-24 --generate=c`
var TABLE = [0x000000, 0x864cfb, 0x8ad50d, 0x0c99f6, 0x93e6e1, 0x15aa1a, 0x1933ec, 0x9f7f17, 0xa18139, 0x27cdc2, 0x2b5434, 0xad18cf, 0x3267d8, 0xb42b23, 0xb8b2d5, 0x3efe2e, 0xc54e89, 0x430272, 0x4f9b84, 0xc9d77f, 0x56a868, 0xd0e493, 0xdc7d65, 0x5a319e, 0x64cfb0, 0xe2834b, 0xee1abd, 0x685646, 0xf72951, 0x7165aa, 0x7dfc5c, 0xfbb0a7, 0x0cd1e9, 0x8a9d12, 0x8604e4, 0x00481f, 0x9f3708, 0x197bf3, 0x15e205, 0x93aefe, 0xad50d0, 0x2b1c2b, 0x2785dd, 0xa1c926, 0x3eb631, 0xb8faca, 0xb4633c, 0x322fc7, 0xc99f60, 0x4fd39b, 0x434a6d, 0xc50696, 0x5a7981, 0xdc357a, 0xd0ac8c, 0x56e077, 0x681e59, 0xee52a2, 0xe2cb54, 0x6487af, 0xfbf8b8, 0x7db443, 0x712db5, 0xf7614e, 0x19a3d2, 0x9fef29, 0x9376df, 0x153a24, 0x8a4533, 0x0c09c8, 0x00903e, 0x86dcc5, 0xb822eb, 0x3e6e10, 0x32f7e6, 0xb4bb1d, 0x2bc40a, 0xad88f1, 0xa11107, 0x275dfc, 0xdced5b, 0x5aa1a0, 0x563856, 0xd074ad, 0x4f0bba, 0xc94741, 0xc5deb7, 0x43924c, 0x7d6c62, 0xfb2099, 0xf7b96f, 0x71f594, 0xee8a83, 0x68c678, 0x645f8e, 0xe21375, 0x15723b, 0x933ec0, 0x9fa736, 0x19ebcd, 0x8694da, 0x00d821, 0x0c41d7, 0x8a0d2c, 0xb4f302, 0x32bff9, 0x3e260f, 0xb86af4, 0x2715e3, 0xa15918, 0xadc0ee, 0x2b8c15, 0xd03cb2, 0x567049, 0x5ae9bf, 0xdca544, 0x43da53, 0xc596a8, 0xc90f5e, 0x4f43a5, 0x71bd8b, 0xf7f170, 0xfb6886, 0x7d247d, 0xe25b6a, 0x641791, 0x688e67, 0xeec29c, 0x3347a4, 0xb50b5f, 0xb992a9, 0x3fde52, 0xa0a145, 0x26edbe, 0x2a7448, 0xac38b3, 0x92c69d, 0x148a66, 0x181390, 0x9e5f6b, 0x01207c, 0x876c87, 0x8bf571, 0x0db98a, 0xf6092d, 0x7045d6, 0x7cdc20, 0xfa90db, 0x65efcc, 0xe3a337, 0xef3ac1, 0x69763a, 0x578814, 0xd1c4ef, 0xdd5d19, 0x5b11e2, 0xc46ef5, 0x42220e, 0x4ebbf8, 0xc8f703, 0x3f964d, 0xb9dab6, 0xb54340, 0x330fbb, 0xac70ac, 0x2a3c57, 0x26a5a1, 0xa0e95a, 0x9e1774, 0x185b8f, 0x14c279, 0x928e82, 0x0df195, 0x8bbd6e, 0x872498, 0x016863, 0xfad8c4, 0x7c943f, 0x700dc9, 0xf64132, 0x693e25, 0xef72de, 0xe3eb28, 0x65a7d3, 0x5b59fd, 0xdd1506, 0xd18cf0, 0x57c00b, 0xc8bf1c, 0x4ef3e7, 0x426a11, 0xc426ea, 0x2ae476, 0xaca88d, 0xa0317b, 0x267d80, 0xb90297, 0x3f4e6c, 0x33d79a, 0xb59b61, 0x8b654f, 0x0d29b4, 0x01b042, 0x87fcb9, 0x1883ae, 0x9ecf55, 0x9256a3, 0x141a58, 0xefaaff, 0x69e604, 0x657ff2, 0xe33309, 0x7c4c1e, 0xfa00e5, 0xf69913, 0x70d5e8, 0x4e2bc6, 0xc8673d, 0xc4fecb, 0x42b230, 0xddcd27, 0x5b81dc, 0x57182a, 0xd154d1, 0x26359f, 0xa07964, 0xace092, 0x2aac69, 0xb5d37e, 0x339f85, 0x3f0673, 0xb94a88, 0x87b4a6, 0x01f85d, 0x0d61ab, 0x8b2d50, 0x145247, 0x921ebc, 0x9e874a, 0x18cbb1, 0xe37b16, 0x6537ed, 0x69ae1b, 0xefe2e0, 0x709df7, 0xf6d10c, 0xfa48fa, 0x7c0401, 0x42fa2f, 0xc4b6d4, 0xc82f22, 0x4e63d9, 0xd11cce, 0x575035, 0x5bc9c3, 0xdd8538];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('crc-24', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = typeof previous !== 'undefined' ? ~~previous : 0xb704ce;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = (TABLE[(crc >> 16 ^ byte) & 0xff] ^ crc << 8) & 0xffffff;
  }

  return crc;
});
});

unwrapExports(crc24);

var crc32 = createCommonjsModule(function (module) {





var _create_buffer2 = _interopRequireDefault(create_buffer);



var _define_crc2 = _interopRequireDefault(define_crc);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`
var TABLE = [0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d];

if (typeof Int32Array !== 'undefined') TABLE = new Int32Array(TABLE);

module.exports = (0, _define_crc2.default)('crc-32', function (buf, previous) {
  if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

  var crc = previous === 0 ? 0 : ~~previous ^ -1;

  for (var index = 0; index < buf.length; index++) {
    var byte = buf[index];
    crc = TABLE[(crc ^ byte) & 0xff] ^ crc >>> 8;
  }

  return crc ^ -1;
});
});

unwrapExports(crc32);

var lib$3 = {
  crc1: crc1,
  crc8: crc8,
  crc81wire: crc8_1wire,
  crc16: crc16,
  crc16ccitt: crc16_ccitt,
  crc16modbus: crc16_modbus,
  crc16xmodem: crc16_xmodem,
  crc16kermit: crc16_kermit,
  crc24: crc24,
  crc32: crc32
};

var debug$g = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$6 = debug$g.coerce;
var debug_2$6 = debug$g.disable;
var debug_3$6 = debug$g.enable;
var debug_4$6 = debug$g.enabled;
var debug_5$6 = debug$g.humanize;
var debug_6$6 = debug$g.names;
var debug_7$6 = debug$g.skips;
var debug_8$6 = debug$g.formatters;

var browser$6 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$g;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$6 = browser$6.log;
var browser_2$6 = browser$6.formatArgs;
var browser_3$6 = browser$6.save;
var browser_4$6 = browser$6.load;
var browser_5$6 = browser$6.useColors;
var browser_6$6 = browser$6.storage;
var browser_7$6 = browser$6.colors;

var node$6 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$g;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$6 = node$6.init;
var node_2$6 = node$6.log;
var node_3$6 = node$6.formatArgs;
var node_4$6 = node$6.save;
var node_5$6 = node$6.load;
var node_6$6 = node$6.useColors;
var node_7$6 = node$6.colors;
var node_8$6 = node$6.inspectOpts;

var src$6 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$6;
} else {
  module.exports = node$6;
}
});

/**
 * Module dependencies.
 * @private
 */



/**
 * Module variables.
 * @private
 */

var EQUAL_END_REGEXP = /=+$/;
var PLUS_GLOBAL_REGEXP$2 = /\+/g;
var SLASH_GLOBAL_REGEXP$2 = /\//g;

/**
 * Module exports.
 * @public
 */

var uidSafe$1 = uid$1;
var sync$2 = uidSync$1;

/**
 * Create a unique ID.
 *
 * @param {number} length
 * @param {function} [callback]
 * @return {Promise}
 * @public
 */

function uid$1(length, callback) {
  // validate callback is a function, if provided
  if (callback !== undefined && typeof callback !== 'function') {
    throw new TypeError('argument callback must be a function');
  }

  // require the callback without promises
  if (!callback && !commonjsGlobal.Promise) {
    throw new TypeError('argument callback is required');
  }

  if (callback) {
    // classic callback style
    return generateUid$1(length, callback);
  }

  return new Promise(function executor(resolve, reject) {
    generateUid$1(length, function onUid(err, str) {
      if (err) return reject(err);
      resolve(str);
    });
  });
}

/**
 * Create a unique ID sync.
 *
 * @param {number} length
 * @return {string}
 * @public
 */

function uidSync$1(length) {
  return toString$3(randomBytes_1.sync(length));
}

/**
 * Generate a unique ID string.
 *
 * @param {number} length
 * @param {function} callback
 * @private
 */

function generateUid$1(length, callback) {
  randomBytes_1(length, function (err, buf) {
    if (err) return callback(err);
    callback(null, toString$3(buf));
  });
}

/**
 * Change a Buffer into a string.
 *
 * @param {Buffer} buf
 * @return {string}
 * @private
 */

function toString$3(buf) {
  return buf.toString('base64').replace(EQUAL_END_REGEXP, '').replace(PLUS_GLOBAL_REGEXP$2, '-').replace(SLASH_GLOBAL_REGEXP$2, '_');
}
uidSafe$1.sync = sync$2;

/*!
 * Connect - session - Session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Expose Session.
 */

var session = Session;

/**
 * Create a new `Session` with the given request and `data`.
 *
 * @param {IncomingRequest} req
 * @param {Object} data
 * @api private
 */

function Session(req, data) {
  Object.defineProperty(this, 'req', { value: req });
  Object.defineProperty(this, 'id', { value: req.sessionID });

  if (typeof data === 'object' && data !== null) {
    // merge data into this, ignoring prototype properties
    for (var prop in data) {
      if (!(prop in this)) {
        this[prop] = data[prop];
      }
    }
  }
}

/**
 * Update reset `.cookie.maxAge` to prevent
 * the cookie from expiring when the
 * session is still active.
 *
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'touch', function touch() {
  return this.resetMaxAge();
});

/**
 * Reset `.maxAge` to `.originalMaxAge`.
 *
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'resetMaxAge', function resetMaxAge() {
  this.cookie.maxAge = this.cookie.originalMaxAge;
  return this;
});

/**
 * Save the session data with optional callback `fn(err)`.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'save', function save(fn) {
  this.req.sessionStore.set(this.id, this, fn || function () {});
  return this;
});

/**
 * Re-loads the session data _without_ altering
 * the maxAge properties. Invokes the callback `fn(err)`,
 * after which time if no exception has occurred the
 * `req.session` property will be a new `Session` object,
 * although representing the same session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'reload', function reload(fn) {
  var req = this.req,
      store = this.req.sessionStore;
  store.get(this.id, function (err, sess) {
    if (err) return fn(err);
    if (!sess) return fn(new Error('failed to load session'));
    store.createSession(req, sess);
    fn();
  });
  return this;
});

/**
 * Destroy `this` session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'destroy', function destroy(fn) {
  delete this.req.session;
  this.req.sessionStore.destroy(this.id, fn);
  return this;
});

/**
 * Regenerate this request's session.
 *
 * @param {Function} fn
 * @return {Session} for chaining
 * @api public
 */

defineMethod(Session.prototype, 'regenerate', function regenerate(fn) {
  this.req.sessionStore.regenerate(this.req, fn);
  return this;
});

/**
 * Helper function for creating a method on a prototype.
 *
 * @param {Object} obj
 * @param {String} name
 * @param {Function} fn
 * @private
 */
function defineMethod(obj, name, fn) {
  Object.defineProperty(obj, name, {
    configurable: true,
    enumerable: false,
    value: fn,
    writable: true
  });
}

var cookie_1 = createCommonjsModule(function (module) {

/**
 * Module dependencies.
 */



/**
 * Initialize a new `Cookie` with the given `options`.
 *
 * @param {IncomingMessage} req
 * @param {Object} options
 * @api private
 */

var Cookie = module.exports = function Cookie(options) {
  this.path = '/';
  this.maxAge = null;
  this.httpOnly = true;
  if (options) utilsMerge(this, options);
  this.originalMaxAge = undefined == this.originalMaxAge ? this.maxAge : this.originalMaxAge;
};

/*!
 * Prototype.
 */

Cookie.prototype = {

  /**
   * Set expires `date`.
   *
   * @param {Date} date
   * @api public
   */

  set expires(date) {
    this._expires = date;
    this.originalMaxAge = this.maxAge;
  },

  /**
   * Get expires `date`.
   *
   * @return {Date}
   * @api public
   */

  get expires() {
    return this._expires;
  },

  /**
   * Set expires via max-age in `ms`.
   *
   * @param {Number} ms
   * @api public
   */

  set maxAge(ms) {
    this.expires = 'number' == typeof ms ? new Date(Date.now() + ms) : ms;
  },

  /**
   * Get expires max-age in `ms`.
   *
   * @return {Number}
   * @api public
   */

  get maxAge() {
    return this.expires instanceof Date ? this.expires.valueOf() - Date.now() : this.expires;
  },

  /**
   * Return cookie data object.
   *
   * @return {Object}
   * @api private
   */

  get data() {
    return {
      originalMaxAge: this.originalMaxAge,
      expires: this._expires,
      secure: this.secure,
      httpOnly: this.httpOnly,
      domain: this.domain,
      path: this.path,
      sameSite: this.sameSite
    };
  },

  /**
   * Return a serialized cookie string.
   *
   * @return {String}
   * @api public
   */

  serialize: function (name, val) {
    return cookie.serialize(name, val, this.data);
  },

  /**
   * Return JSON representation of this cookie.
   *
   * @return {Object}
   * @api private
   */

  toJSON: function () {
    return this.data;
  }
};
});

/**
 * Module dependencies.
 * @private
 */


var EventEmitter = require$$0.EventEmitter;



/**
 * Module exports.
 * @public
 */

var store = Store;

/**
 * Abstract base class for session stores.
 * @public
 */

function Store() {
  EventEmitter.call(this);
}

/**
 * Inherit from EventEmitter.
 */

util.inherits(Store, EventEmitter);

/**
 * Re-generate the given requests's session.
 *
 * @param {IncomingRequest} req
 * @return {Function} fn
 * @api public
 */

Store.prototype.regenerate = function (req, fn) {
  var self = this;
  this.destroy(req.sessionID, function (err) {
    self.generate(req);
    fn(err);
  });
};

/**
 * Load a `Session` instance via the given `sid`
 * and invoke the callback `fn(err, sess)`.
 *
 * @param {String} sid
 * @param {Function} fn
 * @api public
 */

Store.prototype.load = function (sid, fn) {
  var self = this;
  this.get(sid, function (err, sess) {
    if (err) return fn(err);
    if (!sess) return fn();
    var req = { sessionID: sid, sessionStore: self };
    fn(null, self.createSession(req, sess));
  });
};

/**
 * Create session from JSON `sess` data.
 *
 * @param {IncomingRequest} req
 * @param {Object} sess
 * @return {Session}
 * @api private
 */

Store.prototype.createSession = function (req, sess) {
  var expires = sess.cookie.expires,
      orig = sess.cookie.originalMaxAge;
  sess.cookie = new cookie_1(sess.cookie);
  if ('string' == typeof expires) sess.cookie.expires = new Date(expires);
  sess.cookie.originalMaxAge = orig;
  req.session = new session(req, sess);
  return req.session;
};

/**
 * Module dependencies.
 * @private
 */




/**
 * Shim setImmediate for node.js < 0.10
 * @private
 */

/* istanbul ignore next */
var defer$2 = typeof setImmediate === 'function' ? setImmediate : function (fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};

/**
 * Module exports.
 */

var memory = MemoryStore;

/**
 * A session store in memory.
 * @public
 */

function MemoryStore() {
  store.call(this);
  this.sessions = Object.create(null);
}

/**
 * Inherit from Store.
 */

util.inherits(MemoryStore, store);

/**
 * Get all active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.all = function all(callback) {
  var sessionIds = Object.keys(this.sessions);
  var sessions = Object.create(null);

  for (var i = 0; i < sessionIds.length; i++) {
    var sessionId = sessionIds[i];
    var session = getSession.call(this, sessionId);

    if (session) {
      sessions[sessionId] = session;
    }
  }

  callback && defer$2(callback, null, sessions);
};

/**
 * Clear all sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.clear = function clear(callback) {
  this.sessions = Object.create(null);
  callback && defer$2(callback);
};

/**
 * Destroy the session associated with the given session ID.
 *
 * @param {string} sessionId
 * @public
 */

MemoryStore.prototype.destroy = function destroy(sessionId, callback) {
  delete this.sessions[sessionId];
  callback && defer$2(callback);
};

/**
 * Fetch session by the given session ID.
 *
 * @param {string} sessionId
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.get = function get(sessionId, callback) {
  defer$2(callback, null, getSession.call(this, sessionId));
};

/**
 * Commit the given session associated with the given sessionId to the store.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.set = function set(sessionId, session, callback) {
  this.sessions[sessionId] = JSON.stringify(session);
  callback && defer$2(callback);
};

/**
 * Get number of active sessions.
 *
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.length = function length(callback) {
  this.all(function (err, sessions) {
    if (err) return callback(err);
    callback(null, Object.keys(sessions).length);
  });
};

/**
 * Touch the given session object associated with the given session ID.
 *
 * @param {string} sessionId
 * @param {object} session
 * @param {function} callback
 * @public
 */

MemoryStore.prototype.touch = function touch(sessionId, session, callback) {
  var currentSession = getSession.call(this, sessionId);

  if (currentSession) {
    // update expiration
    currentSession.cookie = session.cookie;
    this.sessions[sessionId] = JSON.stringify(currentSession);
  }

  callback && defer$2(callback);
};

/**
 * Get session from the store.
 * @private
 */

function getSession(sessionId) {
  var sess = this.sessions[sessionId];

  if (!sess) {
    return;
  }

  // parse
  sess = JSON.parse(sess);

  var expires = typeof sess.cookie.expires === 'string' ? new Date(sess.cookie.expires) : sess.cookie.expires;

  // destroy expired session
  if (expires && expires <= Date.now()) {
    delete this.sessions[sessionId];
    return;
  }

  return sess;
}

var expressSession = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @private
 */


var crc = lib$3.crc32;
var debug = src$6('express-session');
var deprecate = depd_1('express-session');

var uid = uidSafe$1.sync;



// environment

var env = process.env.NODE_ENV;

/**
 * Expose the middleware.
 */

exports = module.exports = session$$1;

/**
 * Expose constructors.
 */

exports.Store = store;
exports.Cookie = cookie_1;
exports.Session = session;
exports.MemoryStore = memory;

/**
 * Warning message for `MemoryStore` usage in production.
 * @private
 */

var warning = 'Warning: connect.session() MemoryStore is not\n' + 'designed for a production environment, as it will leak\n' + 'memory, and will not scale past a single process.';

/**
 * Node.js 0.8+ async implementation.
 * @private
 */

/* istanbul ignore next */
var defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};

/**
 * Setup session store with the given `options`.
 *
 * @param {Object} [options]
 * @param {Object} [options.cookie] Options for cookie
 * @param {Function} [options.genid]
 * @param {String} [options.name=connect.sid] Session ID cookie name
 * @param {Boolean} [options.proxy]
 * @param {Boolean} [options.resave] Resave unmodified sessions back to the store
 * @param {Boolean} [options.rolling] Enable/disable rolling session expiration
 * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store
 * @param {String|Array} [options.secret] Secret for signing session ID
 * @param {Object} [options.store=MemoryStore] Session store
 * @param {String} [options.unset]
 * @return {Function} middleware
 * @public
 */

function session$$1(options) {
  var opts = options || {};

  // get the cookie options
  var cookieOptions = opts.cookie || {};

  // get the session id generate function
  var generateId = opts.genid || generateSessionId;

  // get the session cookie name
  var name = opts.name || opts.key || 'connect.sid';

  // get the session store
  var store$$1 = opts.store || new memory();

  // get the trust proxy setting
  var trustProxy = opts.proxy;

  // get the resave session option
  var resaveSession = opts.resave;

  // get the rolling session option
  var rollingSessions = Boolean(opts.rolling);

  // get the save uninitialized session option
  var saveUninitializedSession = opts.saveUninitialized;

  // get the cookie signing secret
  var secret = opts.secret;

  if (typeof generateId !== 'function') {
    throw new TypeError('genid option must be a function');
  }

  if (resaveSession === undefined) {
    deprecate('undefined resave option; provide resave option');
    resaveSession = true;
  }

  if (saveUninitializedSession === undefined) {
    deprecate('undefined saveUninitialized option; provide saveUninitialized option');
    saveUninitializedSession = true;
  }

  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {
    throw new TypeError('unset option must be "destroy" or "keep"');
  }

  // TODO: switch to "destroy" on next major
  var unsetDestroy = opts.unset === 'destroy';

  if (Array.isArray(secret) && secret.length === 0) {
    throw new TypeError('secret option array must contain one or more strings');
  }

  if (secret && !Array.isArray(secret)) {
    secret = [secret];
  }

  if (!secret) {
    deprecate('req.secret; provide secret option');
  }

  // notify user that this store is not
  // meant for a production environment
  /* istanbul ignore next: not tested */
  if ('production' == env && store$$1 instanceof memory) {
    console.warn(warning);
  }

  // generates the new session
  store$$1.generate = function (req) {
    req.sessionID = generateId(req);
    req.session = new session(req);
    req.session.cookie = new cookie_1(cookieOptions);

    if (cookieOptions.secure === 'auto') {
      req.session.cookie.secure = issecure(req, trustProxy);
    }
  };

  var storeImplementsTouch = typeof store$$1.touch === 'function';

  // register event listeners for the store to track readiness
  var storeReady = true;
  store$$1.on('disconnect', function ondisconnect() {
    storeReady = false;
  });
  store$$1.on('connect', function onconnect() {
    storeReady = true;
  });

  return function session$$1(req, res, next) {
    // self-awareness
    if (req.session) {
      next();
      return;
    }

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    if (!storeReady) {
      debug('store is disconnected');
      next();
      return;
    }

    // pathname mismatch
    var originalPath = parseurl_1.original(req).pathname || '/';
    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();

    // ensure a secret is available or bail
    if (!secret && !req.secret) {
      next(new Error('secret option required for sessions'));
      return;
    }

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    var secrets = secret || [req.secret];

    var originalHash;
    var originalId;
    var savedHash;
    var touched = false;

    // expose store
    req.sessionStore = store$$1;

    // get the session ID from the cookie
    var cookieId = req.sessionID = getcookie(req, name, secrets);

    // set-cookie
    onHeaders(res, function () {
      if (!req.session) {
        debug('no session');
        return;
      }

      if (!shouldSetCookie(req)) {
        return;
      }

      // only send secure cookies via https
      if (req.session.cookie.secure && !issecure(req, trustProxy)) {
        debug('not secured');
        return;
      }

      if (!touched) {
        // touch session
        req.session.touch();
        touched = true;
      }

      // set cookie
      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);
    });

    // proxy end() to commit the session
    var _end = res.end;
    var _write = res.write;
    var ended = false;
    res.end = function end(chunk, encoding) {
      if (ended) {
        return false;
      }

      ended = true;

      var ret;
      var sync = true;

      function writeend() {
        if (sync) {
          ret = _end.call(res, chunk, encoding);
          sync = false;
          return;
        }

        _end.call(res);
      }

      function writetop() {
        if (!sync) {
          return ret;
        }

        if (chunk == null) {
          ret = true;
          return ret;
        }

        var contentLength = Number(res.getHeader('Content-Length'));

        if (!isNaN(contentLength) && contentLength > 0) {
          // measure chunk
          chunk = !Buffer.isBuffer(chunk) ? new Buffer(chunk, encoding) : chunk;
          encoding = undefined;

          if (chunk.length !== 0) {
            debug('split response');
            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
            chunk = chunk.slice(chunk.length - 1, chunk.length);
            return ret;
          }
        }

        ret = _write.call(res, chunk, encoding);
        sync = false;

        return ret;
      }

      if (shouldDestroy(req)) {
        // destroy session
        debug('destroying');
        store$$1.destroy(req.sessionID, function ondestroy(err) {
          if (err) {
            defer(next, err);
          }

          debug('destroyed');
          writeend();
        });

        return writetop();
      }

      // no session to save
      if (!req.session) {
        debug('no session');
        return _end.call(res, chunk, encoding);
      }

      if (!touched) {
        // touch session
        req.session.touch();
        touched = true;
      }

      if (shouldSave(req)) {
        req.session.save(function onsave(err) {
          if (err) {
            defer(next, err);
          }

          writeend();
        });

        return writetop();
      } else if (storeImplementsTouch && shouldTouch(req)) {
        // store implements touch method
        debug('touching');
        store$$1.touch(req.sessionID, req.session, function ontouch(err) {
          if (err) {
            defer(next, err);
          }

          debug('touched');
          writeend();
        });

        return writetop();
      }

      return _end.call(res, chunk, encoding);
    };

    // generate the session
    function generate() {
      store$$1.generate(req);
      originalId = req.sessionID;
      originalHash = hash(req.session);
      wrapmethods(req.session);
    }

    // wrap session methods
    function wrapmethods(sess) {
      var _reload = sess.reload;
      var _save = sess.save;

      function reload(callback) {
        debug('reloading %s', this.id);
        _reload.call(this, function () {
          wrapmethods(req.session);
          callback.apply(this, arguments);
        });
      }

      function save() {
        debug('saving %s', this.id);
        savedHash = hash(this);
        _save.apply(this, arguments);
      }

      Object.defineProperty(sess, 'reload', {
        configurable: true,
        enumerable: false,
        value: reload,
        writable: true
      });

      Object.defineProperty(sess, 'save', {
        configurable: true,
        enumerable: false,
        value: save,
        writable: true
      });
    }

    // check if session has been modified
    function isModified(sess) {
      return originalId !== sess.id || originalHash !== hash(sess);
    }

    // check if session has been saved
    function isSaved(sess) {
      return originalId === sess.id && savedHash === hash(sess);
    }

    // determine if session should be destroyed
    function shouldDestroy(req) {
      return req.sessionID && unsetDestroy && req.session == null;
    }

    // determine if session should be saved to store
    function shouldSave(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }

      return !saveUninitializedSession && cookieId !== req.sessionID ? isModified(req.session) : !isSaved(req.session);
    }

    // determine if session should be touched
    function shouldTouch(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }

      return cookieId === req.sessionID && !shouldSave(req);
    }

    // determine if cookie should be set on response
    function shouldSetCookie(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        return false;
      }

      return cookieId != req.sessionID ? saveUninitializedSession || isModified(req.session) : rollingSessions || req.session.cookie.expires != null && isModified(req.session);
    }

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next();
      return;
    }

    // generate the session object
    debug('fetching %s', req.sessionID);
    store$$1.get(req.sessionID, function (err, sess) {
      // error handling
      if (err) {
        debug('error %j', err);

        if (err.code !== 'ENOENT') {
          next(err);
          return;
        }

        generate();
        // no session
      } else if (!sess) {
        debug('no session found');
        generate();
        // populate req.session
      } else {
        debug('session found');
        store$$1.createSession(req, sess);
        originalId = req.sessionID;
        originalHash = hash(sess);

        if (!resaveSession) {
          savedHash = originalHash;
        }

        wrapmethods(req.session);
      }

      next();
    });
  };
}
/**
 * Generate a session ID for a new session.
 *
 * @return {String}
 * @private
 */

function generateSessionId(sess) {
  return uid(24);
}

/**
 * Get the session ID cookie from request.
 *
 * @return {string}
 * @private
 */

function getcookie(req, name, secrets) {
  var header = req.headers.cookie;
  var raw;
  var val;

  // read from cookie header
  if (header) {
    var cookies = cookie.parse(header);

    raw = cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);

        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned');
      }
    }
  }

  // back-compat read from cookieParser() signedCookies data
  if (!val && req.signedCookies) {
    val = req.signedCookies[name];

    if (val) {
      deprecate('cookie should be available in req.headers.cookie');
    }
  }

  // back-compat read from cookieParser() cookies data
  if (!val && req.cookies) {
    raw = req.cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);

        if (val) {
          deprecate('cookie should be available in req.headers.cookie');
        }

        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned');
      }
    }
  }

  return val;
}

/**
 * Hash the given `sess` object omitting changes to `.cookie`.
 *
 * @param {Object} sess
 * @return {String}
 * @private
 */

function hash(sess) {
  return crc(JSON.stringify(sess, function (key, val) {
    // ignore sess.cookie property
    if (this === sess && key === 'cookie') {
      return;
    }

    return val;
  }));
}

/**
 * Determine if request is secure.
 *
 * @param {Object} req
 * @param {Boolean} [trustProxy]
 * @return {Boolean}
 * @private
 */

function issecure(req, trustProxy) {
  // socket is https server
  if (req.connection && req.connection.encrypted) {
    return true;
  }

  // do not trust proxy
  if (trustProxy === false) {
    return false;
  }

  // no explicit trust; try req.secure from express
  if (trustProxy !== true) {
    var secure = req.secure;
    return typeof secure === 'boolean' ? secure : false;
  }

  // read the proto from x-forwarded-proto header
  var header = req.headers['x-forwarded-proto'] || '';
  var index = header.indexOf(',');
  var proto = index !== -1 ? header.substr(0, index).toLowerCase().trim() : header.toLowerCase().trim();

  return proto === 'https';
}

/**
 * Set cookie on response.
 *
 * @private
 */

function setcookie(res, name, val, secret, options) {
  var signed = 's:' + cookieSignature.sign(val, secret);
  var data = cookie.serialize(name, signed, options);

  debug('set-cookie %s', data);

  var prev = res.getHeader('set-cookie') || [];
  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];

  res.setHeader('set-cookie', header);
}

/**
 * Verify and decode the given `val` with `secrets`.
 *
 * @param {String} val
 * @param {Array} secrets
 * @returns {String|Boolean}
 * @private
 */
function unsigncookie(val, secrets) {
  for (var i = 0; i < secrets.length; i++) {
    var result = cookieSignature.unsign(val, secrets[i]);

    if (result !== false) {
      return result;
    }
  }

  return false;
}
});
var expressSession_1 = expressSession.Store;
var expressSession_2 = expressSession.Cookie;
var expressSession_3 = expressSession.Session;
var expressSession_4 = expressSession.MemoryStore;

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {/**/}

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || typeof target !== 'object' && typeof target !== 'function') {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						target[name] = copy;
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var camelize = function (obj) {
    if (typeof obj === 'string') return camelCase(obj);
    return walk(obj);
};

function walk(obj) {
    if (!obj || typeof obj !== 'object') return obj;
    if (isDate(obj) || isRegex(obj)) return obj;
    if (isArray$1(obj)) return map$1(obj, walk);
    return reduce(objectKeys(obj), function (acc, key) {
        var camel = camelCase(key);
        acc[camel] = walk(obj[key]);
        return acc;
    }, {});
}

function camelCase(str) {
    return str.replace(/[_.-](\w|$)/g, function (_, x) {
        return x.toUpperCase();
    });
}

var isArray$1 = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

var isDate = function (obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
};

var isRegex = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var has$1 = Object.prototype.hasOwnProperty;
var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        if (has$1.call(obj, key)) keys.push(key);
    }
    return keys;
};

function map$1(xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
    }
    return res;
}

function reduce(xs, f, acc) {
    if (xs.reduce) return xs.reduce(f, acc);
    for (var i = 0; i < xs.length; i++) {
        acc = f(acc, xs[i], i);
    }
    return acc;
}

var contentSecurityPolicyBuilder = function (options) {
  var directives = options.directives;

  var keysSeen = {};

  return Object.keys(directives).reduce(function (result, originalKey) {
    var directive = dashify(originalKey);

    if (keysSeen[directive]) {
      throw new Error(originalKey + ' is specified more than once');
    }
    keysSeen[directive] = true;

    var value = directives[originalKey];
    if (Array.isArray(value)) {
      value = value.join(' ');
    } else if (value === true) {
      value = '';
    } else if (value === false) {
      return result;
    }

    if (value) {
      return result.concat(directive + ' ' + value);
    } else {
      return result.concat(directive);
    }
  }, []).join('; ');
};

function dashify(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

var isFunction = function isFunction(value) {
  return value instanceof Function;
};

var platform = createCommonjsModule(function (module, exports) {
(function () {

  /** Used to determine if values are of the language type `Object`. */

  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = objectTypes[typeof window] && window || this;

  /** Detect free variable `exports`. */
  var freeExports = exports;

  /** Detect free variable `module`. */
  var freeModule = module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4': '10 Technical Preview',
      '6.3': '8.1',
      '6.2': '8',
      '6.1': 'Server 2008 R2 / 7',
      '6.0': 'Server 2008 / Vista',
      '5.2': 'Server 2003 / XP 64-bit',
      '5.1': 'XP',
      '5.01': '2000 SP1',
      '5.0': '2000',
      '4.0': 'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_PowerPC\b/i, ' OS').replace(/\b(OS X) [^ \d]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1').split(' on ')[0]);

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return (/^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string)
    );
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function (value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = isCustomContext && context.java ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera['[[Class]]'] : getClassOf(opera)) ? operaClass : opera = null;

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([{ 'label': 'EdgeHTML', 'pattern': 'Edge' }, 'Trident', { 'label': 'WebKit', 'pattern': 'AppleWebKit' }, 'iCab', 'Presto', 'NetFront', 'Tasman', 'KHTML', 'Gecko']);

    /* Detectable browser names (order is important). */
    var name = getName(['Adobe AIR', 'Arora', 'Avant Browser', 'Breach', 'Camino', 'Electron', 'Epiphany', 'Fennec', 'Flock', 'Galeon', 'GreenBrowser', 'iCab', 'Iceweasel', 'K-Meleon', 'Konqueror', 'Lunascape', 'Maxthon', { 'label': 'Microsoft Edge', 'pattern': 'Edge' }, 'Midori', 'Nook Browser', 'PaleMoon', 'PhantomJS', 'Raven', 'Rekonq', 'RockMelt', { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' }, 'SeaMonkey', { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' }, 'Sleipnir', 'SlimBrowser', { 'label': 'SRWare Iron', 'pattern': 'Iron' }, 'Sunrise', 'Swiftfox', 'Waterfox', 'WebPositive', 'Opera Mini', { 'label': 'Opera Mini', 'pattern': 'OPiOS' }, 'Opera', { 'label': 'Opera', 'pattern': 'OPR' }, 'Chrome', { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' }, { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' }, { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' }, { 'label': 'IE', 'pattern': 'IEMobile' }, { 'label': 'IE', 'pattern': 'MSIE' }, 'Safari']);

    /* Detectable products (order is important). */
    var product = getProduct([{ 'label': 'BlackBerry', 'pattern': 'BB10' }, 'BlackBerry', { 'label': 'Galaxy S', 'pattern': 'GT-I9000' }, { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' }, { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' }, { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' }, { 'label': 'Galaxy S5', 'pattern': 'SM-G900' }, { 'label': 'Galaxy S6', 'pattern': 'SM-G920' }, { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' }, { 'label': 'Galaxy S7', 'pattern': 'SM-G930' }, { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' }, 'Google TV', 'Lumia', 'iPad', 'iPod', 'iPhone', 'Kindle', { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' }, 'Nexus', 'Nook', 'PlayBook', 'PlayStation Vita', 'PlayStation', 'TouchPad', 'Transformer', { 'label': 'Wii U', 'pattern': 'WiiU' }, 'Wii', 'Xbox One', { 'label': 'Xbox 360', 'pattern': 'Xbox' }, 'Xoom']);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1, 'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS(['Windows Phone', 'Android', 'CentOS', { 'label': 'Chrome OS', 'pattern': 'CrOS' }, 'Debian', 'Fedora', 'FreeBSD', 'Gentoo', 'Haiku', 'Kubuntu', 'Linux Mint', 'OpenBSD', 'Red Hat', 'SuSE', 'Ubuntu', 'Xubuntu', 'Cygwin', 'Symbian OS', 'hpwOS', 'webOS ', 'webOS', 'Tablet OS', 'Tizen', 'Linux', 'Mac OS X', 'Macintosh', 'Mac', 'Windows 98;', 'Windows ']);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function (result, guess) {
        return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function (result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function (result, guess) {
        return result || RegExp('\\b' + (guess.pattern || qualify(guess)) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function (result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result = RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua))) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function (result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result = RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) || RegExp('\\b' + pattern + ' *\\w+-[\\w]*', 'i').exec(ua) || RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua))) {
          // Split by forward slash and append product version if needed.
          if ((result = String(guess.label && !RegExp(pattern, 'i').test(guess.label) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0].replace(RegExp(pattern, 'i'), guess).replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ').replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function (result, pattern) {
        return result || (RegExp(pattern + '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if (data = /\bGoogle TV\b/.exec(product)) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
        name || (name = 'Safari');
        os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua)) ? ' ' + data[1].replace(/_/g, '.') : '');
      }
      // Detect Kubuntu.
      else if (name == 'Konqueror' && !/buntu/i.test(os)) {
          os = 'Kubuntu';
        }
        // Detect Android browsers.
        else if (manufacturer && manufacturer != 'Google' && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
            name = 'Android Browser';
            os = /\bAndroid\b/.test(os) ? os : 'Android';
          }
          // Detect Silk desktop/accelerated modes.
          else if (name == 'Silk') {
              if (!/\bMobi/i.test(ua)) {
                os = 'Android';
                description.unshift('desktop mode');
              }
              if (/Accelerated *= *true/i.test(ua)) {
                description.unshift('accelerated');
              }
            }
            // Detect PaleMoon identifying as Firefox.
            else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                description.push('identifying as Firefox ' + data[1]);
              }
              // Detect Firefox OS and products running Firefox.
              else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                  os || (os = 'Firefox OS');
                  product || (product = data[1]);
                }
                // Detect false positives for Firefox/Safari.
                else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
                    // Escape the `/` for Firefox 1.
                    if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
                      // Clear name of false positives.
                      name = null;
                    }
                    // Reassign a generic name.
                    if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                      name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
                    }
                  }
                  // Add Chrome version to description for Electron.
                  else if (name == 'Electron' && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
                      description.push('Chromium ' + data);
                    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion(['(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$))', 'Version', qualify(name), '(?:Firefox|Minefield|NetFront)']);
    }
    // Detect stubborn layout engines.
    if (data = layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' || !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') || layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront') {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
        name = 'IE Mobile';
        os = 'Windows Phone 8.x';
        description.unshift('desktop mode');
        version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
      }
      // Detect IE 11 identifying as other browsers.
      else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
          if (name) {
            description.push('identifying as ' + name + (version ? ' ' + version : ''));
          }
          name = 'IE';
          version = data[1];
        }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (rhino) {
          try {
            version = context.require('ringo/engine').version.join('.');
            name = 'RingoJS';
          } catch (e) {
            if ((data = context.system) && data.global.system == context.system) {
              name = 'Narwhal';
              os || (os = data[0].os || null);
            }
          }
          if (!name) {
            name = 'Rhino';
          }
        } else if (typeof context.process == 'object' && !context.process.browser && (data = context.process)) {
          if (typeof data.versions == 'object') {
            if (typeof data.versions.electron == 'string') {
              description.push('Node ' + data.versions.node);
              name = 'Electron';
              version = data.versions.electron;
            } else if (typeof data.versions.nw == 'string') {
              description.push('Chromium ' + version, 'Node ' + data.versions.node);
              name = 'NW.js';
              version = data.versions.nw;
            }
          }
          if (!name) {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version);
            version = version ? version[0] : null;
          }
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf(data = context.runtime) == airRuntimeClass) {
          name = 'Adobe AIR';
          os = data.flash.system.Capabilities.os;
        }
        // Detect PhantomJS.
        else if (getClassOf(data = context.phantom) == phantomClass) {
            name = 'PhantomJS';
            version = (data = data.version || null) && data.major + '.' + data.minor + '.' + data.patch;
          }
          // Detect IE compatibility modes.
          else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
              // We're in compatibility mode when the Trident version + 4 doesn't
              // equal the document mode.
              version = [version, doc.documentMode];
              if ((data = +data[1] + 4) != version[1]) {
                description.push('IE ' + version[1] + ' mode');
                layout && (layout[1] = '');
                version[1] = data;
              }
              version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
            }
            // Detect IE 11 masking as other browsers.
            else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\b/.test(name)) {
                description.push('masking as ' + name + ' ' + version);
                name = 'IE';
                version = '11.0';
                layout = ['Trident'];
                os = 'Windows';
              }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && 'a')) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') + (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
        version = version.replace(/\.[\d.]+/, '.x');
      }
      // Detect Xbox 360 and Xbox One.
      else if (/\bXbox\b/i.test(product)) {
          if (product == 'Xbox 360') {
            os = null;
          }
          if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
            description.unshift('mobile mode');
          }
        }
        // Add mobile postfix.
        else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == 'Windows CE' || /Mobi/i.test(ua))) {
            name += ' Mobile';
          }
          // Detect IE platform preview.
          else if (name == 'IE' && useFeatures) {
              try {
                if (context.external === null) {
                  description.unshift('platform preview');
                }
              } catch (e) {
                description.unshift('embedded');
              }
            }
            // Detect BlackBerry OS version.
            // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
            else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] || version)) {
                data = [data, /BB10/.test(ua)];
                os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
                version = null;
              }
              // Detect Opera identifying/masking itself as another browser.
              // http://www.opera.com/support/kb/view/843/
              else if (this != forOwn && product != 'Wii' && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os) || name == 'IE' && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, '') + ';')) && data.name) {
                  // When "identifying", the UA contains both Opera and the other browser's name.
                  data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
                  if (reOpera.test(name)) {
                    if (/\bIE\b/.test(data) && os == 'Mac OS') {
                      os = null;
                    }
                    data = 'identify' + data;
                  }
                  // When "masking", the UA contains only the other browser's name.
                  else {
                      data = 'mask' + data;
                      if (operaClass) {
                        name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
                      } else {
                        name = 'Opera';
                      }
                      if (/\bIE\b/.test(data)) {
                        os = null;
                      }
                      if (!useFeatures) {
                        version = null;
                      }
                    }
                  layout = ['Presto'];
                  description.push(data);
                }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
          version = null;
        }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || !likeChrome && !data[1]) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' && (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
        description.unshift('desktop mode');
        name = 'Chrome Mobile';
        version = null;

        if (/\bOS X\b/.test(os)) {
          manufacturer = 'Apple';
          os = 'iOS 4.3+';
        } else {
          os = null;
        }
      }
    // Strip incorrect OS versions.
    if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': data && !isSpecialCasedOS ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function () {
          var version = this.version;
          return this.family + (version && !isSpecialCasedOS ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (os && /^OS X/.test(os.family) && name == 'Chrome' && parseFloat(version) >= 39) {
        os.architecture = 64;
      }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * The list of common layout engines include:
     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * The list of manufacturers include:
     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
     * "Nokia", "Samsung" and "Sony"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * The list of common browser names include:
     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
     * "Opera Mini" and "Opera"
     *
     * Mobile versions of some browsers have "Mobile" appended to their name:
     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * The list of common products include:
     *
     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function () {
        return 'null';
      }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (typeof undefined == 'function' && typeof undefined.amd == 'object' && undefined.amd) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    undefined(function () {
      return platform;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
      // Export for CommonJS support.
      forOwn(platform, function (value, key) {
        freeExports[key] = value;
      });
    } else {
      // Export to the global object.
      root.platform = platform;
    }
}).call(commonjsGlobal);
});

var config$1 = {
  directives: {
    'base-uri': { type: 'sourceList' },
    'block-all-mixed-content': { type: 'boolean' },
    'child-src': { type: 'sourceList' },
    'connect-src': { type: 'sourceList' },
    'default-src': {
      type: 'sourceList',
      hasStrictDynamic: true
    },
    'font-src': { type: 'sourceList' },
    'form-action': { type: 'sourceList' },
    'frame-ancestors': { type: 'sourceList' },
    'frame-src': { type: 'sourceList' },
    'img-src': { type: 'sourceList' },
    'manifest-src': { type: 'sourceList' },
    'media-src': { type: 'sourceList' },
    'object-src': { type: 'sourceList' },
    'script-src': {
      type: 'sourceList',
      hasUnsafes: true,
      hasStrictDynamic: true
    },
    'style-src': {
      type: 'sourceList',
      hasUnsafes: true
    },
    'prefetch-src': { type: 'sourceList' },
    'plugin-types': { type: 'pluginTypes' },
    'sandbox': { type: 'sandbox' },
    'report-to': { type: 'reportUri' },
    'report-uri': { type: 'reportUri' },
    'require-sri-for': { type: 'requireSriFor' },
    'upgrade-insecure-requests': { type: 'boolean' },
    'worker-src': {
      type: 'sourceList',
      hasUnsafes: true
    }
  },
  allHeaders: ['Content-Security-Policy', 'X-Content-Security-Policy', 'X-WebKit-CSP'],
  mustQuote: ['none', 'self', 'unsafe-inline', 'unsafe-eval', 'strict-dynamic'],
  unsafes: ["'unsafe-inline'", 'unsafe-inline', "'unsafe-eval'", 'unsafe-eval'],
  strictDynamics: ["'strict-dynamic'", 'strict-dynamic'],
  requireSriForValues: ['script', 'style'],
  sandboxDirectives: ['allow-forms', 'allow-modals', 'allow-orientation-lock', 'allow-pointer-lock', 'allow-popups', 'allow-popups-to-escape-sandbox', 'allow-presentation', 'allow-same-origin', 'allow-scripts', 'allow-top-navigation']
};

var sourceList = function sourceListCheck(key, value, options) {
  var directiveInfo = config$1.directives[key];

  if (value === false) {
    return;
  }

  if (!Array.isArray(value)) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings.');
  }

  if (value.length === 0) {
    throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to ["\'none\'"].');
  }

  value.forEach(function (sourceExpression) {
    if (!sourceExpression) {
      throw new Error('"' + sourceExpression + '" is not a valid source expression. Only non-empty strings are allowed.');
    }

    if (isFunction(sourceExpression)) {
      return;
    }

    sourceExpression = sourceExpression.valueOf();

    if (typeof sourceExpression !== 'string' || sourceExpression.length === 0) {
      throw new Error('"' + sourceExpression + '" is not a valid source expression. Only non-empty strings are allowed.');
    }

    if (!directiveInfo.hasUnsafes && config$1.unsafes.indexOf(sourceExpression) !== -1 || !directiveInfo.hasStrictDynamic && config$1.strictDynamics.indexOf(sourceExpression) !== -1) {
      throw new Error('"' + sourceExpression + '" does not make sense in ' + key + '. Remove it.');
    }

    if (config$1.mustQuote.indexOf(sourceExpression) !== -1) {
      throw new Error('"' + sourceExpression + '" must be quoted in ' + key + '. Change it to "\'' + sourceExpression + '\'" in your source list. Force this by enabling loose mode.');
    }
  });
};

var notAllowed = ['self', "'self'"].concat(config$1.unsafes);

var pluginTypes = function pluginTypesCheck(key, value, options) {
  if (!Array.isArray(value) && value !== false) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings.');
  }

  if (value.length === 0) {
    throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to ["\'none\'"].');
  }

  value.forEach(function (pluginType) {
    if (!pluginType) {
      throw new Error('"' + pluginType + '" is not a valid plugin type. Only non-empty strings are allowed.');
    }

    if (isFunction(pluginType)) {
      return;
    }

    pluginType = pluginType.valueOf();

    if (typeof pluginType !== 'string' || pluginType.length === 0) {
      throw new Error('"' + pluginType + '" is not a valid plugin type. Only non-empty strings are allowed.');
    }

    if (notAllowed.indexOf(pluginType) !== -1) {
      throw new Error('"' + pluginType + '" does not make sense in ' + key + '. Remove it.');
    }

    if (config$1.mustQuote.indexOf(pluginType) !== -1) {
      throw new Error('"' + pluginType + '" must be quoted in ' + key + '. Change it to "\'' + pluginType + '\'" in your source list. Force this by enabling loose mode.');
    }
  });
};

var sandbox = function sandboxCheck(key, value) {
  if (value === false) {
    return;
  }
  if (value === true) {
    return;
  }

  if (!Array.isArray(value)) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings or `true`.');
  }

  if (value.length === 0) {
    throw new Error(key + ' must have at least one value. To block everything, set ' + key + ' to `true`.');
  }

  value.forEach(function (expression) {
    if (isFunction(expression)) {
      return;
    }

    if (config$1.sandboxDirectives.indexOf(expression) === -1) {
      throw new Error('"' + expression + '" is not a valid ' + key + ' directive. Remove it.');
    }
  });
};

var isString = function isString(value) {
  return Object.prototype.toString.call(value) === '[object String]';
};

var reportUri = function (key, value) {
  if (value === false) {
    return;
  }
  if (isFunction(value)) {
    return;
  }

  if (!isString(value) || value.length === 0) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use a non-empty string.');
  }
};

var requireSriFor = function requireSriForCheck(key, value) {
  if (!Array.isArray(value)) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use an array of strings.');
  }

  if (value.length === 0) {
    throw new Error(key + ' must have at least one value. To require nothing, omit the directive.');
  }

  value.forEach(function (expression) {
    if (isFunction(expression)) {
      return;
    }

    if (config$1.requireSriForValues.indexOf(expression) === -1) {
      throw new Error('"' + expression + '" is not a valid ' + key + ' value. Remove it.');
    }
  });
};

var isBoolean = function isBoolean(value) {
  return Object.prototype.toString.call(value) === '[object Boolean]';
};

var boolean_1 = function (key, value) {
  if (!isBoolean(value)) {
    throw new Error('"' + value + '" is not a valid value for ' + key + '. Use `true` or `false`.');
  }
};

var checkers = {
  sourceList: sourceList,
  pluginTypes: pluginTypes,
  sandbox: sandbox,
  reportUri: reportUri,
  requireSriFor: requireSriFor,
  boolean: boolean_1
};

var checkDirective = function (key, value, options) {
  if (options.loose) {
    return;
  }

  if (!config$1.directives.hasOwnProperty(key)) {
    throw new Error('"' + key + '" is an invalid directive. See the documentation for the supported list. Force this by enabling loose mode.');
  }

  var directiveType = config$1.directives[key].type;
  checkers[directiveType](key, value, options);
};

var isArray$2 = Array.isArray || function (obj) {
  return Object.prototype.toString.call(obj) === '[object Array]';
};

var isDate$1 = function (obj) {
  return Object.prototype.toString.call(obj) === '[object Date]';
};

var isRegex$1 = function (obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var has$2 = Object.prototype.hasOwnProperty;
var objectKeys$1 = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (has$2.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

function dashCase(str) {
  return str.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (s, i) {
    return (i > 0 ? '-' : '') + s.toLowerCase();
  });
}

function map$2(xs, f) {
  if (xs.map) {
    return xs.map(f);
  }
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

function reduce$1(xs, f, acc) {
  if (xs.reduce) {
    return xs.reduce(f, acc);
  }
  for (var i = 0; i < xs.length; i++) {
    acc = f(acc, xs[i], i);
  }
  return acc;
}

function walk$1(obj) {
  if (!obj || typeof obj !== 'object') {
    return obj;
  }
  if (isDate$1(obj) || isRegex$1(obj)) {
    return obj;
  }
  if (isArray$2(obj)) {
    return map$2(obj, walk$1);
  }
  return reduce$1(objectKeys$1(obj), function (acc, key) {
    var camel = dashCase(key);
    acc[camel] = walk$1(obj[key]);
    return acc;
  }, {});
}

var dasherize = function (obj) {
  if (typeof obj === 'string') {
    return dashCase(obj);
  }
  return walk$1(obj);
};

var checkOptions = function (options) {
  if (!isObject(options)) {
    throw new Error('csp must be called with an object argument. See the documentation.');
  }

  var directives = options.directives;

  var directivesExist = isObject(directives);
  if (!directivesExist || Object.keys(directives).length === 0) {
    throw new Error('csp must have at least one directive under the "directives" key. See the documentation.');
  }

  Object.keys(directives).forEach(function (directiveKey) {
    checkDirective(dasherize(directiveKey), directives[directiveKey], options);
  });
};

function isObject(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
}

var containsFunction = function containsFunction(obj) {
  for (var key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }

    var value = obj[key];

    if (!Array.isArray(value)) {
      value = [value];
    }

    if (value.some(isFunction)) {
      return true;
    }
  }

  return false;
};

function goodBrowser() {
  return ['Content-Security-Policy'];
}

var handlers = {
  'Android Browser': function (browser, options) {
    if (parseFloat(browser.os.version) < 4.4 || options.disableAndroid) {
      return [];
    } else {
      return ['Content-Security-Policy'];
    }
  },

  Chrome: function (browser) {
    var version = parseFloat(browser.version);

    if (version >= 14 && version < 25) {
      return ['X-WebKit-CSP'];
    } else if (version >= 25) {
      return ['Content-Security-Policy'];
    } else {
      return [];
    }
  },

  'Chrome Mobile': function (browser) {
    if (browser.os.family === 'iOS') {
      return ['Content-Security-Policy'];
    } else {
      return handlers['Android Browser'].apply(this, arguments);
    }
  },

  Firefox: function (browser) {
    var version = parseFloat(browser.version);

    if (version >= 23) {
      return ['Content-Security-Policy'];
    } else if (version >= 4 && version < 23) {
      return ['X-Content-Security-Policy'];
    } else {
      return [];
    }
  },

  'Firefox Mobile': function (browser) {
    // Handles both Firefox for Android and Firefox OS
    var family = browser.os.family;
    var version = parseFloat(browser.version);

    if (family === 'Firefox OS') {
      if (version >= 32) {
        return ['Content-Security-Policy'];
      } else {
        return ['X-Content-Security-Policy'];
      }
    } else if (family === 'Android') {
      if (version >= 25) {
        return ['Content-Security-Policy'];
      } else {
        return ['X-Content-Security-Policy'];
      }
    }

    return [];
  },

  'Firefox for iOS': goodBrowser,

  IE: function (browser) {
    var version = parseFloat(browser.version);
    var header = version < 12 ? 'X-Content-Security-Policy' : 'Content-Security-Policy';

    return [header];
  },

  'Microsoft Edge': goodBrowser,

  'Microsoft Edge Mobile': goodBrowser,

  Opera: function (browser) {
    if (parseFloat(browser.version) >= 15) {
      return ['Content-Security-Policy'];
    } else {
      return [];
    }
  },

  Safari: function (browser) {
    var version = parseFloat(browser.version);

    if (version >= 7) {
      return ['Content-Security-Policy'];
    } else if (version >= 6) {
      return ['X-WebKit-CSP'];
    } else {
      return [];
    }
  }
};

handlers['IE Mobile'] = handlers.IE;

var getHeaderKeysForBrowser = function getHeaderKeysForBrowser(browser, options) {
  var handler = handlers[browser.name];

  if (handler) {
    return handler(browser, options);
  } else {
    return config$1.allHeaders;
  }
};

var lodash_reduce = createCommonjsModule(function (module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function (value, index, collection) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path$$1) {
  path$$1 = isKey(path$$1, object) ? [path$$1] : castPath(path$$1);

  var index = 0,
      length = path$$1.length;

  while (object != null && index < length) {
    object = object[toKey(path$$1[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path$$1, srcValue) {
  if (isKey(path$$1) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path$$1), srcValue);
  }
  return function (object) {
    var objValue = get(object, path$$1);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path$$1) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path$$1) {
  return function (object) {
    return baseGet(object, path$$1);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          return seen.add(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function (value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path$$1, hasFunc) {
  path$$1 = isKey(path$$1, object) ? [path$$1] : castPath(path$$1);

  var result,
      index = -1,
      length = path$$1.length;

  while (++index < length) {
    var key = toKey(path$$1[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function (string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path$$1, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path$$1);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path$$1) {
  return object != null && hasPath(object, path$$1, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path$$1) {
  return isKey(path$$1) ? baseProperty(toKey(path$$1)) : basePropertyDeep(path$$1);
}

module.exports = reduce;
});

function createFirefoxPreCSP10Directives(directives, basePolicy) {
  return lodash_reduce(directives, function (result, value, key) {
    if (key === 'connectSrc') {
      result.xhrSrc = value;
    } else {
      result[key] = value;
    }

    if (key === 'scriptSrc') {
      var optionsValues = [];

      if (value.indexOf("'unsafe-inline'") !== -1) {
        optionsValues.push('inline-script');
      }
      if (value.indexOf("'unsafe-eval'") !== -1) {
        optionsValues.push('eval-script');
      }

      if (optionsValues.length !== 0) {
        result.options = optionsValues;
      }
    }

    return result;
  }, basePolicy);
}

var handlers$1 = {
  Firefox: function (browser, directives) {
    var version = parseFloat(browser.version);

    if (version >= 4 && version < 23) {
      var basePolicy = {};
      if (version < 5) {
        basePolicy.allow = ['*'];

        if (directives.defaultSrc) {
          basePolicy.allow = directives.defaultSrc;
          delete directives.defaultSrc;
        }
      } else {
        basePolicy.defaultSrc = ['*'];
      }

      return createFirefoxPreCSP10Directives(directives, basePolicy);
    } else {
      return directives;
    }
  },

  'Firefox Mobile': function (browser, directives) {
    // Handles both Firefox for Android and Firefox OS
    var family = browser.os.family;
    var version = parseFloat(browser.version);

    if (family === 'Firefox OS' && version < 32 || family === 'Android' && version < 25) {
      return createFirefoxPreCSP10Directives(directives, { defaultSrc: ['*'] });
    } else {
      return directives;
    }
  }
};

var transformDirectivesForBrowser = function transformDirectivesForBrowser(browser, directives) {
  var handler = handlers$1[browser.name];

  if (handler) {
    return handler(browser, directives);
  } else {
    return directives;
  }
};

var parseDynamicDirectives = function parseDynamicDirectives(directives, functionArgs) {
  return lodash_reduce(directives, function (result, value, key) {
    if (Array.isArray(value)) {
      result[key] = value.map(function (element) {
        if (isFunction(element)) {
          return element.apply(null, functionArgs);
        } else {
          return element;
        }
      });
    } else if (isFunction(value)) {
      result[key] = value.apply(null, functionArgs);
    } else if (value !== false) {
      result[key] = value;
    }

    return result;
  }, {});
};

var helmetCsp = function csp(options) {
  checkOptions(options);

  var originalDirectives = camelize(options.directives || {});
  var directivesAreDynamic = containsFunction(originalDirectives);
  var shouldBrowserSniff = options.browserSniff !== false;
  var reportOnlyIsFunction = isFunction(options.reportOnly);

  if (shouldBrowserSniff) {
    return function csp(req, res, next) {
      var userAgent = req.headers['user-agent'];

      var browser;
      if (userAgent) {
        browser = platform.parse(userAgent);
      } else {
        browser = {};
      }

      var headerKeys;
      if (options.setAllHeaders || !userAgent) {
        headerKeys = config$1.allHeaders;
      } else {
        headerKeys = getHeaderKeysForBrowser(browser, options);
      }

      if (headerKeys.length === 0) {
        next();
        return;
      }

      var directives = transformDirectivesForBrowser(browser, originalDirectives);

      if (directivesAreDynamic) {
        directives = parseDynamicDirectives(directives, [req, res]);
      }

      var policyString = contentSecurityPolicyBuilder({ directives: directives });

      headerKeys.forEach(function (headerKey) {
        if (reportOnlyIsFunction && options.reportOnly(req, res) || !reportOnlyIsFunction && options.reportOnly) {
          headerKey += '-Report-Only';
        }
        res.setHeader(headerKey, policyString);
      });

      next();
    };
  } else {
    var headerKeys;
    if (options.setAllHeaders) {
      headerKeys = config$1.allHeaders;
    } else {
      headerKeys = ['Content-Security-Policy'];
    }

    return function csp(req, res, next) {
      var directives = parseDynamicDirectives(originalDirectives, [req, res]);
      var policyString = contentSecurityPolicyBuilder({ directives: directives });

      if (reportOnlyIsFunction && options.reportOnly(req, res) || !reportOnlyIsFunction && options.reportOnly) {
        headerKeys.forEach(function (headerKey) {
          res.setHeader(headerKey + '-Report-Only', policyString);
        });
      } else {
        headerKeys.forEach(function (headerKey) {
          res.setHeader(headerKey, policyString);
        });
      }

      next();
    };
  }
};

var dnsPrefetchControl = function dnsPrefetchControl(options) {
  if (options && options.allow) {
    return function dnsPrefetchControl(req, res, next) {
      res.setHeader('X-DNS-Prefetch-Control', 'on');
      next();
    };
  } else {
    return function dnsPrefetchControl(req, res, next) {
      res.setHeader('X-DNS-Prefetch-Control', 'off');
      next();
    };
  }
};

var expectCt = function expectCt(options) {
  var headerValue = getHeaderValue(options);

  return function expectCt(req, res, next) {
    res.setHeader('Expect-CT', headerValue);
    next();
  };
};

function getHeaderValue(options) {
  options = options || {};

  var directives = [];

  if (options.enforce) {
    directives.push('enforce');
  }

  directives.push('max-age=' + parseMaxAge(options.maxAge));

  if (options.reportUri) {
    directives.push('report-uri="' + options.reportUri + '"');
  }

  return directives.join('; ');
}

function parseMaxAge(option) {
  if (option == null) {
    return 0;
  }

  if (typeof option !== 'number' || option < 0) {
    throw new Error(option + ' is not a valid value for maxAge. Please choose a positive integer.');
  }

  return option;
}

var isstring = function (val) {
  return typeof val === 'string' || val instanceof String;
};

var frameguard = function frameguard(options) {
  options = options || {};

  var domain = options.domain;
  var action = options.action;

  var directive;
  if (action === undefined) {
    directive = 'SAMEORIGIN';
  } else if (isstring(action)) {
    directive = action.toUpperCase();
  }

  if (directive === 'ALLOWFROM') {
    directive = 'ALLOW-FROM';
  } else if (directive === 'SAME-ORIGIN') {
    directive = 'SAMEORIGIN';
  }

  if (['DENY', 'ALLOW-FROM', 'SAMEORIGIN'].indexOf(directive) === -1) {
    throw new Error('action must be undefined, "DENY", "ALLOW-FROM", or "SAMEORIGIN".');
  }

  if (directive === 'ALLOW-FROM') {
    if (!isstring(domain)) {
      throw new Error('ALLOW-FROM action requires a domain parameter.');
    }
    if (!domain.length) {
      throw new Error('domain parameter must not be empty.');
    }
    directive = 'ALLOW-FROM ' + domain;
  }

  return function frameguard(req, res, next) {
    res.setHeader('X-Frame-Options', directive);
    next();
  };
};

var hidePoweredBy = function hidePoweredBy(options) {
  var setTo = (options || {}).setTo;

  if (setTo) {
    return function hidePoweredBy(req, res, next) {
      res.setHeader('X-Powered-By', setTo);
      next();
    };
  } else {
    return function hidePoweredBy(req, res, next) {
      res.removeHeader('X-Powered-By');
      next();
    };
  }
};

var badArgumentsError = new Error('hpkp must be called with a maxAge and at least two SHA-256s (one actually used and another kept as a backup).');

var hpkp = function hpkp(passedOptions) {
  var options = parseOptions(passedOptions);
  var headerKey = getHeaderKey(options);
  var headerValue = getHeaderValue$1(options);

  return function hpkp(req, res, next) {
    var setHeader = true;
    var setIf = options.setIf;

    if (setIf) {
      setHeader = setIf(req, res);
    }

    if (setHeader) {
      res.setHeader(headerKey, headerValue);
    }

    next();
  };
};

function parseOptions(options) {
  if (!options) {
    throw badArgumentsError;
  }

  if (options.maxage && options.maxAge) {
    throw badArgumentsError;
  }

  var maxAge = options.maxAge;
  var sha256s = options.sha256s;
  var setIf = options.setIf;

  if (!maxAge || maxAge <= 0) {
    throw badArgumentsError;
  }
  if (!sha256s || sha256s.length < 2) {
    throw badArgumentsError;
  }
  if (setIf && typeof setIf !== 'function') {
    throw new TypeError('setIf must be a function.');
  }

  if (options.reportOnly && !options.reportUri) {
    throw badArgumentsError;
  }

  return {
    maxAge: maxAge,
    sha256s: sha256s,
    includeSubDomains: options.includeSubDomains || options.includeSubdomains,
    reportUri: options.reportUri,
    reportOnly: options.reportOnly,
    setIf: setIf
  };
}

function getHeaderKey(options) {
  var header = 'Public-Key-Pins';
  if (options.reportOnly) {
    header += '-Report-Only';
  }
  return header;
}

function getHeaderValue$1(options) {
  var result = options.sha256s.map(function (sha) {
    return 'pin-sha256="' + sha + '"';
  });
  result.push('max-age=' + Math.round(options.maxAge));
  if (options.includeSubDomains) {
    result.push('includeSubDomains');
  }
  if (options.reportUri) {
    result.push('report-uri="' + options.reportUri + '"');
  }
  return result.join('; ');
}

var defaultMaxAge = 180 * 24 * 60 * 60;

var hsts = function hsts(options) {
  options = options || {};

  var maxAge = options.maxAge != null ? options.maxAge : defaultMaxAge;
  var includeSubDomains = options.includeSubDomains !== false && options.includeSubdomains !== false;
  var setIf = options.hasOwnProperty('setIf') ? options.setIf : alwaysTrue;

  if (options.hasOwnProperty('maxage')) {
    throw new Error('maxage is not a supported property. Did you mean to pass "maxAge" instead of "maxage"?');
  }
  if (arguments.length > 1) {
    throw new Error('HSTS passed the wrong number of arguments.');
  }
  if (typeof maxAge !== 'number') {
    throw new TypeError('HSTS must be passed a numeric maxAge parameter.');
  }
  if (maxAge < 0) {
    throw new RangeError('HSTS maxAge must be nonnegative.');
  }
  if (typeof setIf !== 'function') {
    throw new TypeError('setIf must be a function.');
  }
  if (options.hasOwnProperty('includeSubDomains') && options.hasOwnProperty('includeSubdomains')) {
    throw new Error('includeSubDomains and includeSubdomains cannot both be specified.');
  }

  var header = 'max-age=' + Math.round(maxAge);
  if (includeSubDomains) {
    header += '; includeSubDomains';
  }
  if (options.preload) {
    header += '; preload';
  }

  return function hsts(req, res, next) {
    if (setIf(req, res)) {
      res.setHeader('Strict-Transport-Security', header);
    }

    next();
  };
};

function alwaysTrue() {
  return true;
}

var ienoopen = function ienoopen() {
  return function ienoopen(req, res, next) {
    res.setHeader('X-Download-Options', 'noopen');
    next();
  };
};

var nocache = function nocache() {
  return function nocache(req, res, next) {
    res.setHeader('Surrogate-Control', 'no-store');
    res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');

    next();
  };
};

var dontSniffMimetype = function nosniff() {
  return function nosniff(req, res, next) {
    res.setHeader('X-Content-Type-Options', 'nosniff');
    next();
  };
};

var DEFAULT_POLICY = 'no-referrer';
var ALLOWED_POLICIES = ['no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url', ''];
var ALLOWED_POLICIES_ERROR_LIST = ALLOWED_POLICIES.map(function (policy) {
  if (policy.length) {
    return '"' + policy + '"';
  } else {
    return 'and the empty string';
  }
}).join(', ');

var referrerPolicy = function referrerPolicy(options) {
  options = options || {};

  var policy;
  if ('policy' in options) {
    policy = options.policy;
  } else {
    policy = DEFAULT_POLICY;
  }

  if (ALLOWED_POLICIES.indexOf(policy) === -1) {
    throw new Error('"' + policy + '" is not a valid policy. Allowed policies: ' + ALLOWED_POLICIES_ERROR_LIST + '.');
  }

  return function referrerPolicy(req, res, next) {
    res.setHeader('Referrer-Policy', policy);
    next();
  };
};

var xXssProtection = function xXssProtection(options) {
  if (options && options.setOnOldIE) {
    return function xXssProtection(req, res, next) {
      res.setHeader('X-XSS-Protection', '1; mode=block');
      next();
    };
  } else {
    return function xXssProtection(req, res, next) {
      var matches = /msie\s*(\d+)/i.exec(req.headers['user-agent']);

      var value;
      if (!matches || parseFloat(matches[1]) >= 9) {
        value = '1; mode=block';
      } else {
        value = '0';
      }

      res.setHeader('X-XSS-Protection', value);
      next();
    };
  }
};

var DEFAULT_MIDDLEWARE = ['dnsPrefetchControl', 'frameguard', 'hidePoweredBy', 'hsts', 'ieNoOpen', 'noSniff', 'xssFilter'];

var middlewares;
function helmet(options) {
  options = options || {};

  if (options.constructor.name === 'IncomingMessage') {
    throw new Error('It appears you have done something like `app.use(helmet)`, but it should be `app.use(helmet())`.');
  }

  var stack = middlewares.reduce(function (result, middlewareName) {
    var middleware = helmet[middlewareName];
    var middlewareOptions = options[middlewareName];
    var isDefault = DEFAULT_MIDDLEWARE.indexOf(middlewareName) !== -1;

    if (middlewareOptions === false) {
      return result;
    } else if (middlewareOptions === true) {
      middlewareOptions = {};
    }

    if (middlewareOptions != null) {
      return result.concat(middleware(middlewareOptions));
    } else if (isDefault) {
      return result.concat(middleware({}));
    }
    return result;
  }, []);

  return function helmet(req, res, next) {
    var index = 0;

    function internalNext() {
      if (arguments.length > 0) {
        return next.apply(null, arguments);
      }

      var middleware = stack[index];
      if (!middleware) {
        return next();
      }

      index++;

      middleware(req, res, internalNext);
    }

    internalNext();
  };
}

helmet.contentSecurityPolicy = helmetCsp;
helmet.dnsPrefetchControl = dnsPrefetchControl;
helmet.expectCt = expectCt;
helmet.frameguard = frameguard;
helmet.hidePoweredBy = hidePoweredBy;
helmet.hpkp = hpkp;
helmet.hsts = hsts;
helmet.ieNoOpen = ienoopen;
helmet.noCache = nocache;
helmet.noSniff = dontSniffMimetype;
helmet.referrerPolicy = referrerPolicy;
helmet.xssFilter = xXssProtection;
middlewares = Object.keys(helmet);

var helmet_1 = helmet;

var lib$4 = createCommonjsModule(function (module, exports) {
var Module = module$1.Module;


var appModulePaths = [];
var old_nodeModulePaths = Module._nodeModulePaths;
var allowedDirs = {};

function checkIfDirAllowed(from) {
    var currentDir = from;

    while (currentDir) {
        if (allowedDirs[currentDir]) {
            return true;
        }

        var basename = path.basename(currentDir);
        if (basename === 'node_modules') {
            return false;
        }

        var parentDir = path.dirname(currentDir);
        if (parentDir === currentDir) {
            break;
        }
        currentDir = parentDir;
    }

    return true;
}

Module._nodeModulePaths = function (from) {
    var paths = old_nodeModulePaths.call(this, from);

    // Only include the app module path for top-level modules
    // that were not installed or that were explicitly allowed
    if (checkIfDirAllowed(from)) {
        paths = paths.concat(appModulePaths);
    }

    return paths;
};

function enableForDir(dir) {
    allowedDirs[dir] = true;
}

function addPath(path$$1, parent) {
    // Anable app-module-path to work under any directories that are explicitly added
    enableForDir(path$$1);

    function addPathHelper(targetArray) {
        path$$1 = path.normalize(path$$1);
        if (targetArray && targetArray.indexOf(path$$1) === -1) {
            targetArray.push(path$$1);
        }
    }

    path$$1 = path.normalize(path$$1);

    if (appModulePaths.indexOf(path$$1) === -1) {
        appModulePaths.push(path$$1);
        // Enable the search path for the current top-level module
        if (commonjsRequire.main) {
            addPathHelper(commonjsRequire.main.paths);
        }

        parent = parent || module.parent;

        // Also modify the paths of the module that was used to load the app-module-paths module
        // and all of it's parents
        while (parent && parent !== commonjsRequire.main) {
            addPathHelper(parent.paths);
            parent = parent.parent;
        }
    }
}

function removePath(path$$1) {
    function removePathHelper(targetArray) {
        path$$1 = path.normalize(path$$1);
        if (!targetArray) return;
        var index = targetArray.indexOf(path$$1);
        if (index === -1) return;
        targetArray.splice(index, 1);
    }

    var parent;
    path$$1 = path.normalize(path$$1);
    var index = appModulePaths.indexOf(path$$1);

    if (index > -1) {
        appModulePaths.splice(index, 1);
        // Enable the search path for the current top-level module
        if (commonjsRequire.main) removePathHelper(commonjsRequire.main.paths);
        parent = module.parent;

        // Also modify the paths of the module that was used to load the app-module-paths module
        // and all of it's parents
        while (parent && parent !== commonjsRequire.main) {
            removePathHelper(parent.paths);
            parent = parent.parent;
        }
    }
}

exports.addPath = addPath;
exports.removePath = removePath;
exports.enableForDir = enableForDir;
});
var lib_1$2 = lib$4.addPath;
var lib_2$2 = lib$4.removePath;
var lib_3$2 = lib$4.enableForDir;

// loadware.js - Turn different middleware descriptors into an array of middleware
lib$4.addPath(process.cwd());

// Put it all into a single array of non-arrays recursively
// ['a', ['b', ['c', ...]]] => ['a', 'b', 'c', ...]
let flat = arr => arr.reduce((good, one) => {
  let flatten = Array.isArray(one) ? flat(one) : one || [];
  return good.concat(flatten);
}, []);

// Fetches the absolute path from the root
// ['a', 'b'] => [require('a'), require('b')]
// Note: this doesn't work: 'require(mid)'
let include = mid => typeof mid === 'string' ? commonjsRequire(path.resolve(mid)) : mid;

// Throw an error if there's something that is not a function anymore
// [{ a: 'b' }] => throw new Error();
let others = mid => {
  if (mid instanceof Function) return mid;
  throw new Error("Only boolean, string, array or function can be middleware");
};

// The actual glue for them all
var loadware = (...middle) => flat(middle).map(include).filter(others);

var debug$h = createCommonjsModule(function (module, exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = ms;

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0,
      i;

  for (i in namespace) {
    hash = (hash << 5) - hash + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms$$1 = curr - (prevTime || curr);
    self.diff = ms$$1;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}
});
var debug_1$7 = debug$h.coerce;
var debug_2$7 = debug$h.disable;
var debug_3$7 = debug$h.enable;
var debug_4$7 = debug$h.enabled;
var debug_5$7 = debug$h.humanize;
var debug_6$7 = debug$h.names;
var debug_7$7 = debug$h.skips;
var debug_8$7 = debug$h.formatters;

var browser$7 = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$h;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

/**
 * Colors.
 */

exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch (e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch (e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}
});
var browser_1$7 = browser$7.log;
var browser_2$7 = browser$7.formatArgs;
var browser_3$7 = browser$7.save;
var browser_4$7 = browser$7.load;
var browser_5$7 = browser$7.useColors;
var browser_6$7 = browser$7.storage;
var browser_7$7 = browser$7.colors;

var node$7 = createCommonjsModule(function (module, exports) {
/**
 * Module dependencies.
 */




/**
 * This is the Node.js implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug$h;
exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(function (key) {
  return (/^debug_/i.test(key)
  );
}).reduce(function (obj, key) {
  // camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  });

  // coerce string value into JS value
  var val = process.env[key];
  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);

  obj[prop] = val;
  return obj;
}, {});

/**
 * The file descriptor to write the `debug()` calls to.
 * Set the `DEBUG_FD` env variable to override with another value. i.e.:
 *
 *   $ DEBUG_FD=3 node script.js 3>debug.log
 */

var fd = parseInt(process.env.DEBUG_FD, 10) || 2;

if (1 !== fd && 2 !== fd) {
  util.deprecate(function () {}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')();
}

var stream = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
}

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

exports.formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
    return str.trim();
  }).join(' ');
};

/**
 * Map %o to `util.inspect()`, allowing multiple lines if needed.
 */

exports.formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var name = this.namespace;
  var useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var prefix = '  \u001b[3' + c + ';1m' + name + ' ' + '\u001b[0m';

    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push('\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\u001b[0m');
  } else {
    args[0] = new Date().toUTCString() + ' ' + name + ' ' + args[0];
  }
}

/**
 * Invokes `util.format()` with the specified arguments and writes to `stream`.
 */

function log() {
  return stream.write(util.format.apply(util, arguments) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  if (null == namespaces) {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete process.env.DEBUG;
  } else {
    process.env.DEBUG = namespaces;
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  return process.env.DEBUG;
}

/**
 * Copied from `node/src/node.js`.
 *
 * XXX: It's lame that node doesn't expose this API out-of-the-box. It also
 * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.
 */

function createWritableStdioStream(fd) {
  var stream;
  var tty_wrap = process.binding('tty_wrap');

  // Note stream._type is used for test-module-load-list.js

  switch (tty_wrap.guessHandleType(fd)) {
    case 'TTY':
      stream = new tty.WriteStream(fd);
      stream._type = 'tty';

      // Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    case 'FILE':
      var fs$$1 = fs;
      stream = new fs$$1.SyncWriteStream(fd, { autoClose: false });
      stream._type = 'fs';
      break;

    case 'PIPE':
    case 'TCP':
      var net = require$$2;
      stream = new net.Socket({
        fd: fd,
        readable: false,
        writable: true
      });

      // FIXME Should probably have an option in net.Socket to create a
      // stream from an existing fd which is writable only. But for now
      // we'll just add this hack and set the `readable` member to false.
      // Test: ./node test/fixtures/echo.js < /etc/passwd
      stream.readable = false;
      stream.read = null;
      stream._type = 'pipe';

      // FIXME Hack to have stream not keep the event loop alive.
      // See https://github.com/joyent/node/issues/1726
      if (stream._handle && stream._handle.unref) {
        stream._handle.unref();
      }
      break;

    default:
      // Probably an error on in uv_guess_handle()
      throw new Error('Implement me. Unknown stream file type!');
  }

  // For supporting legacy API we put the FD here.
  stream.fd = fd;

  stream._isStdio = true;

  return stream;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
  debug.inspectOpts = {};

  var keys = Object.keys(exports.inspectOpts);
  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

/**
 * Enable namespaces listed in `process.env.DEBUG` initially.
 */

exports.enable(load());
});
var node_1$7 = node$7.init;
var node_2$7 = node$7.log;
var node_3$7 = node$7.formatArgs;
var node_4$7 = node$7.save;
var node_5$7 = node$7.load;
var node_6$7 = node$7.useColors;
var node_7$7 = node$7.colors;
var node_8$7 = node$7.inspectOpts;

var src$7 = createCommonjsModule(function (module) {
/**
 * Detect Electron renderer process, which is node, but we should
 * treat as a browser.
 */

if (typeof process !== 'undefined' && process.type === 'renderer') {
  module.exports = browser$7;
} else {
  module.exports = node$7;
}
});

/**
 * Module dependencies.
 */

var debug$i = src$7('method-override');





/**
 * Method Override:
 *
 * Provides faux HTTP method support.
 *
 * Pass an optional `getter` to use when checking for
 * a method override.
 *
 * A string is converted to a getter that will look for
 * the method in `req.body[getter]` and a function will be
 * called with `req` and expects the method to be returned.
 * If the string starts with `X-` then it will look in
 * `req.headers[getter]` instead.
 *
 * The original method is available via `req.originalMethod`.
 *
 * @param {string|function} [getter=X-HTTP-Method-Override]
 * @param {object} [options]
 * @return {function}
 * @api public
 */

var methodOverride = function methodOverride(getter, options) {
  var opts = options || {};

  // get the getter fn
  var get = typeof getter === 'function' ? getter : createGetter(getter || 'X-HTTP-Method-Override');

  // get allowed request methods to examine
  var methods$$1 = opts.methods === undefined ? ['POST'] : opts.methods;

  return function methodOverride(req, res, next) {
    var method;
    var val;

    req.originalMethod = req.originalMethod || req.method;

    // validate request is an allowed method
    if (methods$$1 && methods$$1.indexOf(req.originalMethod) === -1) {
      return next();
    }

    val = get(req, res);
    method = Array.isArray(val) ? val[0] : val;

    // replace
    if (method !== undefined && supports(method)) {
      req.method = method.toUpperCase();
      debug$i('override %s as %s', req.originalMethod, req.method);
    }

    next();
  };
};

/**
 * Create a getter for the given string.
 */

function createGetter(str) {
  if (str.substr(0, 2).toUpperCase() === 'X-') {
    // header getter
    return createHeaderGetter(str);
  }

  return createQueryGetter(str);
}

/**
 * Create a getter for the given query key name.
 */

function createQueryGetter(key) {
  return function (req, res) {
    var url$$1 = parseurl_1(req);
    var query = querystring.parse(url$$1.query || '');
    return query[key];
  };
}

/**
 * Create a getter for the given header name.
 */

function createHeaderGetter(str) {
  var name = str.toLowerCase();

  return function (req, res) {
    // set appropriate Vary header
    vary_1(res, str);

    // get header
    var header = req.headers[name];

    if (!header) {
      return undefined;
    }

    // multiple headers get joined with comma by node.js core
    var index = header.indexOf(',');

    // return first value
    return index !== -1 ? header.substr(0, index).trim() : header.trim();
  };
}

/**
 * Check if node supports `method`.
 */

function supports(method) {
  return method && typeof method === 'string' && methods.indexOf(method.toLowerCase()) !== -1;
}

// global key for user preferred registration

var REGISTRATION_KEY = '@@any-promise/REGISTRATION',

// Prior registration (preferred or detected)
registered = null;

/**
 * Registers the given implementation.  An implementation must
 * be registered prior to any call to `require("any-promise")`,
 * typically on application load.
 *
 * If called with no arguments, will return registration in
 * following priority:
 *
 * For Node.js:
 *
 * 1. Previous registration
 * 2. global.Promise if node.js version >= 0.12
 * 3. Auto detected promise based on first sucessful require of
 *    known promise libraries. Note this is a last resort, as the
 *    loaded library is non-deterministic. node.js >= 0.12 will
 *    always use global.Promise over this priority list.
 * 4. Throws error.
 *
 * For Browser:
 *
 * 1. Previous registration
 * 2. window.Promise
 * 3. Throws error.
 *
 * Options:
 *
 * Promise: Desired Promise constructor
 * global: Boolean - Should the registration be cached in a global variable to
 * allow cross dependency/bundle registration?  (default true)
 */
var loader = function (root, loadImplementation) {
  return function register(implementation, opts) {
    implementation = implementation || null;
    opts = opts || {};
    // global registration unless explicitly  {global: false} in options (default true)
    var registerGlobal = opts.global !== false;

    // load any previous global registration
    if (registered === null && registerGlobal) {
      registered = root[REGISTRATION_KEY] || null;
    }

    if (registered !== null && implementation !== null && registered.implementation !== implementation) {
      // Throw error if attempting to redefine implementation
      throw new Error('any-promise already defined as "' + registered.implementation + '".  You can only register an implementation before the first ' + ' call to require("any-promise") and an implementation cannot be changed');
    }

    if (registered === null) {
      // use provided implementation
      if (implementation !== null && typeof opts.Promise !== 'undefined') {
        registered = {
          Promise: opts.Promise,
          implementation: implementation
        };
      } else {
        // require implementation if implementation is specified but not provided
        registered = loadImplementation(implementation);
      }

      if (registerGlobal) {
        // register preference globally in case multiple installations
        root[REGISTRATION_KEY] = registered;
      }
    }

    return registered;
  };
};

var register = loader(commonjsGlobal, loadImplementation);

/**
 * Node.js version of loadImplementation.
 *
 * Requires the given implementation and returns the registration
 * containing {Promise, implementation}
 *
 * If implementation is undefined or global.Promise, loads it
 * Otherwise uses require
 */
function loadImplementation(implementation) {
  var impl = null;

  if (shouldPreferGlobalPromise(implementation)) {
    // if no implementation or env specified use global.Promise
    impl = {
      Promise: commonjsGlobal.Promise,
      implementation: 'global.Promise'
    };
  } else if (implementation) {
    // if implementation specified, require it
    var lib = commonjsRequire(implementation);
    impl = {
      Promise: lib.Promise || lib,
      implementation: implementation
    };
  } else {
    // try to auto detect implementation. This is non-deterministic
    // and should prefer other branches, but this is our last chance
    // to load something without throwing error
    impl = tryAutoDetect();
  }

  if (impl === null) {
    throw new Error('Cannot find any-promise implementation nor' + ' global.Promise. You must install polyfill or call' + ' require("any-promise/register") with your preferred' + ' implementation, e.g. require("any-promise/register/bluebird")' + ' on application load prior to any require("any-promise").');
  }

  return impl;
}

/**
 * Determines if the global.Promise should be preferred if an implementation
 * has not been registered.
 */
function shouldPreferGlobalPromise(implementation) {
  if (implementation) {
    return implementation === 'global.Promise';
  } else if (typeof commonjsGlobal.Promise !== 'undefined') {
    // Load global promise if implementation not specified
    // Versions < 0.11 did not have global Promise
    // Do not use for version < 0.12 as version 0.11 contained buggy versions
    var version = /v(\d+)\.(\d+)\.(\d+)/.exec(process.version);
    return !(version && +version[1] == 0 && +version[2] < 12);
  }

  // do not have global.Promise or another implementation was specified
  return false;
}

/**
 * Look for common libs as last resort there is no guarantee that
 * this will return a desired implementation or even be deterministic.
 * The priority is also nearly arbitrary. We are only doing this
 * for older versions of Node.js <0.12 that do not have a reasonable
 * global.Promise implementation and we the user has not registered
 * the preference. This preserves the behavior of any-promise <= 0.1
 * and may be deprecated or removed in the future
 */
function tryAutoDetect() {
  var libs = ["es6-promise", "promise", "native-promise-only", "bluebird", "rsvp", "when", "q", "pinkie", "lie", "vow"];
  var i = 0,
      len = libs.length;
  for (; i < len; i++) {
    try {
      return loadImplementation(libs[i]);
    } catch (e) {}
  }
  return null;
}

var anyPromise = register().Promise;

var fs_1 = clone(fs);

function clone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;

  if (obj instanceof Object) var copy = { __proto__: obj.__proto__ };else var copy = Object.create(null);

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
  });

  return copy;
}

var origCwd = process.cwd;
var cwd = null;

var platform$1 = process.env.GRACEFUL_FS_PLATFORM || process.platform;

process.cwd = function () {
  if (!cwd) cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {}

var chdir = process.chdir;
process.chdir = function (d) {
  cwd = null;
  chdir.call(process, d);
};

var polyfills = patch;

function patch(fs$$1) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs$$1);
  }

  // lutimes implementation, or no-op
  if (!fs$$1.lutimes) {
    patchLutimes(fs$$1);
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs$$1.chown = chownFix(fs$$1.chown);
  fs$$1.fchown = chownFix(fs$$1.fchown);
  fs$$1.lchown = chownFix(fs$$1.lchown);

  fs$$1.chmod = chmodFix(fs$$1.chmod);
  fs$$1.fchmod = chmodFix(fs$$1.fchmod);
  fs$$1.lchmod = chmodFix(fs$$1.lchmod);

  fs$$1.chownSync = chownFixSync(fs$$1.chownSync);
  fs$$1.fchownSync = chownFixSync(fs$$1.fchownSync);
  fs$$1.lchownSync = chownFixSync(fs$$1.lchownSync);

  fs$$1.chmodSync = chmodFixSync(fs$$1.chmodSync);
  fs$$1.fchmodSync = chmodFixSync(fs$$1.fchmodSync);
  fs$$1.lchmodSync = chmodFixSync(fs$$1.lchmodSync);

  fs$$1.stat = statFix(fs$$1.stat);
  fs$$1.fstat = statFix(fs$$1.fstat);
  fs$$1.lstat = statFix(fs$$1.lstat);

  fs$$1.statSync = statFixSync(fs$$1.statSync);
  fs$$1.fstatSync = statFixSync(fs$$1.fstatSync);
  fs$$1.lstatSync = statFixSync(fs$$1.lstatSync);

  // if lchmod/lchown do not exist, then make them no-ops
  if (!fs$$1.lchmod) {
    fs$$1.lchmod = function (path$$1, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs$$1.lchmodSync = function () {};
  }
  if (!fs$$1.lchown) {
    fs$$1.lchown = function (path$$1, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs$$1.lchownSync = function () {};
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform$1 === "win32") {
    fs$$1.rename = function (fs$rename) {
      return function (from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
            setTimeout(function () {
              fs$$1.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);else cb(er);
              });
            }, backoff);
            if (backoff < 100) backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      };
    }(fs$$1.rename);
  }

  // if read() returns EAGAIN, then just try it again.
  fs$$1.read = function (fs$read) {
    return function (fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0;
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs$$1, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs$$1, fd, buffer, offset, length, position, callback);
    };
  }(fs$$1.read);

  fs$$1.readSync = function (fs$readSync) {
    return function (fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs$$1, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs$$1.readSync);
}

function patchLchmod(fs$$1) {
  fs$$1.lchmod = function (path$$1, mode, callback) {
    fs$$1.open(path$$1, constants.O_WRONLY | constants.O_SYMLINK, mode, function (err, fd) {
      if (err) {
        if (callback) callback(err);
        return;
      }
      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      fs$$1.fchmod(fd, mode, function (err) {
        fs$$1.close(fd, function (err2) {
          if (callback) callback(err || err2);
        });
      });
    });
  };

  fs$$1.lchmodSync = function (path$$1, mode) {
    var fd = fs$$1.openSync(path$$1, constants.O_WRONLY | constants.O_SYMLINK, mode);

    // prefer to return the chmod error, if one occurs,
    // but still try to close, and report closing errors if they occur.
    var threw = true;
    var ret;
    try {
      ret = fs$$1.fchmodSync(fd, mode);
      threw = false;
    } finally {
      if (threw) {
        try {
          fs$$1.closeSync(fd);
        } catch (er) {}
      } else {
        fs$$1.closeSync(fd);
      }
    }
    return ret;
  };
}

function patchLutimes(fs$$1) {
  if (constants.hasOwnProperty("O_SYMLINK")) {
    fs$$1.lutimes = function (path$$1, at, mt, cb) {
      fs$$1.open(path$$1, constants.O_SYMLINK, function (er, fd) {
        if (er) {
          if (cb) cb(er);
          return;
        }
        fs$$1.futimes(fd, at, mt, function (er) {
          fs$$1.close(fd, function (er2) {
            if (cb) cb(er || er2);
          });
        });
      });
    };

    fs$$1.lutimesSync = function (path$$1, at, mt) {
      var fd = fs$$1.openSync(path$$1, constants.O_SYMLINK);
      var ret;
      var threw = true;
      try {
        ret = fs$$1.futimesSync(fd, at, mt);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs$$1.closeSync(fd);
          } catch (er) {}
        } else {
          fs$$1.closeSync(fd);
        }
      }
      return ret;
    };
  } else {
    fs$$1.lutimes = function (_a, _b, _c, cb) {
      if (cb) process.nextTick(cb);
    };
    fs$$1.lutimesSync = function () {};
  }
}

function chmodFix(orig) {
  if (!orig) return orig;
  return function (target, mode, cb) {
    return orig.call(fs_1, target, mode, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chmodFixSync(orig) {
  if (!orig) return orig;
  return function (target, mode) {
    try {
      return orig.call(fs_1, target, mode);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function chownFix(orig) {
  if (!orig) return orig;
  return function (target, uid, gid, cb) {
    return orig.call(fs_1, target, uid, gid, function (er) {
      if (chownErOk(er)) er = null;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function chownFixSync(orig) {
  if (!orig) return orig;
  return function (target, uid, gid) {
    try {
      return orig.call(fs_1, target, uid, gid);
    } catch (er) {
      if (!chownErOk(er)) throw er;
    }
  };
}

function statFix(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target, cb) {
    return orig.call(fs_1, target, function (er, stats) {
      if (!stats) return cb.apply(this, arguments);
      if (stats.uid < 0) stats.uid += 0x100000000;
      if (stats.gid < 0) stats.gid += 0x100000000;
      if (cb) cb.apply(this, arguments);
    });
  };
}

function statFixSync(orig) {
  if (!orig) return orig;
  // Older versions of Node erroneously returned signed integers for
  // uid + gid.
  return function (target) {
    var stats = orig.call(fs_1, target);
    if (stats.uid < 0) stats.uid += 0x100000000;
    if (stats.gid < 0) stats.gid += 0x100000000;
    return stats;
  };
}

// ENOSYS means that the fs doesn't support the op. Just ignore
// that, because it doesn't matter.
//
// if there's no getuid, or if getuid() is something other
// than 0, and the error is EINVAL or EPERM, then just ignore
// it.
//
// This specific case is a silent failure in cp, install, tar,
// and most other unix tools that manage permissions.
//
// When running as root, or if other types of errors are
// encountered, then it's strict.
function chownErOk(er) {
  if (!er) return true;

  if (er.code === "ENOSYS") return true;

  var nonroot = !process.getuid || process.getuid() !== 0;
  if (nonroot) {
    if (er.code === "EINVAL" || er.code === "EPERM") return true;
  }

  return false;
}

var Stream = require$$1.Stream;

var legacyStreams = legacy;

function legacy(fs$$1) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  };

  function ReadStream(path$$1, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path$$1, options);

    Stream.call(this);

    var self = this;

    this.path = path$$1;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function () {
        self._read();
      });
      return;
    }

    fs$$1.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    });
  }

  function WriteStream(path$$1, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path$$1, options);

    Stream.call(this);

    this.path = path$$1;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs$$1.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}

var gracefulFs = createCommonjsModule(function (module) {
var queue = [];



function noop() {}

var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function () {
  var m = util.format.apply(util, arguments);
  m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
  console.error(m);
};

if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
  process.on('exit', function () {
    debug(queue);
    assert.equal(queue.length, 0);
  });
}

module.exports = patch(fs_1);
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
  module.exports = patch(fs);
}

// Always patch fs.close/closeSync, because we want to
// retry() whenever a close happens *anywhere* in the program.
// This is essential when multiple graceful-fs instances are
// in play at the same time.
module.exports.close = fs.close = function (fs$close) {
  return function (fd, cb) {
    return fs$close.call(fs, fd, function (err) {
      if (!err) retry();

      if (typeof cb === 'function') cb.apply(this, arguments);
    });
  };
}(fs.close);

module.exports.closeSync = fs.closeSync = function (fs$closeSync) {
  return function (fd) {
    // Note that graceful-fs also retries when fs.closeSync() fails.
    // Looks like a bug to me, although it's probably a harmless one.
    var rval = fs$closeSync.apply(fs, arguments);
    retry();
    return rval;
  };
}(fs.closeSync);

function patch(fs$$1) {
  // Everything that references the open() function needs to be in here
  polyfills(fs$$1);
  fs$$1.gracefulify = patch;
  fs$$1.FileReadStream = ReadStream; // Legacy name.
  fs$$1.FileWriteStream = WriteStream; // Legacy name.
  fs$$1.createReadStream = createReadStream;
  fs$$1.createWriteStream = createWriteStream;
  var fs$readFile = fs$$1.readFile;
  fs$$1.readFile = readFile;
  function readFile(path$$1, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$readFile(path$$1, options, cb);

    function go$readFile(path$$1, options, cb) {
      return fs$readFile(path$$1, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readFile, [path$$1, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$writeFile = fs$$1.writeFile;
  fs$$1.writeFile = writeFile;
  function writeFile(path$$1, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$writeFile(path$$1, data, options, cb);

    function go$writeFile(path$$1, data, options, cb) {
      return fs$writeFile(path$$1, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$writeFile, [path$$1, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$appendFile = fs$$1.appendFile;
  if (fs$appendFile) fs$$1.appendFile = appendFile;
  function appendFile(path$$1, data, options, cb) {
    if (typeof options === 'function') cb = options, options = null;

    return go$appendFile(path$$1, data, options, cb);

    function go$appendFile(path$$1, data, options, cb) {
      return fs$appendFile(path$$1, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$appendFile, [path$$1, data, options, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  var fs$readdir = fs$$1.readdir;
  fs$$1.readdir = readdir;
  function readdir(path$$1, options, cb) {
    var args = [path$$1];
    if (typeof options !== 'function') {
      args.push(options);
    } else {
      cb = options;
    }
    args.push(go$readdir$cb);

    return go$readdir(args);

    function go$readdir$cb(err, files) {
      if (files && files.sort) files.sort();

      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$readdir, [args]]);else {
        if (typeof cb === 'function') cb.apply(this, arguments);
        retry();
      }
    }
  }

  function go$readdir(args) {
    return fs$readdir.apply(fs$$1, args);
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacyStreams(fs$$1);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }

  var fs$ReadStream = fs$$1.ReadStream;
  ReadStream.prototype = Object.create(fs$ReadStream.prototype);
  ReadStream.prototype.open = ReadStream$open;

  var fs$WriteStream = fs$$1.WriteStream;
  WriteStream.prototype = Object.create(fs$WriteStream.prototype);
  WriteStream.prototype.open = WriteStream$open;

  fs$$1.ReadStream = ReadStream;
  fs$$1.WriteStream = WriteStream;

  function ReadStream(path$$1, options) {
    if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }

  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose) that.destroy();

        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
        that.read();
      }
    });
  }

  function WriteStream(path$$1, options) {
    if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }

  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy();
        that.emit('error', err);
      } else {
        that.fd = fd;
        that.emit('open', fd);
      }
    });
  }

  function createReadStream(path$$1, options) {
    return new ReadStream(path$$1, options);
  }

  function createWriteStream(path$$1, options) {
    return new WriteStream(path$$1, options);
  }

  var fs$open = fs$$1.open;
  fs$$1.open = open;
  function open(path$$1, flags, mode, cb) {
    if (typeof mode === 'function') cb = mode, mode = null;

    return go$open(path$$1, flags, mode, cb);

    function go$open(path$$1, flags, mode, cb) {
      return fs$open(path$$1, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([go$open, [path$$1, flags, mode, cb]]);else {
          if (typeof cb === 'function') cb.apply(this, arguments);
          retry();
        }
      });
    }
  }

  return fs$$1;
}

function enqueue(elem) {
  debug('ENQUEUE', elem[0].name, elem[1]);
  queue.push(elem);
}

function retry() {
  var elem = queue.shift();
  if (elem) {
    debug('RETRY', elem[0].name, elem[1]);
    elem[0].apply(null, elem[1]);
  }
}
});
var gracefulFs_1 = gracefulFs.close;
var gracefulFs_2 = gracefulFs.closeSync;

var thenify_1 = thenify;

/**
 * Turn async functions into promises
 *
 * @param {Function} $$__fn__$$
 * @return {Function}
 * @api public
 */

function thenify($$__fn__$$, options) {
  assert(typeof $$__fn__$$ === 'function');
  return eval(createWrapper($$__fn__$$.name, options));
}

/**
 * Turn async functions into promises and backward compatible with callback
 *
 * @param {Function} $$__fn__$$
 * @return {Function}
 * @api public
 */

thenify.withCallback = function ($$__fn__$$, options) {
  assert(typeof $$__fn__$$ === 'function');
  options = options || {};
  options.withCallback = true;
  if (options.multiArgs === undefined) options.multiArgs = true;
  return eval(createWrapper($$__fn__$$.name, options));
};

function createWrapper(name, options) {
  name = (name || '').replace(/\s|bound(?!$)/g, '');
  options = options || {};
  // default to true
  var multiArgs = options.multiArgs !== undefined ? options.multiArgs : true;
  multiArgs = 'var multiArgs = ' + JSON.stringify(multiArgs) + '\n';

  var withCallback = options.withCallback ? 'var lastType = typeof arguments[len - 1]\n' + 'if (lastType === "function") return $$__fn__$$.apply(self, arguments)\n' : '';

  return '(function ' + name + '() {\n' + 'var self = this\n' + 'var len = arguments.length\n' + multiArgs + withCallback + 'var args = new Array(len + 1)\n' + 'for (var i = 0; i < len; ++i) args[i] = arguments[i]\n' + 'var lastIndex = i\n' + 'return new Promise(function (resolve, reject) {\n' + 'args[lastIndex] = createCallback(resolve, reject, multiArgs)\n' + '$$__fn__$$.apply(self, args)\n' + '})\n' + '})';
}

var thenifyAll_1 = thenifyAll;
thenifyAll.withCallback = withCallback;
thenifyAll.thenify = thenify_1;

/**
 * Promisifies all the selected functions in an object.
 *
 * @param {Object} source the source object for the async functions
 * @param {Object} [destination] the destination to set all the promisified methods
 * @param {Array} [methods] an array of method names of `source`
 * @return {Object}
 * @api public
 */

function thenifyAll(source, destination, methods) {
  return promisifyAll(source, destination, methods, thenify_1);
}

/**
 * Promisifies all the selected functions in an object and backward compatible with callback.
 *
 * @param {Object} source the source object for the async functions
 * @param {Object} [destination] the destination to set all the promisified methods
 * @param {Array} [methods] an array of method names of `source`
 * @return {Object}
 * @api public
 */

function withCallback(source, destination, methods) {
  return promisifyAll(source, destination, methods, thenify_1.withCallback);
}

function promisifyAll(source, destination, methods, promisify) {
  if (!destination) {
    destination = {};
    methods = Object.keys(source);
  }

  if (Array.isArray(destination)) {
    methods = destination;
    destination = {};
  }

  if (!methods) {
    methods = Object.keys(source);
  }

  if (typeof source === 'function') destination = promisify(source);

  methods.forEach(function (name) {
    // promisify only if it's a function
    if (typeof source[name] === 'function') destination[name] = promisify(source[name]);
  });

  // proxy the rest
  Object.keys(source).forEach(function (name) {
    if (deprecated(source, name)) return;
    if (destination[name]) return;
    destination[name] = source[name];
  });

  return destination;
}

function deprecated(source, name) {
  var desc = Object.getOwnPropertyDescriptor(source, name);
  if (!desc || !desc.get) return false;
  if (desc.get.name === 'deprecated') return true;
  return false;
}

var fs_1$1 = createCommonjsModule(function (module, exports) {
var fs$$1;
try {
  fs$$1 = gracefulFs;
} catch (err) {
  fs$$1 = fs;
}

var api = ['appendFile', 'chmod', 'chown', 'close', 'fchmod', 'fchown', 'fdatasync', 'fstat', 'fsync', 'ftruncate', 'futimes', 'lchown', 'link', 'lstat', 'mkdir', 'open', 'read', 'readFile', 'readdir', 'readlink', 'realpath', 'rename', 'rmdir', 'stat', 'symlink', 'truncate', 'unlink', 'utimes', 'write', 'writeFile'];

typeof fs$$1.access === 'function' && api.push('access');
typeof fs$$1.copyFile === 'function' && api.push('copyFile');
typeof fs$$1.mkdtemp === 'function' && api.push('mkdtemp');

thenifyAll_1.withCallback(fs$$1, exports, api);

exports.exists = function (filename, callback) {
  // callback
  if (typeof callback === 'function') {
    return fs$$1.stat(filename, function (err) {
      callback(null, !err);
    });
  }
  // or promise
  return new anyPromise(function (resolve) {
    fs$$1.stat(filename, function (err) {
      resolve(!err);
    });
  });
};
});
var fs_2 = fs_1$1.exists;

var dns$1 = createCommonjsModule(function (module, exports) {
thenifyAll_1.withCallback(dns, exports, ['lookup', 'resolve', 'resolve4', 'resolve6', 'resolveCname', 'resolveMx', 'resolveNs', 'resolveSrv', 'resolveTxt', 'reverse']);
});

var zlib$1 = createCommonjsModule(function (module, exports) {
thenifyAll_1.withCallback(zlib, exports, ['deflate', 'deflateRaw', 'gzip', 'gunzip', 'inflate', 'inflateRaw', 'unzip']);
});

var crypto$1 = createCommonjsModule(function (module, exports) {
thenifyAll_1.withCallback(crypto, exports, ['pbkdf2', 'pseudoRandomBytes', 'randomBytes']);
});

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty$2.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

var readline_1 = createCommonjsModule(function (module, exports) {
var Interface = readline.Interface;

function wrapCompleter(completer) {
  if (completer.length === 2) return completer;

  return function (line, cb) {
    var result = completer(line);

    if (typeof result.then !== 'function') {
      return cb(null, result);
    }

    result.catch(cb).then(function (result) {
      process.nextTick(function () {
        cb(null, result);
      });
    });
  };
}

function InterfaceAsPromised(input, output, completer, terminal) {
  if (arguments.length === 1) {
    var options = input;

    if (typeof options.completer === 'function') {
      options = objectAssign({}, options, {
        completer: wrapCompleter(options.completer)
      });
    }

    Interface.call(this, options);
  } else {
    if (typeof completer === 'function') {
      completer = wrapCompleter(completer);
    }

    Interface.call(this, input, output, completer, terminal);
  }
}

InterfaceAsPromised.prototype = Object.create(Interface.prototype);

InterfaceAsPromised.prototype.question = function (question, callback) {
  if (typeof callback === 'function') {
    return Interface.prototype.question.call(this, question, callback);
  }

  var self = this;
  return new anyPromise(function (resolve) {
    Interface.prototype.question.call(self, question, resolve);
  });
};

objectAssign(exports, readline, {
  Interface: InterfaceAsPromised,
  createInterface: function (input, output, completer, terminal) {
    if (arguments.length === 1) {
      return new InterfaceAsPromised(input);
    }

    return new InterfaceAsPromised(input, output, completer, terminal);
  }
});
});

var child_process$1 = createCommonjsModule(function (module, exports) {
thenifyAll_1.withCallback(child_process, exports, ['exec', 'execFile']);
});

var mz = {
  fs: fs_1$1,
  dns: dns$1,
  zlib: zlib$1,
  crypto: crypto$1,
  readline: readline_1,
  child_process: child_process$1
};

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp$1;
var parse_1$6 = parse$b;
var compile_1$1 = compile$1;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse$b(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path$$1 = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path$$1 += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path$$1 += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path$$1) {
      tokens.push(path$$1);
      path$$1 = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path$$1 += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path$$1) {
    tokens.push(path$$1);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile$1(str, options) {
  return tokensToFunction(parse$b(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path$$1 = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path$$1 += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path$$1 += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path$$1 += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path$$1 += token.prefix + segment;
    }

    return path$$1;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path$$1, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path$$1.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path$$1, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path$$1, keys, options) {
  var parts = [];

  for (var i = 0; i < path$$1.length; i++) {
    parts.push(pathToRegexp$1(path$$1[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path$$1, keys, options) {
  return tokensToRegExp(parse$b(path$$1, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp$1(path$$1, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path$$1 instanceof RegExp) {
    return regexpToRegexp(path$$1, /** @type {!Array} */keys);
  }

  if (isarray(path$$1)) {
    return arrayToRegexp( /** @type {!Array} */path$$1, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path$$1, /** @type {!Array} */keys, options);
}
pathToRegexp_1.parse = parse_1$6;
pathToRegexp_1.compile = compile_1$1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/**
 * Routes lib
 * @type {exports}
 */
var pathToRegexpWrap = function (options) {
  options = options || {};

  /**
   * String decoder
   * @param {String} str
   * @returns {*}
   */
  function decodeUri(str) {
    try {
      str = decodeURIComponent(str);
    } catch (e) {
      throw new Error(`Cannot decodeURIComponent: ${str}`);
    }
    return str;
  }

  return function (route) {
    const keys = [];
    const reg = pathToRegexp_1.apply(this, [route, keys, options]);

    return function (route, config) {
      const res = reg.exec(route);
      const params = config || {};

      if (!res) {
        return false;
      }

      for (let i = 1, l = res.length; i < l; i++) {
        if (!res[i]) {
          continue;
        }
        params[keys[i - 1].name] = decodeUri(res[i]);
      }

      return params;
    };
  };
};

var pathExists = fp => new Promise(resolve => {
	fs.access(fp, err => {
		resolve(!err);
	});
});

var sync$3 = fp => {
	try {
		fs.accessSync(fp);
		return true;
	} catch (err) {
		return false;
	}
};
pathExists.sync = sync$3;

var pTry = cb => new Promise(resolve => {
	resolve(cb());
});

var pLimit = concurrency => {
	if (concurrency < 1) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = [];
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.length > 0) {
			queue.shift()();
		}
	};

	return fn => new Promise((resolve, reject) => {
		const run = () => {
			activeCount++;

			pTry(() => fn()).then(val => {
				resolve(val);
				next();
			}, err => {
				reject(err);
				next();
			});
		};

		if (activeCount < concurrency) {
			run();
		} else {
			queue.push(run);
		}
	});
};

class EndError extends Error {
	constructor(value) {
		super();
		this.value = value;
	}
}

// the input can also be a promise, so we `Promise.all()` them both
const finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));

var pLocate = (iterable, tester, opts) => {
	opts = Object.assign({
		concurrency: Infinity,
		preserveOrder: true
	}, opts);

	const limit = pLimit(opts.concurrency);

	// start all the promises concurrently with optional limit
	const items = Array.from(iterable).map(el => [el, limit(() => Promise.resolve(el).then(tester))]);

	// check the promises either serially or concurrently
	const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);

	return Promise.all(items.map(el => checkLimit(() => finder(el)))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));
};

var locatePath = (iterable, opts) => {
	opts = Object.assign({
		cwd: process.cwd()
	}, opts);

	return pLocate(iterable, el => pathExists(path.resolve(opts.cwd, el)), opts);
};

var sync$4 = (iterable, opts) => {
	opts = Object.assign({
		cwd: process.cwd()
	}, opts);

	for (const el of iterable) {
		if (pathExists.sync(path.resolve(opts.cwd, el))) {
			return el;
		}
	}
};
locatePath.sync = sync$4;

var findUp = (filename, opts) => {
	opts = opts || {};

	const startDir = path.resolve(opts.cwd || '');
	const root = path.parse(startDir).root;

	const filenames = [].concat(filename);

	return new Promise(resolve => {
		(function find(dir) {
			locatePath(filenames, { cwd: dir }).then(file => {
				if (file) {
					resolve(path.join(dir, file));
				} else if (dir === root) {
					resolve(null);
				} else {
					find(path.dirname(dir));
				}
			});
		})(startDir);
	});
};

var sync$5 = (filename, opts) => {
	opts = opts || {};

	let dir = path.resolve(opts.cwd || '');
	const root = path.parse(dir).root;

	const filenames = [].concat(filename);

	// eslint-disable-next-line no-constant-condition
	while (true) {
		const file = locatePath.sync(filenames, { cwd: dir });

		if (file) {
			return path.join(dir, file);
		} else if (dir === root) {
			return null;
		}

		dir = path.dirname(dir);
	}
};
findUp.sync = sync$5;

var pkgDir = cwd => findUp('package.json', { cwd }).then(fp => fp ? path.dirname(fp) : null);

var sync$6 = cwd => {
	const fp = findUp.sync('package.json', { cwd });
	return fp ? path.dirname(fp) : null;
};
pkgDir.sync = sync$6;

/**
 * Module dependencies
 * @api private
 */

var deprecate$4 = depd_1('response-time');


/**
 * Module exports
 */

var responseTime_1 = responseTime;

/**
 * Reponse time:
 *
 * Adds the `X-Response-Time` header displaying the response
 * duration in milliseconds.
 *
 * @param {object} [options]
 * @param {number} [options.digits=3]
 * @return {function}
 * @api public
 */

function responseTime(options) {
  var opts = options || {};

  if (typeof options === 'number') {
    // back-compat single number argument
    deprecate$4('number argument: use {digits: ' + JSON.stringify(options) + '} instead');
    opts = { digits: options };
  }

  // get the function to invoke
  var fn = typeof opts !== 'function' ? createSetHeader(opts) : opts;

  return function responseTime(req, res, next) {
    var startAt = process.hrtime();

    onHeaders(res, function onHeaders$$1() {
      var diff = process.hrtime(startAt);
      var time = diff[0] * 1e3 + diff[1] * 1e-6;

      fn(req, res, time);
    });

    next();
  };
}

/**
 * Create function to set respoonse time header.
 * @api private
 */

function createSetHeader(options) {
  // response time digits
  var digits = options.digits !== undefined ? options.digits : 3;

  // header name
  var header = options.header || 'X-Response-Time';

  // display suffix
  var suffix = options.suffix !== undefined ? Boolean(options.suffix) : true;

  return function setResponseHeader(req, res, time) {
    if (res.getHeader(header)) {
      return;
    }

    var val = time.toFixed(digits);

    if (suffix) {
      val += 'ms';
    }

    res.setHeader(header, val);
  };
}

/**
 * Module dependencies.
 * @private
 */

var Buffer$a = safeBuffer.Buffer;





var path$3 = path;
var resolve$4 = path$3.resolve;

/**
 * Module exports.
 * @public
 */

var serveFavicon = favicon;

/**
 * Module variables.
 * @private
 */

var ONE_YEAR_MS = 60 * 60 * 24 * 365 * 1000; // 1 year

/**
 * Serves the favicon located by the given `path`.
 *
 * @public
 * @param {String|Buffer} path
 * @param {Object} [options]
 * @return {Function} middleware
 */

function favicon(path$$1, options) {
  var opts = options || {};

  var icon; // favicon cache
  var maxAge = calcMaxAge(opts.maxAge);

  if (!path$$1) {
    throw new TypeError('path to favicon.ico is required');
  }

  if (Buffer$a.isBuffer(path$$1)) {
    icon = createIcon(Buffer$a.from(path$$1), maxAge);
  } else if (typeof path$$1 === 'string') {
    path$$1 = resolveSync(path$$1);
  } else {
    throw new TypeError('path to favicon.ico must be string or buffer');
  }

  return function favicon(req, res, next) {
    if (parseurl_1(req).pathname !== '/favicon.ico') {
      next();
      return;
    }

    if (req.method !== 'GET' && req.method !== 'HEAD') {
      res.statusCode = req.method === 'OPTIONS' ? 200 : 405;
      res.setHeader('Allow', 'GET, HEAD, OPTIONS');
      res.setHeader('Content-Length', '0');
      res.end();
      return;
    }

    if (icon) {
      send$2(req, res, icon);
      return;
    }

    fs.readFile(path$$1, function (err, buf) {
      if (err) return next(err);
      icon = createIcon(buf, maxAge);
      send$2(req, res, icon);
    });
  };
}

/**
 * Calculate the max-age from a configured value.
 *
 * @private
 * @param {string|number} val
 * @return {number}
 */

function calcMaxAge(val) {
  var num = typeof val === 'string' ? ms(val) : val;

  return num != null ? Math.min(Math.max(0, num), ONE_YEAR_MS) : ONE_YEAR_MS;
}

/**
 * Create icon data from Buffer and max-age.
 *
 * @private
 * @param {Buffer} buf
 * @param {number} maxAge
 * @return {object}
 */

function createIcon(buf, maxAge) {
  return {
    body: buf,
    headers: {
      'Cache-Control': 'public, max-age=' + Math.floor(maxAge / 1000),
      'ETag': etag_1(buf)
    }
  };
}

/**
 * Create EISDIR error.
 *
 * @private
 * @param {string} path
 * @return {Error}
 */

function createIsDirError(path$$1) {
  var error = new Error('EISDIR, illegal operation on directory \'' + path$$1 + '\'');
  error.code = 'EISDIR';
  error.errno = 28;
  error.path = path$$1;
  error.syscall = 'open';
  return error;
}

/**
 * Determine if the cached representation is fresh.
 *
 * @param {object} req
 * @param {object} res
 * @return {boolean}
 * @private
 */

function isFresh(req, res) {
  return fresh_1(req.headers, {
    'etag': res.getHeader('ETag'),
    'last-modified': res.getHeader('Last-Modified')
  });
}

/**
 * Resolve the path to icon.
 *
 * @param {string} iconPath
 * @private
 */

function resolveSync(iconPath) {
  var path$$1 = resolve$4(iconPath);
  var stat = fs.statSync(path$$1);

  if (stat.isDirectory()) {
    throw createIsDirError(path$$1);
  }

  return path$$1;
}

/**
 * Send icon data in response to a request.
 *
 * @private
 * @param {IncomingMessage} req
 * @param {OutgoingMessage} res
 * @param {object} icon
 */

function send$2(req, res, icon) {
  // Set headers
  var headers = icon.headers;
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res.setHeader(key, headers[key]);
  }

  // Validate freshness
  if (isFresh(req, res)) {
    res.statusCode = 304;
    res.end();
    return;
  }

  // Send icon
  res.statusCode = 200;
  res.setHeader('Content-Length', icon.body.length);
  res.setHeader('Content-Type', 'image/x-icon');
  res.end(icon.body);
}

var BuiltInEmitter = require$$0.EventEmitter;

var socketioWildcard = function (CustomEmitter) {
  var Emitter = CustomEmitter || BuiltInEmitter;
  var emit = Emitter.prototype.emit;

  function onevent(packet) {
    var args = packet.data || [];
    if (packet.id != null) {
      args.push(this.ack(packet.id));
    }
    emit.call(this, '*', packet);
    return emit.apply(this, args);
  }

  return function (socket, next) {
    if (socket.onevent !== onevent) {
      socket.onevent = onevent;
    }
    return next ? next() : null;
  };
};

var list = {
  bodyParser: bodyParser_1,
  compression: compression_1,
  // connectRedis,
  cookieParser: cookieParser_1,
  csurf: csurf_1,
  debug: src$2,
  dotenv: main,
  express: express$1,
  // expressDataParser,
  expressSession,
  extend,
  // hbs,
  helmet: helmet_1,
  loadware,
  // log,
  methodOverride,
  mz,
  pathToRegexpWrap,
  pkgDir,
  // pug,
  responseTime: responseTime_1,
  serveFavicon,
  // serveIndex,
  // socketIo,
  socketioWildcard
};

module.exports = list;
